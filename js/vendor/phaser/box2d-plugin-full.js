// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  // void 0 always evaluates to undefined and hence we do not need to depend on
  // the definition of the global variable named 'undefined'.
  return val !== void 0;
};


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retreived from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled, the default can be overridden using compiler command-line
 * options.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else if (goog.global.CLOSURE_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode
 */
goog.define('goog.STRICT_MODE_COMPATIBLE', false);


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Provided objects must not be null or undefined.
 * Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice. This is intended
    // to teach new developers that 'goog.provide' is effectively a variable
    // declaration. And when JSCompiler transforms goog.provide into a real
    // variable declaration, the compiled JS should work the same as the raw
    // JS--even when the raw JS uses goog.provide incorrectly.
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return !goog.implicitNamespaces_[name] &&
        goog.isDefAndNotNull(goog.getObjectByName(name));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {Object}
   * @private
   */
  goog.implicitNamespaces_ = {};
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function(relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 */
goog.require = function(name) {

  // If the object already exists we do not need do do anything.
  // TODO(arv): If we start to support require based on file name this has to
  //            change.
  // TODO(arv): If we allow goog.foo.* this has to change.
  // TODO(arv): If we implement dynamic load after page load we should probably
  //            not remove this code for the compiled output.
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }


      throw Error(errorMessage);

  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * Object used to keep track of urls that have already been added. This record
   * allows the prevention of circular dependencies.
   * @type {Object}
   * @private
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {Object}
   */
  goog.dependencies_ = {
    pathToNames: {}, // 1 to many
    nameToPath: {}, // 1 to 1
    requires: {}, // 1 to many
    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},
    written: {} // Used to keep track of script files we have written.
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @private
   */
  goog.importScript_ = function(src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script source.
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page.
      if (doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      doc.write(
          '<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };


  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    // The scripts we need to write this time.
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  // if (!goog.global.CLOSURE_NO_DEPS) {
  //   goog.importScript_(goog.basePath + 'deps.js');
  // }
}



//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is alreay assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {Object} obj The object to check.
 * @return {boolean} Whether there an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 2);
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
    throw Error('arguments.caller not defined.  goog.base() cannot be used ' +
                'with strict mode code. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
  }

  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}



//==============================================================================
// goog.defineClass implementation
//==============================================================================

/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing the
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw Error('cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {
 *     !Object|
 *     {constructor:!Function}|
 *     {constructor:!Function, statics:(Object|function(Function):void)}}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by
 * goog.defineClass should be sealed when possible.
 */
goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (goog.defineClass.SEAL_CLASS_INSTANCES &&
      Object.seal instanceof Function) {
    // Don't seal subclasses of unsealable-tagged legacy classes.
    if (superClass && superClass.prototype &&
        superClass.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
      return ctr;
    }
    /** @this {*} */
    var wrappedCtr = function() {
      // Don't seal an instance of a subclass when it calls the constructor of
      // its super class as there is most likely still setup to do.
      var instance = ctr.apply(this, arguments) || this;
      if (this.constructor === wrappedCtr) {
        Object.seal(instance);
      }
      return instance;
    };
    return wrappedCtr;
  }
  return ctr;
};


// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array.<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properites from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};


/**
 * Sealing classes breaks the older idiom of assigning properties on the
 * prototype rather than in the constructor.  As such, goog.defineClass
 * must not seal subclasses of these old-style classes until they are fixed.
 * Until then, this marks a class as "broken", instructing defineClass
 * not to seal subclasses.
 * @param {!Function} ctr The legacy constructor to tag as unsealable.
 */
goog.tagUnsealableClass = function(ctr) {
  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
  }
};


/**
 * Name for unsealable tag property.
 * @const @private {string}
 */
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';
/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Settings');

//goog.require('goog.asserts');
//goog.require('goog.string.format');

if (!Object.defineProperty)
{
	Object.defineProperty = function (obj, name, options)
	{
		if (Object.__defineGetter__)
		{
			if ('get' in options)
			{
				obj.__defineGetter__(name, options.get);
			}
			else if ('value' in options)
			{
				obj.__defineGetter__(name, options.value);
			}
		}

		if (Object.__defineSetter__)
		{
			if ('set' in options)
			{
				obj.__defineSetter__(name, options.set);
			}
			else if ('value' in options)
			{
				obj.__defineSetter__(name, options.value);
			}
		}
	}
}

/** 
 * @export 
 * @define {boolean}
 */
box2d.DEBUG = false;

/** 
 * @export 
 * @define {boolean}
 */
box2d.ENABLE_ASSERTS = box2d.DEBUG;

/** 
 * @export 
 * @return {void} 
 * @param {boolean} condition 
 * @param {string=} opt_message 
 * @param {...} var_args 
 */
box2d.b2Assert = function (condition, opt_message, var_args)
{
	if (box2d.DEBUG)
	{
		if (!condition)
		{
			debugger;
		}
	
		//goog.asserts.assert(condition, opt_message, var_args);
	}
}

/**
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxFloat = 1E+37; // FLT_MAX instead of Number.MAX_VALUE;
/**
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_epsilon = 1E-5; // FLT_EPSILON instead of Number.MIN_VALUE;
/**
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_epsilon_sq = (box2d.b2_epsilon * box2d.b2_epsilon);
/**
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_pi = Math.PI;

/**
 * Global tuning constants based on meters-kilograms-seconds 
 * (MKS) units. 
 */

// Collision

/** 
 * The maximum number of contact points between two convex 
 * shapes. Do not change this value. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxManifoldPoints = 2;

/** 
 * The maximum number of vertices on a convex polygon. You 
 * cannot increase this too much because b2BlockAllocator has a 
 * maximum object size. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxPolygonVertices = 8;

/** 
 * This is used to fatten AABBs in the dynamic tree. This allows 
 * proxies to move by a small amount without triggering a tree 
 * adjustment. 
 * This is in meters. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_aabbExtension = 0.1;

/** 
 * This is used to fatten AABBs in the dynamic tree. This is 
 * used to predict the future position based on the current 
 * displacement. 
 * This is a dimensionless multiplier. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_aabbMultiplier = 2;

/** 
 * A small length used as a collision and constraint tolerance. 
 * Usually it is chosen to be numerically significant, but 
 * visually insignificant. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_linearSlop = 0.008; //0.005;

/** 
 * A small angle used as a collision and constraint tolerance. 
 * Usually it is chosen to be numerically significant, but 
 * visually insignificant. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi;

/** 
 * The radius of the polygon/edge shape skin. This should not be 
 * modified. Making this smaller means polygons will have an 
 * insufficient buffer for continuous collision. 
 * Making it larger may create artifacts for vertex collision.
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop;

/** 
 * Maximum number of sub-steps per contact in continuous physics 
 * simulation. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxSubSteps = 8;


// Dynamics

/** 
 * Maximum number of contacts to be handled to solve a TOI 
 * impact. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxTOIContacts = 32;

/** 
 * A velocity threshold for elastic collisions. Any collision 
 * with a relative linear velocity below this threshold will be 
 * treated as inelastic. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_velocityThreshold = 1;

/** 
 * The maximum linear position correction used when solving 
 * constraints. This helps to prevent overshoot. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxLinearCorrection = 0.2;

/** 
 * The maximum angular position correction used when solving 
 * constraints. This helps to prevent overshoot. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi;

/** 
 * The maximum linear velocity of a body. This limit is very 
 * large and is used to prevent numerical problems. You 
 * shouldn't need to adjust this. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxTranslation = 2;
/** 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation;

/** 
 * The maximum angular velocity of a body. This limit is very 
 * large and is used to prevent numerical problems. You 
 * shouldn't need to adjust this. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxRotation = 0.5 * box2d.b2_pi;
/** 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation;

/** 
 * This scale factor controls how fast overlap is resolved. 
 * Ideally this would be 1 so that overlap is removed in one 
 * time step. However using values close to 1 often lead to 
 * overshoot. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_baumgarte = 0.2;
/** 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_toiBaumgarte = 0.75;



// Sleep

/** 
 * The time that a body must be still before it will go to 
 * sleep. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_timeToSleep = 0.5;

/** 
 * A body cannot sleep if its linear velocity is above this 
 * tolerance. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_linearSleepTolerance = 0.01;

/** 
 * A body cannot sleep if its angular velocity is above this 
 * tolerance. 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi;

// Memory Allocation

/** 
 * Implement this function to use your own memory allocator. 
 * @export 
 * @return {*} 
 * @param {number} size 
 */
box2d.b2Alloc = function (size)
{
	return null;
}

/** 
 * If you implement b2Alloc, you should also implement this 
 * function. 
 * @export  
 * @return {void} 
 * @param {*} mem 
 */
box2d.b2Free = function (mem)
{
}

/** 
 * Logging function. 
 * You can modify this to use your logging facility.
 * @export 
 * @return {void} 
 * @param {...string|number|boolean} var_args 
 */
box2d.b2Log = function (var_args)
{
	goog.global.console.log.apply(null, arguments);
}

/** 
 * Version numberinf scheme See 
 * http://en.wikipedia.org/wiki/Software_versioning 
 * @export 
 * @constructor
 * @param {number=} major 
 * @param {number=} minor 
 * @param {number=} revision 
 */
box2d.b2Version = function (major, minor, revision)
{
	this.major = major || 0;
	this.minor = minor || 0;
	this.revision = revision || 0;
};

/**
 * @export 
 * @type {number} 
 */
box2d.b2Version.prototype.major = 0; ///< significant changes
/**
 * @export 
 * @type {number} 
 */
box2d.b2Version.prototype.minor = 0; ///< incremental changes
/**
 * @export 
 * @type {number} 
 */
box2d.b2Version.prototype.revision = 0; ///< bug fixes

/**
 * @export 
 * @return {string}
 */
box2d.b2Version.prototype.toString = function ()
{
	return this.major + "." + this.minor + "." + this.revision;
}

/** 
 * Current version. 
 * @export 
 * @const 
 * @type {box2d.b2Version} 
 */
box2d.b2_version = new box2d.b2Version(2, 3, 0);
/** 
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_changelist = 278;

/** 
 * @export 
 * @return {number} 
 * @param {string} v 
 */
box2d.b2ParseInt = function (v)
{
	return parseInt(v, 10);
}

/**
 * @export 
 * @return {number} 
 * @param {string} v 
 */
box2d.b2ParseUInt = function (v)
{
	return box2d.b2Abs(parseInt(v, 10));
}

/** 
 * @export 
 * @return {Array.<*>} 
 * @param {number=} length 
 * @param {function(number): *=} init 
 */
box2d.b2MakeArray = function (length, init)
{
	if (length === undefined) length = 0;
	var a = new Array(length);
	if (init !== undefined)
	{
		for (var i = 0; i < length; ++i)
		{
			a[i] = init(i);
		}
	}
	return a;
}

/** 
 * @export 
 * @return {Array.<number>} 
 * @param {number=} length
 */
box2d.b2MakeNumberArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return 0; });
}

/*
* Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Math');

goog.require('box2d.b2Settings');

/**
 * @export 
 * @type {number} 
 */
box2d.b2_pi_over_180 = box2d.b2_pi / 180.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2_180_over_pi = 180.0 / box2d.b2_pi;
/**
 * @export 
 * @type {number} 
 */
box2d.b2_two_pi = 2.0 * box2d.b2_pi;

/** 
 * @export 
 * @return {number}
 * @param {number} n
 */
box2d.b2Abs = function (n)
{
	return (n < 0)?(-n):(n);
}

/**
 * @export 
 * @return {number}
 * @param {number} a
 * @param {number} b
 */
box2d.b2Min = function (a, b)
{
	return (a < b)?(a):(b);
}

/**
 * @export 
 * @return {number}
 * @param {number} a
 * @param {number} b
 */
box2d.b2Max = function (a, b)
{
	return (a > b)?(a):(b);
}

/**
 * @export 
 * @return {number}
 * @param {number} a
 * @param {number} lo
 * @param {number} hi
 */
box2d.b2Clamp = function (a, lo, hi)
{
	return (a < lo)?(lo):((a > hi)?(hi):(a));
}

/**
 * @export 
 * @return {void} 
 * @param {Array.<number>} a
 * @param {Array.<number>} b
 */
box2d.b2Swap = function (a, b)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
	var tmp = a[0];
	a[0] = b[0];
	b[0] = tmp;
}

/** 
 * This function is used to ensure that a floating point number 
 * is not a NaN or infinity. 
 * @export 
 * @return {boolean}
 * @param {number} n
 */
box2d.b2IsValid = function (n)
{
	return isFinite(n);
}

/**
 * @export 
 * @return {number} 
 * @param {number} n
 */
box2d.b2Sq = function (n)
{
	return n * n;
}

/** 
 * This is a approximate yet fast inverse square-root. 
 * @export 
 * @return {number}
 * @param {number} n
 */
box2d.b2InvSqrt = function (n)
{
	return 1 / Math.sqrt(n);
}

/**
 * @export 
 * @return {number}
 * @param {number} n
 */
box2d.b2Sqrt = function (n)
{
	return Math.sqrt(n);
}

/**
 * @export 
 * @return {number}
 * @param {number} x
 * @param {number} y
 */
box2d.b2Pow = function (x, y)
{
	return Math.pow(x, y);
}

/**
 * @export 
 * @return {number}
 * @param {number} degrees
 */
box2d.b2DegToRad = function (degrees)
{
	return degrees * box2d.b2_pi_over_180;
}

/**
 * @export 
 * @return {number}
 * @param {number} radians
 */
box2d.b2RadToDeg = function (radians)
{
	return radians * box2d.b2_180_over_pi;
}

/**
 * @export 
 * @return {number}
 * @param {number} radians
 */
box2d.b2Cos = function (radians)
{
	return Math.cos(radians);
}

/**
 * @export 
 * @return {number}
 * @param {number} radians
 */
box2d.b2Sin = function (radians)
{
	return Math.sin(radians);
}

/**
 * @export 
 * @return {number}
 * @param {number} n
 */
box2d.b2Acos = function (n)
{
	return Math.acos(n);
}

/**
 * @export 
 * @return {number}
 * @param {number} n
 */
box2d.b2Asin = function (n)
{
	return Math.asin(n);
}

/**
 * @export 
 * @return {number}
 * @param {number} y
 * @param {number} x
 */
box2d.b2Atan2 = function (y, x)
{
	return Math.atan2(y, x);
}

/** 
 * Next Largest Power of 2 
 * Given a binary integer value x, the next largest power of 2 
 * can be computed by a SWAR algorithm that recursively "folds" 
 * the upper bits into the lower bits. This process yields a bit 
 * vector with the same most significant 1 as x, but all 1's 
 * below it. Adding 1 to that value yields the next largest 
 * power of 2. For a 32-bit value: 
 * @export 
 * @return {number}
 * @param {number} x
 */
box2d.b2NextPowerOfTwo = function (x)
{
	x |= (x >> 1) & 0x7FFFFFFF;
	x |= (x >> 2) & 0x3FFFFFFF;
	x |= (x >> 4) & 0x0FFFFFFF;
	x |= (x >> 8) & 0x00FFFFFF;
	x |= (x >> 16) & 0x0000FFFF;
	return x + 1;
}

/**
 * @export 
 * @return {boolean}
 * @param {number} x
 */
box2d.b2IsPowerOfTwo = function (x)
{
	return x > 0 && (x & (x - 1)) === 0;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2Random = function ()
{
	return Math.random() * 2.0 - 1.0;
}

/**
 * @export 
 * @return {number}
 * @param {number} lo
 * @param {number} hi
 */
box2d.b2RandomRange = function (lo, hi)
{
	return (hi - lo) * Math.random() + lo;
}

/** 
 * A 2D column vector. 
 * @export 
 * @constructor 
 * @param {number=} x
 * @param {number=} y
 */
box2d.b2Vec2 = function (x, y)
{
	this.x = x || 0.0;
	this.y = y || 0.0;
	//this.a = new Float32Array(2);
	//this.a[0] = x || 0;
	//this.a[1] = y || 0;
}

/**
 * @export 
 * @type {number} 
 */
box2d.b2Vec2.prototype.x = 0.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Vec2.prototype.y = 0.0;

//	/**
//	 * @type {Float32Array} 
//	 */
//	box2d.b2Vec2.prototype.a;
//	
//	box2d.b2Vec2.prototype.__defineGetter__('x', function () { return this.a[0]; });
//	box2d.b2Vec2.prototype.__defineGetter__('y', function () { return this.a[1]; });
//	box2d.b2Vec2.prototype.__defineSetter__('x', function (n) { this.a[0] = n; });
//	box2d.b2Vec2.prototype.__defineSetter__('y', function (n) { this.a[1] = n; });

/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2_zero = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.ZERO = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.UNITX = new box2d.b2Vec2(1.0, 0.0);
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.UNITY = new box2d.b2Vec2(0.0, 1.0);

/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.s_t0 = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.s_t1 = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.s_t2 = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Vec2.s_t3 = new box2d.b2Vec2();

/**
 * @export 
 * @return {Array.<box2d.b2Vec2>}
 * @param {number=} length
 */
box2d.b2Vec2.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2Vec2(); });
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.Clone = function ()
{
	return new box2d.b2Vec2(this.x, this.y);
}

/** 
 * Set this vector to all zeros. 
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.SetZero = function ()
{
	this.x = 0.0;
	this.y = 0.0;
	return this;
}

/** 
 * Set this vector to some specified coordinates. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} x
 * @param {number} y
 */
box2d.b2Vec2.prototype.SetXY = function (x, y)
{
	this.x = x;
	this.y = y;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} other
 */
box2d.b2Vec2.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.x = other.x;
	this.y = other.y;
	return this;
}

/** 
 * Add a vector to this vector. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfAdd = function (v)
{
	this.x += v.x;
	this.y += v.y;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} x 
 * @param {number} y 
 */
box2d.b2Vec2.prototype.SelfAddXY = function (x, y)
{
	this.x += x;
	this.y += y;
	return this;
}

/** 
 * Subtract a vector from this vector. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfSub = function (v)
{
	this.x -= v.x;
	this.y -= v.y;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} x 
 * @param {number} y 
 */
box2d.b2Vec2.prototype.SelfSubXY = function (x, y)
{
	this.x -= x;
	this.y -= y;
	return this;
}

/** 
 * Multiply this vector by a scalar. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 */
box2d.b2Vec2.prototype.SelfMul = function (s)
{
	this.x *= s;
	this.y *= s;
	return this;
}

/** 
 * this += s * v 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfMulAdd = function (s, v)
{
	this.x += s * v.x;
	this.y += s * v.y;
	return this;
}

/** 
 * this -= s * v 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfMulSub = function (s, v)
{
	this.x -= s * v.x;
	this.y -= s * v.y;
	return this;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.Dot = function (v)
{
	return this.x * v.x + this.y * v.y;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.Cross = function (v)
{
	return this.x * v.y - this.y * v.x;
}

/** 
 * Get the length of this vector (the norm). 
 * @export 
 * @return {number}
 */
box2d.b2Vec2.prototype.Length = function ()
{
	var x = this.x, y = this.y;
	return Math.sqrt(x * x + y * y);
}

/** 
 * @export 
 * @return {number} 
 */
box2d.b2Vec2.prototype.GetLength = box2d.b2Vec2.prototype.Length;

/** 
 * Get the length squared. For performance, use this instead of 
 * b2Vec2::Length (if possible). 
 * @export 
 * @return {number}
 */
box2d.b2Vec2.prototype.LengthSquared = function ()
{
	var x = this.x, y = this.y;
	return (x * x + y * y);
}

/** 
 * @export 
 * @return {number} 
 */
box2d.b2Vec2.prototype.GetLengthSquared = box2d.b2Vec2.prototype.LengthSquared;

/** 
 * Convert this vector into a unit vector. Returns the length. 
 * @export 
 * @return {number}
 */
box2d.b2Vec2.prototype.Normalize = function ()
{
	var length = this.GetLength();
	if (length >= box2d.b2_epsilon)
	{
		var inv_length = 1.0 / length;
		this.x *= inv_length;
		this.y *= inv_length;
	}
	return length;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.SelfNormalize = function ()
{
	var length = this.GetLength();
	if (length >= box2d.b2_epsilon)
	{
		var inv_length = 1.0 / length;
		this.x *= inv_length;
		this.y *= inv_length;
	}
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} c
 * @param {number} s
 */
box2d.b2Vec2.prototype.SelfRotate = function (c, s)
{
	var x = this.x, y = this.y;
	this.x = c * x - s * y;
	this.y = s * x + c * y;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} radians
 */
box2d.b2Vec2.prototype.SelfRotateRadians = function (radians)
{
	return this.SelfRotate(Math.cos(radians), Math.sin(radians));
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} degrees
 */
box2d.b2Vec2.prototype.SelfRotateDegrees = function (degrees)
{
	return this.SelfRotateRadians(box2d.b2DegToRad(degrees));
}

/** 
 * Does this vector contain finite coordinates? 
 * @export 
 * @return {boolean}
 */
box2d.b2Vec2.prototype.IsValid = function ()
{
	return isFinite(this.x) && isFinite(this.y);
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 */
box2d.b2Vec2.prototype.SelfCrossVS = function (s)
{
	var x = this.x;
	this.x =  s * this.y;
	this.y = -s * x;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 */
box2d.b2Vec2.prototype.SelfCrossSV = function (s)
{
	var x = this.x;
	this.x = -s * this.y;
	this.y =  s * x;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfMinV = function (v)
{
	this.x = box2d.b2Min(this.x, v.x);
	this.y = box2d.b2Min(this.y, v.y);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 */
box2d.b2Vec2.prototype.SelfMaxV = function (v)
{
	this.x = box2d.b2Max(this.x, v.x);
	this.y = box2d.b2Max(this.y, v.y);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.SelfAbs = function ()
{
	this.x = box2d.b2Abs(this.x);
	this.y = box2d.b2Abs(this.y);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.SelfNeg = function ()
{
	this.x = (-this.x);
	this.y = (-this.y);
	return this;
}

/** 
 * Get the skew vector such that dot(skew_vec, other) === 
 * cross(vec, other) 
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Vec2.prototype.SelfSkew = function ()
{
	var x = this.x;
	this.x = -this.y;
	this.y = x;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2AbsV = function (v, out)
{
	out.x = box2d.b2Abs(v.x);
	out.y = box2d.b2Abs(v.y);
	return out;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2MinV = function (a, b, out)
{
	out.x = box2d.b2Min(a.x, b.x);
	out.y = box2d.b2Min(a.y, b.y);
	return out;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2MaxV = function (a, b, out)
{
	out.x = box2d.b2Max(a.x, b.x);
	out.y = box2d.b2Max(a.y, b.y);
	return out;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} lo
 * @param {box2d.b2Vec2} hi
 * @param {box2d.b2Vec2} out
 */
box2d.b2ClampV = function (v, lo, hi, out)
{
	out.x = box2d.b2Clamp(v.x, lo.x, hi.x);
	out.y = box2d.b2Clamp(v.y, lo.y, hi.y);
	return out;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {number} c
 * @param {number} s
 * @param {box2d.b2Vec2} out
 */
box2d.b2RotateV = function (v, c, s, out)
{
	var v_x = v.x, v_y = v.y;
	out.x = c * v_x - s * v_y;
	out.y = s * v_x + c * v_y;
	return out;
}

/** 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {number} radians
 * @param {box2d.b2Vec2} out
 */
box2d.b2RotateRadiansV = function (v, radians, out)
{
	return box2d.b2RotateV(v, Math.cos(radians), Math.sin(radians), out);
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {number} degrees
 * @param {box2d.b2Vec2} out
 */
box2d.b2RotateDegreesV = function (v, degrees, out)
{
	return box2d.b2RotateRadiansV(v, box2d.b2DegToRad(degrees), out);
}

/** 
 * Perform the dot product on two vectors. 
 * a.x * b.x + a.y * b.y 
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 */
box2d.b2DotVV = function (a, b)
{
	return a.x * b.x + a.y * b.y;
}

/** 
 * Perform the cross product on two vectors. In 2D this produces a scalar. 
 * a.x * b.y - a.y * b.x 
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 */
box2d.b2CrossVV = function (a, b)
{
	return a.x * b.y - a.y * b.x;
}

/** 
 * Perform the cross product on a vector and a scalar. In 2D 
 * this produces a vector. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {number} s
 * @param {box2d.b2Vec2} out
 */
box2d.b2CrossVS = function (v, s, out)
{
	var v_x = v.x;
	out.x =  s * v.y;
	out.y = -s * v_x;
	return out;
}

/**
 * box2d.b2CrossVS(v, 1.0, out) 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2CrossVOne = function (v, out)
{
	var v_x = v.x;
	out.x =  v.y;
	out.y = -v_x;
	return out;
}

/** 
 * Perform the cross product on a scalar and a vector. In 2D 
 * this produces a vector. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2CrossSV = function (s, v, out)
{
	var v_x = v.x;
	out.x = -s * v.y;
	out.y =  s * v_x;
	return out;
}

/** 
 * box2d.b2CrossSV(1.0, v, out) 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2CrossOneV = function (v, out)
{
	var v_x = v.x;
	out.x = -v.y;
	out.y =  v_x;
	return out;
}

/** 
 * Add two vectors component-wise. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2AddVV = function (a, b, out) { out.x = a.x + b.x; out.y = a.y + b.y; return out; }

/** 
 * Subtract two vectors component-wise. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2SubVV = function (a, b, out) { out.x = a.x - b.x; out.y = a.y - b.y; return out; }

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} s
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulSV = function (s, v, out) { out.x = v.x * s; out.y = v.y * s; return out; }

/** 
 * out = a + (s * b)
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {number} s
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2AddVMulSV = function (a, s, b, out) { out.x = a.x + (s * b.x); out.y = a.y + (s * b.y); return out; }
/** 
 * out = a - (s * b)
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {number} s
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2SubVMulSV = function (a, s, b, out) { out.x = a.x - (s * b.x); out.y = a.y - (s * b.y); return out; }

/** 
 * out = a + b2CrossSV(s, v) 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} a
 * @param {number} s
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out 
 */
box2d.b2AddVCrossSV = function (a, s, v, out)
{
	var v_x = v.x;
	out.x = a.x - (s * v.y);
	out.y = a.y + (s * v_x);
	return out;
}

/** 
 * Get the center of two vectors. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2MidVV = function (a, b, out) { out.x = (a.x + b.x) * 0.5; out.y = (a.y + b.y) * 0.5; return out; }

/** 
 * Get the extent of two vectors (half-widths). 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 * @param {box2d.b2Vec2} out
 */
box2d.b2ExtVV = function (a, b, out) { out.x = (b.x - a.x) * 0.5; out.y = (b.y - a.y) * 0.5; return out; }

/**
 * @export 
 * @return {boolean}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 */
box2d.b2IsEqualToV = function (a, b)
{
	return a.x === b.x && a.y === b.y;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 */
box2d.b2DistanceVV = function (a, b)
{
	var c_x = a.x - b.x;
	var c_y = a.y - b.y;
	return Math.sqrt(c_x * c_x + c_y * c_y);
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} a
 * @param {box2d.b2Vec2} b
 */
box2d.b2DistanceSquaredVV = function (a, b)
{
	var c_x = a.x - b.x;
	var c_y = a.y - b.y;
	return (c_x * c_x + c_y * c_y);
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2NegV = function (v, out) { out.x = -v.x; out.y = -v.y; return out; }

/** 
 * @export 
 * @constructor 
 * @param {number=} x
 * @param {number=} y
 * @param {number=} z
 */
box2d.b2Vec3 = function (x, y, z)
{
	this.x = x || 0.0;
	this.y = y || 0.0;
	this.z = z || 0.0;
	//this.a = new Float32Array(3);
	//this.a[0] = x || 0;
	//this.a[1] = y || 0;
	//this.a[2] = z || 0;
}

/**
 * @export 
 * @type {number} 
 */
box2d.b2Vec3.prototype.x = 0.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Vec3.prototype.y = 0.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Vec3.prototype.z = 0.0;

//	/**
//	 * @type {Float32Array} 
//	 */
//	box2d.b2Vec3.prototype.a;
//	
//	box2d.b2Vec3.prototype.__defineGetter__('x', function () { return this.a[0]; });
//	box2d.b2Vec3.prototype.__defineGetter__('y', function () { return this.a[1]; });
//	box2d.b2Vec3.prototype.__defineGetter__('z', function () { return this.a[2]; });
//	box2d.b2Vec3.prototype.__defineSetter__('x', function (n) { this.a[0] = n; });
//	box2d.b2Vec3.prototype.__defineSetter__('y', function (n) { this.a[1] = n; });
//	box2d.b2Vec3.prototype.__defineSetter__('z', function (n) { this.a[2] = n; });

/**
 * @export 
 * @type {box2d.b2Vec3}
 */
box2d.b2Vec3.ZERO = new box2d.b2Vec3();
/**
 * @export 
 * @type {box2d.b2Vec3}
 */
box2d.b2Vec3.s_t0 = new box2d.b2Vec3();

/**
 * @export 
 * @return {box2d.b2Vec3}
 */
box2d.b2Vec3.prototype.Clone = function ()
{
	return new box2d.b2Vec3(this.x, this.y, this.z);
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 */
box2d.b2Vec3.prototype.SetZero = function ()
{
	this.x = 0.0;
	this.y = 0.0;
	this.z = 0.0;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {number} x
 * @param {number} y
 * @param {number} z
 */
box2d.b2Vec3.prototype.SetXYZ = function (x, y, z)
{
	this.x = x;
	this.y = y;
	this.z = z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Vec3} other
 */
box2d.b2Vec3.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.x = other.x;
	this.y = other.y;
	this.z = other.z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 */
box2d.b2Vec3.prototype.SelfNeg = function ()
{
	this.x = (-this.x);
	this.y = (-this.y);
	this.z = (-this.z);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Vec3} v
 */
box2d.b2Vec3.prototype.SelfAdd = function (v)
{
	this.x += v.x;
	this.y += v.y;
	this.z += v.z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {number} x 
 * @param {number} y 
 * @param {number} z 
 */
box2d.b2Vec3.prototype.SelfAddXYZ = function (x, y, z)
{
	this.x += x;
	this.y += y;
	this.z += z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Vec3} v
 */
box2d.b2Vec3.prototype.SelfSub = function (v)
{
	this.x -= v.x;
	this.y -= v.y;
	this.z -= v.z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {number} x 
 * @param {number} y 
 * @param {number} z 
 */
box2d.b2Vec3.prototype.SelfSubXYZ = function (x, y, z)
{
	this.x -= x;
	this.y -= y;
	this.z -= z;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {number} s
 */
box2d.b2Vec3.prototype.SelfMul = function (s)
{
	this.x *= s;
	this.y *= s;
	this.z *= s;
	return this;
}

/** 
 * Perform the dot product on two vectors. 
 * @export 
 * @return {number}
 * @param {box2d.b2Vec3} a
 * @param {box2d.b2Vec3} b
 */
box2d.b2DotV3V3 = function (a, b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/** 
 * Perform the cross product on two vectors. 
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Vec3} a
 * @param {box2d.b2Vec3} b
 * @param {box2d.b2Vec3} out
 */
box2d.b2CrossV3V3 = function (a, b, out)
{
	var a_x = a.x, a_y = a.y, a_z = a.z;
	var b_x = b.x, b_y = b.y, b_z = b.z;
	out.x = a_y * b_z - a_z * b_y;
	out.y = a_z * b_x - a_x * b_z;
	out.z = a_x * b_y - a_y * b_x;
	return out;
}

/** 
 * A 2-by-2 matrix. Stored in column-major order. 
 * @export 
 * @constructor 
 */
box2d.b2Mat22 = function ()
{
	this.ex = new box2d.b2Vec2(1.0, 0.0);
	this.ey = new box2d.b2Vec2(0.0, 1.0);
}

/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Mat22.prototype.ex = null;
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Mat22.prototype.ey = null;

/**
 * @export 
 * @type {box2d.b2Mat22} 
 */
box2d.b2Mat22.IDENTITY = new box2d.b2Mat22();

/**
 * @export 
 * @return {box2d.b2Mat22}
 */
box2d.b2Mat22.prototype.Clone = function ()
{
	return new box2d.b2Mat22().Copy(this);
}

/** 
 * Construct this matrix using columns. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Vec2} c1
 * @param {box2d.b2Vec2} c2
 */
box2d.b2Mat22.FromVV = function (c1, c2)
{
	return new box2d.b2Mat22().SetVV(c1, c2);
}

/** 
 * Construct this matrix using scalars. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {number} r1c1 or ex.x
 * @param {number} r1c2 or ey.x
 * @param {number} r2c1 or ex.y
 * @param {number} r2c2 or ey.y
 */
box2d.b2Mat22.FromSSSS = function (r1c1, r1c2, r2c1, r2c2)
{
	return new box2d.b2Mat22().SetSSSS(r1c1, r1c2, r2c1, r2c2);
}

/** 
 * Construct this matrix using an angle. This matrix becomes an 
 * orthonormal rotation matrix. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {number} radians
 */
box2d.b2Mat22.FromAngleRadians = function (radians)
{
	return new box2d.b2Mat22().SetAngleRadians(radians);
}

/** 
 * Initialize this matrix using scalars. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {number} r1c1 or ex.x
 * @param {number} r1c2 or ey.x
 * @param {number} r2c1 or ex.y
 * @param {number} r2c2 or ey.y
 */
box2d.b2Mat22.prototype.SetSSSS = function (r1c1, r1c2, r2c1, r2c2)
{
	this.ex.SetXY(r1c1, r2c1);
	this.ey.SetXY(r1c2, r2c2);
	return this;
}

/** 
 * Initialize this matrix using columns. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Vec2} c1
 * @param {box2d.b2Vec2} c2
 */
box2d.b2Mat22.prototype.SetVV = function (c1, c2)
{
	this.ex.Copy(c1);
	this.ey.Copy(c2);
	return this;
}

/** 
 * Initialize this matrix using an angle. This matrix becomes an 
 * orthonormal rotation matrix. 
 * @export 
 * @return {box2d.b2Mat22}
 * @param {number} radians
 */
box2d.b2Mat22.prototype.SetAngle = function (radians)
{
	var c = Math.cos(radians);
	var s = Math.sin(radians);
	this.ex.SetXY( c, s);
	this.ey.SetXY(-s, c);
	return this;
}

box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle;

box2d.b2Mat22.prototype.SetAngleDegrees = function (angle) { return this.SetAngle(box2d.b2DegToRad(angle)); }

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} other
 */
box2d.b2Mat22.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.ex.Copy(other.ex);
	this.ey.Copy(other.ey);
	return this;
}

/** 
 * Set this to the identity matrix. 
 * @export 
 * @return {box2d.b2Mat22}
 */
box2d.b2Mat22.prototype.SetIdentity = function ()
{
	this.ex.SetXY(1.0, 0.0);
	this.ey.SetXY(0.0, 1.0);
	return this;
}

/** 
 * Set this matrix to all zeros. 
 * @export 
 * @return {box2d.b2Mat22}
 */
box2d.b2Mat22.prototype.SetZero = function ()
{
	this.ex.SetZero();
	this.ey.SetZero();
	return this;
}

/** 
 * Extract the angle from this matrix (assumed to be a rotation 
 * matrix). 
 * @export 
 * @return {number}
 */
box2d.b2Mat22.prototype.GetAngle = function ()
{
	return Math.atan2(this.ex.y, this.ex.x);
}

box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle;

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} out
 */
box2d.b2Mat22.prototype.GetInverse = function (out)
{
	var a = this.ex.x;
	var b = this.ey.x;
	var c = this.ex.y;
	var d = this.ey.y;
	var det = a * d - b * c;
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}
	out.ex.x =   det * d;
	out.ey.x = (-det * b);
	out.ex.y = (-det * c);
	out.ey.y =   det * a;
	return out;
}

/** 
 * Solve A * x = b, where b is a column vector. This is more 
 * efficient than computing the inverse in one-shot cases. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} b_x
 * @param {number} b_y
 * @param {box2d.b2Vec2} out
 */
box2d.b2Mat22.prototype.Solve = function (b_x, b_y, out)
{
	var a11 = this.ex.x, a12 = this.ey.x;
	var a21 = this.ex.y, a22 = this.ey.y;
	var det = a11 * a22 - a12 * a21;
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}
	out.x = det * (a22 * b_x - a12 * b_y);
	out.y = det * (a11 * b_y - a21 * b_x);
	return out;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 */
box2d.b2Mat22.prototype.SelfAbs = function ()
{
	this.ex.SelfAbs();
	this.ey.SelfAbs();
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 */
box2d.b2Mat22.prototype.SelfInv = function ()
{
	return this.GetInverse(this);
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} M
 */
box2d.b2Mat22.prototype.SelfAddM = function (M)
{
	this.ex.SelfAdd(M.ex);
	this.ey.SelfAdd(M.ey);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} M
 */
box2d.b2Mat22.prototype.SelfSubM = function (M)
{
	this.ex.SelfSub(M.ex);
	this.ey.SelfSub(M.ey);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} M
 * @param {box2d.b2Mat22} out
 */
box2d.b2AbsM = function (M, out)
{
	var M_ex = M.ex, M_ey = M.ey;
	out.ex.x = box2d.b2Abs(M_ex.x);
	out.ex.y = box2d.b2Abs(M_ex.y);
	out.ey.x = box2d.b2Abs(M_ey.x);
	out.ey.y = box2d.b2Abs(M_ey.y);
	return out;
}

/** 
 * Multiply a matrix times a vector. If a rotation matrix is 
 * provided, then this transforms the vector from one frame to 
 * another. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Mat22} M
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulMV = function (M, v, out)
{
	var M_ex = M.ex, M_ey = M.ey;
	var v_x = v.x, v_y = v.y;
	out.x = M_ex.x * v_x + M_ey.x * v_y;
	out.y = M_ex.y * v_x + M_ey.y * v_y;
	return out;
}

/** 
 * Multiply a matrix transpose times a vector. If a rotation 
 * matrix is provided, then this transforms the vector from one 
 * frame to another (inverse transform). 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Mat22} M
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulTMV = function (M, v, out)
{
	var M_ex = M.ex, M_ey = M.ey;
	var v_x = v.x, v_y = v.y;
	out.x = M_ex.x * v_x + M_ex.y * v_y;
	out.y = M_ey.x * v_x + M_ey.y * v_y;
	return out;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} A
 * @param {box2d.b2Mat22} B
 * @param {box2d.b2Mat22} out
 */
box2d.b2AddMM = function (A, B, out)
{
	var A_ex = A.ex, A_ey = A.ey;
	var B_ex = B.ex, B_ey = B.ey;
	out.ex.x = A_ex.x + B_ex.x;
	out.ex.y = A_ex.y + B_ex.y;
	out.ey.x = A_ey.x + B_ey.x;
	out.ey.y = A_ey.y + B_ey.y;
	return out;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} A
 * @param {box2d.b2Mat22} B
 * @param {box2d.b2Mat22} out
 */
box2d.b2MulMM = function (A, B, out)
{
	var A_ex_x = A.ex.x, A_ex_y = A.ex.y;
	var A_ey_x = A.ey.x, A_ey_y = A.ey.y;
	var B_ex_x = B.ex.x, B_ex_y = B.ex.y;
	var B_ey_x = B.ey.x, B_ey_y = B.ey.y;
	out.ex.x = A_ex_x * B_ex_x + A_ey_x * B_ex_y;
	out.ex.y = A_ex_y * B_ex_x + A_ey_y * B_ex_y;
	out.ey.x = A_ex_x * B_ey_x + A_ey_x * B_ey_y;
	out.ey.y = A_ex_y * B_ey_x + A_ey_y * B_ey_y;
	return out;
}

/**
 * @export 
 * @return {box2d.b2Mat22}
 * @param {box2d.b2Mat22} A
 * @param {box2d.b2Mat22} B
 * @param {box2d.b2Mat22} out
 */
box2d.b2MulTMM = function (A, B, out)
{
	var A_ex_x = A.ex.x, A_ex_y = A.ex.y;
	var A_ey_x = A.ey.x, A_ey_y = A.ey.y;
	var B_ex_x = B.ex.x, B_ex_y = B.ex.y;
	var B_ey_x = B.ey.x, B_ey_y = B.ey.y;
	out.ex.x = A_ex_x * B_ex_x + A_ex_y * B_ex_y;
	out.ex.y = A_ey_x * B_ex_x + A_ey_y * B_ex_y;
	out.ey.x = A_ex_x * B_ey_x + A_ex_y * B_ey_y;
	out.ey.y = A_ey_x * B_ey_x + A_ey_y * B_ey_y;
	return out;
}

/** 
 * A 3-by-3 matrix. Stored in column-major order. 
 * @export 
 * @constructor 
 */
box2d.b2Mat33 = function ()
{
	this.ex = new box2d.b2Vec3(1.0, 0.0, 0.0);
	this.ey = new box2d.b2Vec3(0.0, 1.0, 0.0);
	this.ez = new box2d.b2Vec3(0.0, 0.0, 1.0);
}

/**
 * @export 
 * @type {box2d.b2Vec3} 
 */
box2d.b2Mat33.prototype.ex = null;
/**
 * @export 
 * @type {box2d.b2Vec3} 
 */
box2d.b2Mat33.prototype.ey = null;
/**
 * @export 
 * @type {box2d.b2Vec3} 
 */
box2d.b2Mat33.prototype.ez = null;

/**
 * @export 
 * @type {box2d.b2Mat33} 
 */
box2d.b2Mat33.IDENTITY = new box2d.b2Mat33();

/**
 * @export 
 * @return {box2d.b2Mat33}
 */
box2d.b2Mat33.prototype.Clone = function ()
{
	return new box2d.b2Mat33().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Mat33}
 * @param {box2d.b2Vec3} c1
 * @param {box2d.b2Vec3} c2
 * @param {box2d.b2Vec3} c3
 */
box2d.b2Mat33.prototype.SetVVV = function (c1, c2, c3)
{
	this.ex.Copy(c1);
	this.ey.Copy(c2);
	this.ez.Copy(c3);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat33}
 * @param {box2d.b2Mat33} other
 */
box2d.b2Mat33.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.ex.Copy(other.ex);
	this.ey.Copy(other.ey);
	this.ez.Copy(other.ez);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat33}
 */
box2d.b2Mat33.prototype.SetIdentity = function ()
{
	this.ex.SetXYZ(1.0, 0.0, 0.0);
	this.ey.SetXYZ(0.0, 1.0, 0.0);
	this.ez.SetXYZ(0.0, 0.0, 1.0);
	return this;
}

/** 
 * Set this matrix to all zeros. 
 * @export 
 * @return {box2d.b2Mat33}
 */
box2d.b2Mat33.prototype.SetZero = function ()
{
	this.ex.SetZero();
	this.ey.SetZero();
	this.ez.SetZero();
	return this;
}

/**
 * @export 
 * @return {box2d.b2Mat33}
 * @param {box2d.b2Mat33} M
 */
box2d.b2Mat33.prototype.SelfAddM = function (M)
{
	this.ex.SelfAdd(M.ex);
	this.ey.SelfAdd(M.ey);
	this.ez.SelfAdd(M.ez);
	return this;
}

/** 
 * Solve A * x = b, where b is a column vector. This is more 
 * efficient than computing the inverse in one-shot cases. 
 * @export 
 * @return {box2d.b2Vec3}
 * @param {number} b_x
 * @param {number} b_y
 * @param {number} b_z
 * @param {box2d.b2Vec3} out
 */
box2d.b2Mat33.prototype.Solve33 = function (b_x, b_y, b_z, out)
{
	var a11 = this.ex.x, a21 = this.ex.y, a31 = this.ex.z;
	var a12 = this.ey.x, a22 = this.ey.y, a32 = this.ey.z;
	var a13 = this.ez.x, a23 = this.ez.y, a33 = this.ez.z;
	var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}
	out.x = det * (b_x * (a22 * a33 - a32 * a23) + b_y * (a32 * a13 - a12 * a33) + b_z * (a12 * a23 - a22 * a13));
	out.y = det * (a11 * (b_y * a33 - b_z * a23) + a21 * (b_z * a13 - b_x * a33) + a31 * (b_x * a23 - b_y * a13));
	out.z = det * (a11 * (a22 * b_z - a32 * b_y) + a21 * (a32 * b_x - a12 * b_z) + a31 * (a12 * b_y - a22 * b_x));
	return out;
}

/** 
 * Solve A * x = b, where b is a column vector. This is more 
 * efficient than computing the inverse in one-shot cases. Solve 
 * only the upper 2-by-2 matrix equation. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} b_x
 * @param {number} b_y
 * @param {box2d.b2Vec2} out
 */
box2d.b2Mat33.prototype.Solve22 = function (b_x, b_y, out)
{
	var a11 = this.ex.x, a12 = this.ey.x;
	var a21 = this.ex.y, a22 = this.ey.y;
	var det = a11 * a22 - a12 * a21;
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}
	out.x = det * (a22 * b_x - a12 * b_y);
	out.y = det * (a11 * b_y - a21 * b_x);
	return out;
}

/** 
 * Get the inverse of this matrix as a 2-by-2. 
 * Returns the zero matrix if singular.
 * @export 
 * @return {void} 
 * @param {box2d.b2Mat33} M 
 */
box2d.b2Mat33.prototype.GetInverse22 = function (M)
{
	var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
	var det = a * d - b * c;
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}

	M.ex.x =  det * d; M.ey.x = -det * b; M.ex.z = 0.0;
	M.ex.y = -det * c; M.ey.y =  det * a; M.ey.z = 0.0;
	M.ez.x =      0.0; M.ez.y =      0.0; M.ez.z = 0.0;
}

/** 
 * Get the symmetric inverse of this matrix as a 3-by-3. 
 * Returns the zero matrix if singular.
 * @export 
 * @return {void} 
 * @param {box2d.b2Mat33} M 
 */
box2d.b2Mat33.prototype.GetSymInverse33 = function (M)
{
	var det = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
	if (det !== 0.0)
	{
		det = 1.0 / det;
	}

	var a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;
	var a22 = this.ey.y, a23 = this.ez.y;
	var a33 = this.ez.z;

	M.ex.x = det * (a22 * a33 - a23 * a23);
	M.ex.y = det * (a13 * a23 - a12 * a33);
	M.ex.z = det * (a12 * a23 - a13 * a22);

	M.ey.x = M.ex.y;
	M.ey.y = det * (a11 * a33 - a13 * a13);
	M.ey.z = det * (a13 * a12 - a11 * a23);

	M.ez.x = M.ex.z;
	M.ez.y = M.ey.z;
	M.ez.z = det * (a11 * a22 - a12 * a12);
}

/** 
 * Multiply a matrix times a vector. 
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Mat33} A
 * @param {box2d.b2Vec3} v
 * @param {box2d.b2Vec3} out
 */
box2d.b2MulM33V3 = function (A, v, out)
{
	var v_x = v.x, v_y = v.y, v_z = v.z;
	out.x = A.ex.x * v_x + A.ey.x * v_y + A.ez.x * v_z;
	out.y = A.ex.y * v_x + A.ey.y * v_y + A.ez.y * v_z;
	out.z = A.ex.z * v_x + A.ey.z * v_y + A.ez.z * v_z;
	return out;
}
/**
 * @export 
 * @return {box2d.b2Vec3}
 * @param {box2d.b2Mat33} A
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {box2d.b2Vec3} out
 */
box2d.b2MulM33XYZ = function (A, x, y, z, out)
{
	out.x = A.ex.x * x + A.ey.x * y + A.ez.x * z;
	out.y = A.ex.y * x + A.ey.y * y + A.ez.y * z;
	out.z = A.ex.z * x + A.ey.z * y + A.ez.z * z;
	return out;
}
/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Mat33} A
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulM33V2 = function (A, v, out)
{
	var v_x = v.x, v_y = v.y;
	out.x = A.ex.x * v_x + A.ey.x * v_y;
	out.y = A.ex.y * v_x + A.ey.y * v_y;
	return out;
}
/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Mat33} A
 * @param {number} x
 * @param {number} y
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulM33XY = function (A, x, y, out)
{
	out.x = A.ex.x * x + A.ey.x * y;
	out.y = A.ex.y * x + A.ey.y * y;
	return out;
}

/** 
 * Rotation 
 * Initialize from an angle in radians 
 * @export 
 * @constructor 
 * @param {number=} angle 
 */
box2d.b2Rot = function (angle)
{
	/// Sine and cosine
	if (angle)
	{
		/// TODO_ERIN optimize
		this.angle = angle;
		this.s = Math.sin(angle);
		this.c = Math.cos(angle);
	}
}

/**
 * @export 
 * @type {number} 
 */
box2d.b2Rot.prototype.angle = 0.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Rot.prototype.s = 0.0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Rot.prototype.c = 1.0;

/**
 * @export 
 * @type {box2d.b2Rot} 
 */
box2d.b2Rot.IDENTITY = new box2d.b2Rot();

/**
 * @export 
 * @return {box2d.b2Rot}
 */
box2d.b2Rot.prototype.Clone = function ()
{
	return new box2d.b2Rot().Copy(this);
}

/** 
 * @export 
 * @return {box2d.b2Rot}
 * @param {box2d.b2Rot} other 
 */
box2d.b2Rot.prototype.Copy = function (other)
{
	this.angle = other.angle;
	this.s = other.s;
	this.c = other.c;
	return this;
}

/** 
 * Set using an angle in radians. 
 * @export 
 * @return {box2d.b2Rot} 
 * @param {number} angle 
 */
box2d.b2Rot.prototype.SetAngle = function (angle)
{
	/// TODO_ERIN optimize
	if (this.angle !== angle)
	{
		this.angle = angle;
		this.s = Math.sin(angle);
		this.c = Math.cos(angle);
	}
	return this;
}

box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle;

box2d.b2Rot.prototype.SetAngleDegrees = function (angle) { return this.SetAngle(box2d.b2DegToRad(angle)); }

/** 
 * Set to the identity rotation 
 * @export 
 * @return {box2d.b2Rot} 
 */
box2d.b2Rot.prototype.SetIdentity = function ()
{
	this.angle = 0.0;
	this.s = 0.0;
	this.c = 1.0;
	return this;
}

/** 
 * Get the angle in radians 
 * @export 
 * @return {number}
 */
box2d.b2Rot.prototype.GetAngle = function ()
{
	return this.angle;
//	return Math.atan2(this.s, this.c);
}

box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle;

box2d.b2Rot.prototype.GetAngleDegrees = function () { return box2d.b2RadToDeg(this.GetAngle()); }

/** 
 * Get the x-axis 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Rot.prototype.GetXAxis = function (out)
{
	out.x = this.c;
	out.y = this.s;
	return out;
}

/** 
 * Get the y-axis 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Rot.prototype.GetYAxis = function (out)
{
	out.x = -this.s;
	out.y = this.c;
	return out;
}

/** 
 * Multiply two rotations: q * r 
 * @export 
 * @return {box2d.b2Rot} 
 * @param {box2d.b2Rot} q
 * @param {box2d.b2Rot} r
 * @param {box2d.b2Rot} out 
 */
box2d.b2MulRR = function (q, r, out)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	var q_c = q.c, q_s = q.s;
	var r_c = r.c, r_s = r.s;
	out.s = q_s * r_c + q_c * r_s;
	out.c = q_c * r_c - q_s * r_s;
	out.angle = q.angle + r.angle;
	while (out.angle < -box2d.b2_pi) { out.angle += box2d.b2_two_pi; }
	while (out.angle >= box2d.b2_pi) { out.angle -= box2d.b2_two_pi; }
	return out;
}

/** 
 * Transpose multiply two rotations: qT * r 
 * @export 
 * @return {box2d.b2Rot} 
 * @param {box2d.b2Rot} q
 * @param {box2d.b2Rot} r
 * @param {box2d.b2Rot} out 
 */
box2d.b2MulTRR = function (q, r, out)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	var q_c = q.c, q_s = q.s;
	var r_c = r.c, r_s = r.s;
	out.s = q_c * r_s - q_s * r_c;
	out.c = q_c * r_c + q_s * r_s;
	out.angle = q.angle - r.angle;
	while (out.angle < -box2d.b2_pi) { out.angle += box2d.b2_two_pi; }
	while (out.angle >= box2d.b2_pi) { out.angle -= box2d.b2_two_pi; }
	return out;
}

/** 
 * Rotate a vector 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Rot} q 
 * @param {box2d.b2Vec2} v 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MulRV = function (q, v, out)
{
	var q_c = q.c, q_s = q.s;
	var v_x = v.x, v_y = v.y;
	out.x = q_c * v_x - q_s * v_y;
	out.y = q_s * v_x + q_c * v_y;
	return out;
}

/** 
 * Inverse rotate a vector 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Rot} q 
 * @param {box2d.b2Vec2} v 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MulTRV = function (q, v, out)
{
	var q_c = q.c, q_s = q.s;
	var v_x = v.x, v_y = v.y;
	out.x =  q_c * v_x + q_s * v_y;
	out.y = -q_s * v_x + q_c * v_y;
	return out;
}

/** 
 * A transform contains translation and rotation. It is used to 
 * represent the position and orientation of rigid frames. 
 * @export 
 * @constructor 
 */
box2d.b2Transform = function ()
{
	this.p = new box2d.b2Vec2();
	this.q = new box2d.b2Rot();
}

/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Transform.prototype.p = null;
/**
 * @export 
 * @type {box2d.b2Rot} 
 */
box2d.b2Transform.prototype.q = null;

/**
 * @export 
 * @type {box2d.b2Transform} 
 */
box2d.b2Transform.IDENTITY = new box2d.b2Transform();

/**
 * @export 
 * @return {box2d.b2Transform}
 */
box2d.b2Transform.prototype.Clone = function ()
{
	return new box2d.b2Transform().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Transform} other
 */
box2d.b2Transform.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.p.Copy(other.p);
	this.q.Copy(other.q);
	return this;
}

/** 
 * Set this to the identity transform. 
 * @export 
 * @return {box2d.b2Transform}
 */
box2d.b2Transform.prototype.SetIdentity = function ()
{
	this.p.SetZero();
	this.q.SetIdentity();
	return this;
}

/** 
 * Set this based on the position and angle. 
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Vec2} position
 * @param {box2d.b2Rot} q
 */
box2d.b2Transform.prototype.SetPositionRotation = function (position, q)
{
	this.p.Copy(position);
	this.q.Copy(q);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Vec2} pos
 * @param {number} a
 */
box2d.b2Transform.prototype.SetPositionAngleRadians = function (pos, a)
{
	this.p.Copy(pos);
	this.q.SetAngleRadians(a);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Vec2} position
 */
box2d.b2Transform.prototype.SetPosition = function (position)
{
	this.p.Copy(position);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {number} x
 * @param {number} y
 */
box2d.b2Transform.prototype.SetPositionXY = function (x, y)
{
	this.p.SetXY(x, y);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Rot} rotation
 */
box2d.b2Transform.prototype.SetRotation = function (rotation)
{
	this.q.Copy(rotation);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Transform}
 * @param {number} radians
 */
box2d.b2Transform.prototype.SetRotationAngleRadians = function (radians)
{
	this.q.SetAngleRadians(radians);
	return this;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2Transform.prototype.GetPosition = function ()
{
	return this.p;
}

/**
 * @export 
 * @return {box2d.b2Rot}
 */
box2d.b2Transform.prototype.GetRotation = function ()
{
	return this.q;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2Transform.prototype.GetRotationAngle = function ()
{
	return this.q.GetAngle();
}

box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle;

/**
 * @export 
 * @return {number}
 */
box2d.b2Transform.prototype.GetAngle = function ()
{
	return this.q.GetAngle();
}

box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle;

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Transform} T
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulXV = function (T, v, out)
{
//	float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
//	float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;
//
//	return b2Vec2(x, y);
	var T_q_c = T.q.c, T_q_s = T.q.s;
	var v_x = v.x, v_y = v.y;
	out.x = (T_q_c * v_x - T_q_s * v_y) + T.p.x;
	out.y = (T_q_s * v_x + T_q_c * v_y) + T.p.y;
	return out;
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Transform} T
 * @param {box2d.b2Vec2} v
 * @param {box2d.b2Vec2} out
 */
box2d.b2MulTXV = function (T, v, out)
{
//	float32 px = v.x - T.p.x;
//	float32 py = v.y - T.p.y;
//	float32 x = (T.q.c * px + T.q.s * py);
//	float32 y = (-T.q.s * px + T.q.c * py);
//
//	return b2Vec2(x, y);
	var T_q_c = T.q.c, T_q_s = T.q.s;
	var p_x = v.x - T.p.x;
	var p_y = v.y - T.p.y;
	out.x = ( T_q_c * p_x + T_q_s * p_y);
	out.y = (-T_q_s * p_x + T_q_c * p_y);
	return out;
}

/**
 * v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
 *    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Transform} A
 * @param {box2d.b2Transform} B
 * @param {box2d.b2Transform} out 
 */
box2d.b2MulXX = function (A, B, out)
{
	box2d.b2MulRR(A.q, B.q, out.q);
	box2d.b2AddVV(box2d.b2MulRV(A.q, B.p, out.p), A.p, out.p);
	return out;
}

/**
 * v2 = A.q' * (B.q * v1 + B.p - A.p)
 *    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Transform} A
 * @param {box2d.b2Transform} B
 * @param {box2d.b2Transform} out 
 */
box2d.b2MulTXX = function (A, B, out)
{
	box2d.b2MulTRR(A.q, B.q, out.q);
	box2d.b2MulTRV(A.q, box2d.b2SubVV(B.p, A.p, out.p), out.p);
	return out;
}

/**
 * This describes the motion of a body/shape for TOI computation.
 * Shapes are defined with respect to the body origin, which may
 * no coincide with the center of mass. However, to support dynamics
 * we must interpolate the center of mass position.
 * @export 
 * @constructor 
 */
box2d.b2Sweep = function ()
{
	this.localCenter = new box2d.b2Vec2();
	this.c0 = new box2d.b2Vec2();
	this.c = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Sweep.prototype.localCenter = null; ///< local center of mass position
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Sweep.prototype.c0 = null; ///< center world positions
/**
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2Sweep.prototype.c = null;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Sweep.prototype.a0 = 0.0; ///< world angles
/**
 * @export 
 * @type {number} 
 */
box2d.b2Sweep.prototype.a = 0.0;

/**
 * Fraction of the current time step in the range [0,1]
 * c0 and a0 are the positions at alpha0.
 * @export 
 * @type {number} 
 */
box2d.b2Sweep.prototype.alpha0 = 0.0;

/**
 * @export 
 * @return {box2d.b2Sweep}
 */
box2d.b2Sweep.prototype.Clone = function ()
{
	return new box2d.b2Sweep().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Sweep}
 * @param {box2d.b2Sweep} other
 */
box2d.b2Sweep.prototype.Copy = function (other)
{
	//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.localCenter.Copy(other.localCenter);
	this.c0.Copy(other.c0);
	this.c.Copy(other.c);
	this.a0 = other.a0;
	this.a = other.a;
	this.alpha0 = other.alpha0;
	return this;
}

/** 
 * Get the interpolated transform at a specific time. 
 * @export 
 * @return {box2d.b2Transform}
 * @param {box2d.b2Transform} xf
 * @param {number} beta is a factor in [0,1], where 0 indicates alpha0.
 */
box2d.b2Sweep.prototype.GetTransform = function (xf, beta)
{
	var one_minus_beta = (1.0 - beta);
	xf.p.x = one_minus_beta * this.c0.x + beta * this.c.x;
	xf.p.y = one_minus_beta * this.c0.y + beta * this.c.y;
	var angle = one_minus_beta * this.a0 + beta * this.a;
	xf.q.SetAngleRadians(angle);

	// Shift to origin
	xf.p.SelfSub(box2d.b2MulRV(xf.q, this.localCenter, box2d.b2Vec2.s_t0));
	return xf;
}

/** 
 * Advance the sweep forward, yielding a new initial state. 
 * @export 
 * @return {void} 
 * @param {number} alpha the new initial time.
 */
box2d.b2Sweep.prototype.Advance = function (alpha)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.alpha0 < 1.0); }
	var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);
	this.c0.x += beta * (this.c.x - this.c0.x);
	this.c0.y += beta * (this.c.y - this.c0.y);
	this.a0 += beta * (this.a - this.a0);
	this.alpha0 = alpha;
}

/** 
 * Normalize an angle in radians to be between -pi and pi 
 * (actually 0 and 2*pi) 
 * @export 
 * @return {void} 
 */
box2d.b2Sweep.prototype.Normalize = function ()
{
	var d = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
	this.a0 -= d;
	this.a -= d;
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Controller');

goog.require('box2d.b2Settings');

/** 
 * A controller edge is used to connect bodies and controllers 
 * together in a bipartite graph. 
 * @export 
 * @constructor 
 */
box2d.b2ControllerEdge = function ()
{
};

/**
 * @export 
 * @type {box2d.b2Controller} 
 */
box2d.b2ControllerEdge.prototype.controller = null; ///< provides quick access to other end of this edge.
/**
 * @export 
 * @type {box2d.b2Body} 
 */
box2d.b2ControllerEdge.prototype.body = null; ///< the body
/**
 * @export 
 * @type {box2d.b2ControllerEdge} 
 */
box2d.b2ControllerEdge.prototype.prevBody = null; ///< the previous controller edge in the controllers's joint list
/**
 * @export 
 * @type {box2d.b2ControllerEdge} 
 */
box2d.b2ControllerEdge.prototype.nextBody = null; ///< the next controller edge in the controllers's joint list
/**
 * @export 
 * @type {box2d.b2ControllerEdge} 
 */
box2d.b2ControllerEdge.prototype.prevController = null; ///< the previous controller edge in the body's joint list
/**
 * @export 
 * @type {box2d.b2ControllerEdge} 
 */
box2d.b2ControllerEdge.prototype.nextController = null; ///< the next controller edge in the body's joint list

/** 
 * Base class for controllers. Controllers are a convience for 
 * encapsulating common per-step functionality. 
 * @export 
 * @constructor 
 */
box2d.b2Controller = function ()
{
};

/**
 * @export 
 * @type {box2d.b2World} 
 */
box2d.b2Controller.prototype.m_world = null;
/**
 * @export 
 * @type {box2d.b2ControllerEdge} 
 */
box2d.b2Controller.prototype.m_bodyList = null;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Controller.prototype.m_bodyCount = 0;
/**
 * @export 
 * @type {box2d.b2Controller} 
 */
box2d.b2Controller.prototype.m_prev = null;
/**
 * @export 
 * @type {box2d.b2Controller} 
 */
box2d.b2Controller.prototype.m_next = null;

/** 
 * Controllers override this to implement per-step 
 * functionality. 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2Controller.prototype.Step = function (step)
{
}

/** 
 * Controllers override this to provide debug drawing. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Draw} debugDraw
 */
box2d.b2Controller.prototype.Draw = function (debugDraw)
{
}

/** 
 * Get the next controller in the world's body list. 
 * @export 
 * @return {box2d.b2Controller} 
 */
box2d.b2Controller.prototype.GetNext = function ()
{
	return this.m_next;
}

/** 
 * Get the previous controller in the world's body list. 
 * @export 
 * @return {box2d.b2Controller} 
 */
box2d.b2Controller.prototype.GetPrev = function ()
{
	return this.m_prev;
}

/** 
 * Get the parent world of this body. 
 * @export 
 * @return {box2d.b2World} 
 */
box2d.b2Controller.prototype.GetWorld = function ()
{
	return this.m_world;
}

/** 
 * Get the attached body list 
 * @export 
 * @return {box2d.b2ControllerEdge}
 */
box2d.b2Controller.prototype.GetBodyList = function ()
{
	return this.m_bodyList;
}

/** 
 * Adds a body to the controller list. 
 * @export 
 * @return {void}
 * @param {box2d.b2Body} body
 */
box2d.b2Controller.prototype.AddBody = function (body)
{
	var edge = new box2d.b2ControllerEdge();

	edge.body = body;
	edge.controller = this;

	//Add edge to controller list
	edge.nextBody = this.m_bodyList;
	edge.prevBody = null;
	if (this.m_bodyList)
		this.m_bodyList.prevBody = edge;
	this.m_bodyList = edge;
	++this.m_bodyCount;

	//Add edge to body list
	edge.nextController = body.m_controllerList;
	edge.prevController = null;
	if (body.m_controllerList)
		body.m_controllerList.prevController = edge;
	body.m_controllerList = edge;
	++body.m_controllerCount;
}

/** 
 * Removes a body from the controller list. 
 * @export 
 * @return {void}
 * @param {box2d.b2Body} body
 */
box2d.b2Controller.prototype.RemoveBody = function (body)
{
	//Assert that the controller is not empty
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount > 0); }

	//Find the corresponding edge
	/*b2ControllerEdge*/ var edge = this.m_bodyList;
	while(edge && edge.body !== body)
		edge = edge.nextBody;

	//Assert that we are removing a body that is currently attached to the controller
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(edge !== null); }

	//Remove edge from controller list
	if (edge.prevBody)
		edge.prevBody.nextBody = edge.nextBody;
	if (edge.nextBody)
		edge.nextBody.prevBody = edge.prevBody;
	if (this.m_bodyList === edge)
		this.m_bodyList = edge.nextBody;
	--this.m_bodyCount;

	//Remove edge from body list
	if (edge.nextController)
		edge.nextController.prevController = edge.prevController;
	if (edge.prevController)
		edge.prevController.nextController = edge.nextController;
	if (body.m_controllerList === edge)
		body.m_controllerList = edge.nextController;
	--body.m_controllerCount;
}

/** 
 * Removes all bodies from the controller list. 
 * @export 
 * @return {void}
 */
box2d.b2Controller.prototype.Clear = function ()
{
	while (this.m_bodyList)
	{
		this.RemoveBody(this.m_bodyList.body);
	}

	this.m_bodyCount = 0;
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ConstantAccelController');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Controller');
goog.require('box2d.b2Math');

/** 
 * Applies a force every frame 
 * @export 
 * @constructor 
 * @extends {box2d.b2Controller} 
 */
box2d.b2ConstantAccelController = function ()
{
	goog.base(this); // base class constructor

	this.A = new box2d.b2Vec2(0, 0);
};

goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller);

/** 
 * The acceleration to apply 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2ConstantAccelController.prototype.A = null;

/** 
 * @see box2d.b2Controller::Step 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2ConstantAccelController.prototype.Step = function (step)
{
	var dtA = box2d.b2MulSV(step.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA);
	for (var i = this.m_bodyList; i; i = i.nextBody)
	{
		var body = i.body;
		if (!body.IsAwake())
			continue;
		body.SetLinearVelocity(box2d.b2AddVV(body.GetLinearVelocity(), dtA, box2d.b2Vec2.s_t0));
	}
}
box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Joint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');

/** 
 * @export 
 * @enum
 */
box2d.b2JointType = 
{
	e_unknownJoint		: 0,
	e_revoluteJoint		: 1,
	e_prismaticJoint	: 2,
	e_distanceJoint		: 3,
	e_pulleyJoint		: 4,
	e_mouseJoint		: 5,
	e_gearJoint			: 6,
	e_wheelJoint		: 7,
	e_weldJoint			: 8,
	e_frictionJoint		: 9,
	e_ropeJoint			: 10,
	e_motorJoint		: 11,
	e_areaJoint			: 12
};
goog.exportProperty(box2d.b2JointType, 'e_unknownJoint'  , box2d.b2JointType.e_unknownJoint  );
goog.exportProperty(box2d.b2JointType, 'e_revoluteJoint' , box2d.b2JointType.e_revoluteJoint );
goog.exportProperty(box2d.b2JointType, 'e_prismaticJoint', box2d.b2JointType.e_prismaticJoint);
goog.exportProperty(box2d.b2JointType, 'e_distanceJoint' , box2d.b2JointType.e_distanceJoint );
goog.exportProperty(box2d.b2JointType, 'e_pulleyJoint'   , box2d.b2JointType.e_pulleyJoint   );
goog.exportProperty(box2d.b2JointType, 'e_mouseJoint'    , box2d.b2JointType.e_mouseJoint    );
goog.exportProperty(box2d.b2JointType, 'e_gearJoint'     , box2d.b2JointType.e_gearJoint     );
goog.exportProperty(box2d.b2JointType, 'e_wheelJoint'    , box2d.b2JointType.e_wheelJoint    );
goog.exportProperty(box2d.b2JointType, 'e_weldJoint'     , box2d.b2JointType.e_weldJoint     );
goog.exportProperty(box2d.b2JointType, 'e_frictionJoint' , box2d.b2JointType.e_frictionJoint );
goog.exportProperty(box2d.b2JointType, 'e_ropeJoint'     , box2d.b2JointType.e_ropeJoint     );
goog.exportProperty(box2d.b2JointType, 'e_motorJoint'    , box2d.b2JointType.e_motorJoint    );
goog.exportProperty(box2d.b2JointType, 'e_areaJoint'     , box2d.b2JointType.e_areaJoint     );

/** 
 * @export 
 * @enum
 */
box2d.b2LimitState = 
{
	e_inactiveLimit	: 0,
	e_atLowerLimit	: 1,
	e_atUpperLimit	: 2,
	e_equalLimits	: 3
};
goog.exportProperty(box2d.b2LimitState, 'e_inactiveLimit', box2d.b2LimitState.e_inactiveLimit);
goog.exportProperty(box2d.b2LimitState, 'e_atLowerLimit' , box2d.b2LimitState.e_atLowerLimit );
goog.exportProperty(box2d.b2LimitState, 'e_atUpperLimit' , box2d.b2LimitState.e_atUpperLimit );
goog.exportProperty(box2d.b2LimitState, 'e_equalLimits'  , box2d.b2LimitState.e_equalLimits  );

/** 
 * @export 
 * @constructor
 */
box2d.b2Jacobian = function ()
{
	this.linear = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Jacobian.prototype.linear = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Jacobian.prototype.angularA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Jacobian.prototype.angularB = 0;

/** 
 * @export 
 * @return {box2d.b2Jacobian}
 */
box2d.b2Jacobian.prototype.SetZero = function ()
{
	this.linear.SetZero();
	this.angularA = 0;
	this.angularB = 0;
	return this;
}

/** 
 * @export 
 * @return {box2d.b2Jacobian}
 * @param {box2d.b2Vec2} x
 * @param {number} a1
 * @param {number} a2
 */
box2d.b2Jacobian.prototype.Set = function (x, a1, a2)
{
	this.linear.Copy(x);
	this.angularA = a1;
	this.angularB = a2;
	return this;
}

/** 
 * A joint edge is used to connect bodies and joints together in 
 * a joint graph where each body is a node and each joint is an 
 * edge. A joint edge belongs to a doubly linked list maintained 
 * in each attached body. Each joint has two joint nodes, one 
 * for each attached body. 
 * @export 
 * @constructor
 */
box2d.b2JointEdge = function ()
{
};

/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2JointEdge.prototype.other = null; ///< provides quick access to the other body attached.
/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2JointEdge.prototype.joint = null; ///< the joint
/**
 * @export 
 * @type {box2d.b2JointEdge}
 */
box2d.b2JointEdge.prototype.prev = null; ///< the previous joint edge in the body's joint list
/**
 * @export 
 * @type {box2d.b2JointEdge}
 */
box2d.b2JointEdge.prototype.next = null; ///< the next joint edge in the body's joint list

/** 
 * Joint definitions are used to construct joints. 
 * @export 
 * @constructor 
 * @param {box2d.b2JointType} type 
 */
box2d.b2JointDef = function (type)
{
	this.type = type;
}

/** 
 * The joint type is set automatically for concrete joint types.
 * @export 
 * @type {box2d.b2JointType}
 */
box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint;

/** 
 * Use this to attach application specific data to your joints. 
 * @export 
 * @type {*}
 */
box2d.b2JointDef.prototype.userData = null;

/** 
 * The first attached body. 
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2JointDef.prototype.bodyA = null;

/** 
 * The second attached body. 
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2JointDef.prototype.bodyB = null;

/** 
 * Set this flag to true if the attached bodies should collide. 
 * @export 
 * @type {boolean}
 */
box2d.b2JointDef.prototype.collideConnected = false;

/** 
 * The base joint class. Joints are used to constraint two 
 * bodies together in various fashions. Some joints also feature 
 * limits and motors. 
 * @export 
 * @constructor 
 */
box2d.b2Joint = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.bodyA !== def.bodyB); }

	this.m_type = def.type;
	this.m_edgeA = new box2d.b2JointEdge();
	this.m_edgeB = new box2d.b2JointEdge();
	this.m_bodyA = def.bodyA;
	this.m_bodyB = def.bodyB;

	this.m_collideConnected = def.collideConnected;

	this.m_userData = def.userData;
}

/**
 * @export 
 * @type {box2d.b2JointType}
 */
box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint;
/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2Joint.prototype.m_prev = null;
/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2Joint.prototype.m_next = null;
/**
 * @export 
 * @type {box2d.b2JointEdge}
 */
box2d.b2Joint.prototype.m_edgeA = null;
/**
 * @export 
 * @type {box2d.b2JointEdge}
 */
box2d.b2Joint.prototype.m_edgeB = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2Joint.prototype.m_bodyA = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2Joint.prototype.m_bodyB = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2Joint.prototype.m_index = 0;

/**
 * @export 
 * @type {boolean}
 */
box2d.b2Joint.prototype.m_islandFlag = false;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2Joint.prototype.m_collideConnected = false;

/**
 * @export 
 * @type {*}
 */
box2d.b2Joint.prototype.m_userData = null;

/** 
 * Get the anchor point on bodyA in world coordinates. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out
 */
box2d.b2Joint.prototype.GetAnchorA = function (out)
{
	return out.SetZero();
}

/** 
 * Get the anchor point on bodyB in world coordinates. 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out
 */
box2d.b2Joint.prototype.GetAnchorB = function (out)
{
	return out.SetZero();
}

/** 
 * Get the reaction force on bodyB at the joint anchor in 
 * Newtons. 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2Joint.prototype.GetReactionForce = function (inv_dt, out)
{
	return out.SetZero();
}

/** 
 * Get the reaction torque on bodyB in N*m. 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2Joint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2Joint.prototype.InitVelocityConstraints = function (data)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2Joint.prototype.SolveVelocityConstraints = function (data)
{
}

/** 
 * This returns true if the position errors are within 
 * tolerance. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2Joint.prototype.SolvePositionConstraints = function (data)
{
	return false;
}

/** 
 * Get the type of the concrete joint. 
 * @export 
 * @return {box2d.b2JointType} 
 */
box2d.b2Joint.prototype.GetType = function ()
{
	return this.m_type;
}

/** 
 * Get the first body attached to this joint. 
 * @export 
 * @return {box2d.b2Body}
 */
box2d.b2Joint.prototype.GetBodyA = function ()
{
	return this.m_bodyA;
}

/** 
 * Get the second body attached to this joint. 
 * @export 
 * @return {box2d.b2Body}
 */
box2d.b2Joint.prototype.GetBodyB = function ()
{
	return this.m_bodyB;
}

/** 
 * Get the next joint the world joint list. 
 * @export 
 * @return {box2d.b2Joint} 
 */
box2d.b2Joint.prototype.GetNext = function ()
{
	return this.m_next;
}

/** 
 * Get the user data pointer. 
 * @export 
 * @return {*} 
 */
box2d.b2Joint.prototype.GetUserData = function ()
{
	return this.m_userData;
}

/** 
 * Set the user data pointer. 
 * @export 
 * @return {void} 
 * @param {*} data 
 */
box2d.b2Joint.prototype.SetUserData = function (data)
{
	this.m_userData = data;
}

/** 
 * Get collide connected. 
 * Note: modifying the collide connect flag won't work correctly 
 * because the flag is only checked when fixture AABBs begin to 
 * overlap. 
 * @export 
 * @return {boolean}
 */
box2d.b2Joint.prototype.GetCollideConnected = function ()
{
	return this.m_collideConnected;
}

/** 
 * Dump this joint to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2Joint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		box2d.b2Log("// Dump is not supported for this joint type.\n");
	}
}

/** 
 * Short-cut function to determine if either body is inactive. 
 * @export 
 * @return {boolean} 
 */
box2d.b2Joint.prototype.IsActive = function ()
{
	return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
}

/** 
 * Shift the origin for any points stored in world coordinates. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} newOrigin
 */
box2d.b2Joint.prototype.ShiftOrigin = function (newOrigin)
{
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2RevoluteJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Revolute joint definition. This requires defining an anchor 
 * point where the bodies are joined. The definition uses local 
 * anchor points so that the initial configuration can violate 
 * the constraint slightly. You also need to specify the initial 
 * relative angle for joint limits. This helps when saving and 
 * loading a game. 
 * The local anchor points are measured from the body's origin 
 * rather than the center of mass because: 
 * 1. you might not know where the center of mass will be. 
 * 2. if you add/remove shapes from a body and recompute the 
 * mass, the joints will be broken. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2RevoluteJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_revoluteJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2(0, 0);
	this.localAnchorB = new box2d.b2Vec2(0, 0);
}

goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJointDef.prototype.localAnchorB = null;

/** 
 * The bodyB angle minus bodyA angle in the reference state 
 * (radians). 
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJointDef.prototype.referenceAngle = 0;

/** 
 * A flag to enable joint limits. 
 * @export 
 * @type {boolean}
 */
box2d.b2RevoluteJointDef.prototype.enableLimit = false;

/** 
 * The lower angle for the joint limit (radians). 
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJointDef.prototype.lowerAngle = 0;

/** 
 * The upper angle for the joint limit (radians). 
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJointDef.prototype.upperAngle = 0;

/** 
 * A flag to enable the joint motor. 
 * @export 
 * @type {boolean}
 */
box2d.b2RevoluteJointDef.prototype.enableMotor = false;

/** 
 * The desired motor speed. Usually in radians per second. 
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJointDef.prototype.motorSpeed = 0;

/** 
 * The maximum motor torque used to achieve the desired motor 
 * speed. 
 * Usually in N-m. 
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} anchor 
 */
box2d.b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
	this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();
}

/** 
 * A revolute joint constrains two bodies to share a common 
 * point while they are free to rotate about the point. The 
 * relative rotation about the shared point is the joint angle. 
 * You can limit the relative rotation with a joint limit that 
 * specifies a lower and upper angle. You can use a motor to 
 * drive the relative rotation about the shared point. A maximum 
 * motor torque is provided so that infinite forces are not 
 * generated. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2RevoluteJointDef} def 
 */
box2d.b2RevoluteJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_localAnchorA = new box2d.b2Vec2();
	this.m_localAnchorB = new box2d.b2Vec2();
	this.m_impulse = new box2d.b2Vec3();

	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();
	this.m_mass = new box2d.b2Mat33();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_K = new box2d.b2Mat22();

	this.m_localAnchorA.Copy(def.localAnchorA);
	this.m_localAnchorB.Copy(def.localAnchorB);
	this.m_referenceAngle = def.referenceAngle;

	this.m_impulse.SetZero();
	this.m_motorImpulse = 0;

	this.m_lowerAngle = def.lowerAngle;
	this.m_upperAngle = def.upperAngle;
	this.m_maxMotorTorque = def.maxMotorTorque;
	this.m_motorSpeed = def.motorSpeed;
	this.m_enableLimit = def.enableLimit;
	this.m_enableMotor = def.enableMotor;
	this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
}

goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint);

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {box2d.b2Vec3}
 */
box2d.b2RevoluteJoint.prototype.m_impulse = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0;

/**
 * @export 
 * @type {boolean}
 */
box2d.b2RevoluteJoint.prototype.m_enableMotor = false;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0;

/**
 * @export 
 * @type {boolean}
 */
box2d.b2RevoluteJoint.prototype.m_enableLimit = false;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_upperAngle = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Mat33}
 */
box2d.b2RevoluteJoint.prototype.m_mass = null; // effective mass for point-to-point constraint.
/**
 * @export 
 * @type {number}
 */
box2d.b2RevoluteJoint.prototype.m_motorMass = 0; // effective mass for motor/limit angular constraint.
/**
 * @export 
 * @type {box2d.b2LimitState}
 */
box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2RevoluteJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2RevoluteJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RevoluteJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2RevoluteJoint.prototype.m_K = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	b2Rot qA(aA), qB(aB);
	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*bool*/ var fixedRotation = (iA + iB === 0);

	this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
	this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
	this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
	this.m_mass.ex.y = this.m_mass.ey.x;
	this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
	this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
	this.m_mass.ex.z = this.m_mass.ez.x;
	this.m_mass.ey.z = this.m_mass.ez.y;
	this.m_mass.ez.z = iA + iB;

	this.m_motorMass = iA + iB;
	if (this.m_motorMass > 0)
	{
		this.m_motorMass = 1 / this.m_motorMass;
	}

	if (this.m_enableMotor === false || fixedRotation)
	{
		this.m_motorImpulse = 0;
	}

	if (this.m_enableLimit && fixedRotation === false)
	{
		/*float32*/ var jointAngle = aB - aA - this.m_referenceAngle;
		if (box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop)
		{
			this.m_limitState = box2d.b2LimitState.e_equalLimits;
		}
		else if (jointAngle <= this.m_lowerAngle)
		{
			if (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit)
			{
				this.m_impulse.z = 0;
			}
			this.m_limitState = box2d.b2LimitState.e_atLowerLimit;
		}
		else if (jointAngle >= this.m_upperAngle)
		{
			if (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit)
			{
				this.m_impulse.z = 0;
			}
			this.m_limitState = box2d.b2LimitState.e_atUpperLimit;
		}
		else
		{
			this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
			this.m_impulse.z = 0;
		}
	}
	else
	{
		this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
	}

	if (data.step.warmStarting)
	{
		// Scale impulses to support a variable time step.
		this.m_impulse.SelfMul(data.step.dtRatio);
		this.m_motorImpulse *= data.step.dtRatio;

//		b2Vec2 P(m_impulse.x, m_impulse.y);
		var P = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
	}
	else
	{
		this.m_impulse.SetZero();
		this.m_motorImpulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*bool*/ var fixedRotation = (iA + iB === 0);

	// Solve motor constraint.
	if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits && fixedRotation === false)
	{
		/*float32*/ var Cdot = wB - wA - this.m_motorSpeed;
		/*float32*/ var impulse = -this.m_motorMass * Cdot;
		/*float32*/ var oldImpulse = this.m_motorImpulse;
		/*float32*/ var maxImpulse = data.step.dt * this.m_maxMotorTorque;
		this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = this.m_motorImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve limit constraint.
	if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && fixedRotation === false)
	{
//		b2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
		var Cdot1 = box2d.b2SubVV(
			box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),
			box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),
			box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1)
		/*float32*/ var Cdot2 = wB - wA;
//		b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);

//		b2Vec3 impulse = -this.m_mass.Solve33(Cdot);
		var impulse = this.m_mass.Solve33(Cdot1.x, Cdot1.y, Cdot2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg();

		if (this.m_limitState === box2d.b2LimitState.e_equalLimits)
		{
			this.m_impulse.SelfAdd(impulse);
		}
		else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)
		{
			/*float32*/ var newImpulse = this.m_impulse.z + impulse.z;
			if (newImpulse < 0)
			{
//				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
				var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;
				var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;
				/*box2d.b2Vec2*/ var reduced = this.m_mass.Solve22(rhs_x, rhs_y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
				impulse.x = reduced.x;
				impulse.y = reduced.y;
				impulse.z = -this.m_impulse.z;
				this.m_impulse.x += reduced.x;
				this.m_impulse.y += reduced.y;
				this.m_impulse.z = 0;
			}
			else
			{
				this.m_impulse.SelfAdd(impulse);
			}
		}
		else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)
		{
			/*float32*/ var newImpulse = this.m_impulse.z + impulse.z;
			if (newImpulse > 0)
			{
//				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
				var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;
				var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;
				/*box2d.b2Vec2*/ var reduced = this.m_mass.Solve22(rhs_x, rhs_y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
				impulse.x = reduced.x;
				impulse.y = reduced.y;
				impulse.z = -this.m_impulse.z;
				this.m_impulse.x += reduced.x;
				this.m_impulse.y += reduced.y;
				this.m_impulse.z = 0;
			}
			else
			{
				this.m_impulse.SelfAdd(impulse);
			}
		}

//		b2Vec2 P(impulse.x, impulse.y);
		var P = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(impulse.x, impulse.y);

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);
	}
	else
	{
		// Solve point-to-point constraint
//		b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
		var Cdot = box2d.b2SubVV(
			box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),
			box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),
			box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot)
//		b2Vec2 impulse = m_mass.Solve22(-Cdot);
		/*box2d.b2Vec2*/ var impulse = this.m_mass.Solve22(-Cdot.x, -Cdot.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2);

		this.m_impulse.x += impulse.x;
		this.m_impulse.y += impulse.y;

//		vA -= mA * impulse;
		vA.SelfMulSub(mA, impulse);
		wA -= iA * box2d.b2CrossVV(this.m_rA, impulse);

//		vB += mB * impulse;
		vB.SelfMulAdd(mB, impulse);
		wB += iB * box2d.b2CrossVV(this.m_rB, impulse);
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2();
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3();
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2();
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

//	b2Rot qA(aA), qB(aB);
	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	/*float32*/ var angularError = 0;
	/*float32*/ var positionError = 0;

	/*bool*/ var fixedRotation = (this.m_invIA + this.m_invIB === 0);

	// Solve angular limit constraint.
	if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && fixedRotation === false)
	{
		/*float32*/ var angle = aB - aA - this.m_referenceAngle;
		/*float32*/ var limitImpulse = 0;

		if (this.m_limitState === box2d.b2LimitState.e_equalLimits)
		{
			// Prevent large angular corrections
			/*float32*/ var C = box2d.b2Clamp(angle - this.m_lowerAngle, -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection);
			limitImpulse = -this.m_motorMass * C;
			angularError = box2d.b2Abs(C);
		}
		else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)
		{
			/*float32*/ var C = angle - this.m_lowerAngle;
			angularError = -C;

			// Prevent large angular corrections and allow some slop.
			C = box2d.b2Clamp(C + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0);
			limitImpulse = -this.m_motorMass * C;
		}
		else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)
		{
			/*float32*/ var C = angle - this.m_upperAngle;
			angularError = C;

			// Prevent large angular corrections and allow some slop.
			C = box2d.b2Clamp(C - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection);
			limitImpulse = -this.m_motorMass * C;
		}

		aA -= this.m_invIA * limitImpulse;
		aB += this.m_invIB * limitImpulse;
	}

	// Solve point-to-point constraint.
	{
		qA.SetAngleRadians(aA);
		qB.SetAngleRadians(aB);
//		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
		box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
		var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
		box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
		var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

//		b2Vec2 C = cB + rB - cA - rA;
		var C = 
			box2d.b2SubVV(
				box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), 
				box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C);
//		positionError = C.Length();
		positionError = C.GetLength();

		/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
		/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

		var K = this.m_K;
		K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
		K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
		K.ey.x = K.ex.y;
		K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

//		b2Vec2 impulse = -K.Solve(C);
		/*box2d.b2Vec2*/ var impulse = K.Solve(C.x, C.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();

//		cA -= mA * impulse;
		cA.SelfMulSub(mA, impulse);
		aA -= iA * box2d.b2CrossVV(rA, impulse);

//		cB += mB * impulse;
		cB.SelfMulAdd(mB, impulse);
		aB += iB * box2d.b2CrossVV(rB, impulse);
	}

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;
	
	return positionError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;
}
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2();
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2();

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RevoluteJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RevoluteJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * Get the reaction force given the inverse time step. 
 * Unit is N.
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	b2Vec2 P(this.m_impulse.x, this.m_impulse.y);
//	return inv_dt * P;
	return out.SetXY(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
}

/** 
 * Get the reaction torque due to the joint limit given the 
 * inverse time step. 
 * Unit is N*m. 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_impulse.z;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * Get the reference angle. 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function ()
{
//	b2Body* bA = this.m_bodyA;
//	b2Body* bB = this.m_bodyB;
//	return bB->this.m_sweep.a - bA->this.m_sweep.a - this.m_referenceAngle;
	return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetJointSpeed = function ()
{
//	b2Body* bA = this.m_bodyA;
//	b2Body* bB = this.m_bodyB;
//	return bB->this.m_angularVelocity - bA->this.m_angularVelocity;
	return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function ()
{
	return this.m_enableMotor;
}

/** 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2RevoluteJoint.prototype.EnableMotor = function (flag)
{
	if (this.m_enableMotor !== flag)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_enableMotor = flag;
	}
}

/** 
 * Get the current motor torque given the inverse time step. 
 * Unit is N*m. 
 * @export 
 * @return {number}
 * @param {number} inv_dt 
 */
box2d.b2RevoluteJoint.prototype.GetMotorTorque = function (inv_dt)
{
	return inv_dt * this.m_motorImpulse;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function ()
{
	return this.m_motorSpeed;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} torque
 */
box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque)
{
	this.m_maxMotorTorque = torque;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function () { return this.m_maxMotorTorque; }

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function ()
{
	return this.m_enableLimit;
}

/** 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2RevoluteJoint.prototype.EnableLimit = function (flag)
{
	if (flag !== this.m_enableLimit)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_enableLimit = flag;
		this.m_impulse.z = 0;
	}
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetLowerLimit = function ()
{
	return this.m_lowerAngle;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2RevoluteJoint.prototype.GetUpperLimit = function ()
{
	return this.m_upperAngle;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} lower 
 * @param {number} upper 
 */
box2d.b2RevoluteJoint.prototype.SetLimits = function (lower, upper)
{
	
	if (lower !== this.m_lowerAngle || upper !== this.m_upperAngle)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_impulse.z = 0;
		this.m_lowerAngle = lower;
		this.m_upperAngle = upper;
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {number} speed
 */
box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function (speed)
{
	if (this.m_motorSpeed !== speed)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_motorSpeed = speed;
	}
}

/** 
 * Dump to b2Log. 
 * @export 
 * @return {void}
 */
box2d.b2RevoluteJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
		box2d.b2Log("  jd.enableLimit = %s;\n", (this.m_enableLimit)?('true'):('false'));
		box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
		box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
		box2d.b2Log("  jd.enableMotor = %s;\n", (this.m_enableMotor)?('true'):('false'));
		box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
		box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2PrismaticJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Prismatic joint definition. This requires defining a line of 
 * motion using an axis and an anchor point. The definition uses 
 * local anchor points and a local axis so that the initial 
 * configuration can violate the constraint slightly. The joint 
 * translation is zero when the local anchor points coincide in 
 * world space. Using local anchors and a local axis helps when 
 * saving and loading a game. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2PrismaticJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_prismaticJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2();
	this.localAnchorB = new box2d.b2Vec2();
	this.localAxisA = new box2d.b2Vec2(1, 0);
}

goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJointDef.prototype.localAnchorB = null;

/** 
 * The local translation unit axis in bodyA. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJointDef.prototype.localAxisA = null;

/** 
 * The constrained angle between the bodies: bodyB_angle - 
 * bodyA_angle. 
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJointDef.prototype.referenceAngle = 0;

/** 
 * Enable/disable the joint limit. 
 * @export 
 * @type {boolean}
 */
box2d.b2PrismaticJointDef.prototype.enableLimit = false;

/** 
 * The lower translation limit, usually in meters. 
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0;

/** 
 * The upper translation limit, usually in meters. 
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJointDef.prototype.upperTranslation = 0;

/** 
 * Enable/disable the joint motor. 
 * @export 
 * @type {boolean}
 */
box2d.b2PrismaticJointDef.prototype.enableMotor = false;

/** 
 * The maximum motor torque, usually in N-m. 
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0;

/** 
 * The desired motor speed in radians per second. 
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJointDef.prototype.motorSpeed = 0;

/** 
 * Initialize the bodies, anchors, axis, and reference angle 
 * using the world anchor and unit world axis. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} anchor 
 * @param {box2d.b2Vec2} axis 
 */
box2d.b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
	this.bodyA.GetLocalVector(axis, this.localAxisA);
	this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();
}

/** 
 * A prismatic joint. This joint provides one degree of freedom: 
 * translation along an axis fixed in bodyA. Relative rotation 
 * is prevented. You can use a joint limit to restrict the range 
 * of motion and a joint motor to drive the motion or to model 
 * joint friction. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2PrismaticJointDef} def 
 */
box2d.b2PrismaticJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();
	this.m_localXAxisA = def.localAxisA.Clone().SelfNormalize();
	this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2());
	this.m_referenceAngle = def.referenceAngle;
	this.m_impulse = new box2d.b2Vec3(0, 0, 0);
	this.m_lowerTranslation = def.lowerTranslation;
	this.m_upperTranslation = def.upperTranslation;
	this.m_maxMotorForce = def.maxMotorForce;
	this.m_motorSpeed = def.motorSpeed;
	this.m_enableLimit = def.enableLimit;
	this.m_enableMotor = def.enableMotor;

	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();
	this.m_axis = new box2d.b2Vec2(0, 0);
	this.m_perp = new box2d.b2Vec2(0, 0);
	this.m_K = new box2d.b2Mat33();
	this.m_K3 = new box2d.b2Mat33();
	this.m_K2 = new box2d.b2Mat22();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
}

goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint);

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localXAxisA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localYAxisA = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0;
/**
 * @export 
 * @type {box2d.b2Vec3}
 */
box2d.b2PrismaticJoint.prototype.m_impulse = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2PrismaticJoint.prototype.m_enableLimit = false;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2PrismaticJoint.prototype.m_enableMotor = false;
/**
 * @export 
 * @type {box2d.b2LimitState}
 */
box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_axis = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_perp = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_s1 = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_s2 = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_a1 = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_a2 = 0;
/**
 * @export 
 * @type {box2d.b2Mat33}
 */
box2d.b2PrismaticJoint.prototype.m_K = null;
/**
 * @export 
 * @type {box2d.b2Mat33}
 */
box2d.b2PrismaticJoint.prototype.m_K3 = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2PrismaticJoint.prototype.m_K2 = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PrismaticJoint.prototype.m_motorMass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2PrismaticJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2PrismaticJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PrismaticJoint.prototype.m_rB = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	// Compute the effective masses.
//	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	b2Vec2 d = (cB - cA) + rB - rA;
	var d = box2d.b2AddVV(
		box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0),
		box2d.b2SubVV(rB, rA, box2d.b2Vec2.s_t1),
		box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d);

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	// Compute motor Jacobian and effective mass.
	{
//		m_axis = b2Mul(qA, m_localXAxisA);
		box2d.b2MulRV(qA, this.m_localXAxisA, this.m_axis);
//		m_a1 = b2Cross(d + rA, m_axis);
		this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_axis);
//		m_a2 = b2Cross(rB, m_axis);
		this.m_a2 = box2d.b2CrossVV(rB, this.m_axis);

		this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
		if (this.m_motorMass > 0)
		{
			this.m_motorMass = 1 / this.m_motorMass;
		}
	}

	// Prismatic constraint.
	{
//		m_perp = b2Mul(qA, m_localYAxisA);
		box2d.b2MulRV(qA, this.m_localYAxisA, this.m_perp);

//		m_s1 = b2Cross(d + rA, m_perp);
		this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_perp);
//		m_s2 = b2Cross(rB, m_perp);
		this.m_s2 = box2d.b2CrossVV(rB, this.m_perp);

//		float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;
		this.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
//		float32 k12 = iA * m_s1 + iB * m_s2;
		this.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;
//		float32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;
		this.m_K.ex.z = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
		this.m_K.ey.x = this.m_K.ex.y;
//		float32 k22 = iA + iB;
		this.m_K.ey.y = iA + iB;
		if (this.m_K.ey.y === 0)
		{
			// For bodies with fixed rotation.
			this.m_K.ey.y = 1;
		}
//		float32 k23 = iA * m_a1 + iB * m_a2;
		this.m_K.ey.z = iA * this.m_a1 + iB * this.m_a2;
		this.m_K.ez.x = this.m_K.ex.z;
		this.m_K.ez.y = this.m_K.ey.z;
//		float32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;
		this.m_K.ez.z = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;

//		m_K.ex.Set(k11, k12, k13);
//		m_K.ey.Set(k12, k22, k23);
//		m_K.ez.Set(k13, k23, k33);
	}

	// Compute motor and limit terms.
	if (this.m_enableLimit)
	{
//		float32 jointTranslation = b2Dot(m_axis, d);
		var jointTranslation = box2d.b2DotVV(this.m_axis, d);
		if (box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop)
		{
			this.m_limitState = box2d.b2LimitState.e_equalLimits;
		}
		else if (jointTranslation <= this.m_lowerTranslation)
		{
			if (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit)
			{
				this.m_limitState = box2d.b2LimitState.e_atLowerLimit;
				this.m_impulse.z = 0;
			}
		}
		else if (jointTranslation >= this.m_upperTranslation)
		{
			if (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit)
			{
				this.m_limitState = box2d.b2LimitState.e_atUpperLimit;
				this.m_impulse.z = 0;
			}
		}
		else
		{
			this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
			this.m_impulse.z = 0;
		}
	}
	else
	{
		this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
		this.m_impulse.z = 0;
	}

	if (this.m_enableMotor === false)
	{
		this.m_motorImpulse = 0;
	}

	if (data.step.warmStarting)
	{
		// Account for variable time step.
//		m_impulse *= data.step.dtRatio;
		this.m_impulse.SelfMul(data.step.dtRatio);
		this.m_motorImpulse *= data.step.dtRatio;

//		b2Vec2 P = m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis;
		var P = box2d.b2AddVV(
			box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), 
			box2d.b2MulSV((this.m_motorImpulse + this.m_impulse.z), this.m_axis, box2d.b2Vec2.s_t1), 
			box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P);
//		float32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;
		var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
//		float32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;
		var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}
	else
	{
		this.m_impulse.SetZero();
		this.m_motorImpulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	// Solve linear motor constraint.
	if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits)
	{
//		float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
		var Cdot = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
		var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
		var oldImpulse = this.m_motorImpulse;
		var maxImpulse = data.step.dt * this.m_maxMotorForce;
		this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
		impulse = this.m_motorImpulse - oldImpulse;

//		b2Vec2 P = impulse * m_axis;
		var P = box2d.b2MulSV(impulse, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
		var LA = impulse * this.m_a1;
		var LB = impulse * this.m_a2;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}

//	b2Vec2 Cdot1;
//	Cdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;
	var Cdot1_x = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;
//	Cdot1.y = wB - wA;
	var Cdot1_y = wB - wA;

	if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit)
	{
		// Solve prismatic and limit constraint in block form.
//		float32 Cdot2;
//		Cdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
		var Cdot2 = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
//		box2d.b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);

//		box2d.b2Vec3 f1 = m_impulse;
		var f1 = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse);
//		box2d.b2Vec3 df =  m_K.Solve33(-Cdot);
		var df = this.m_K.Solve33((-Cdot1_x), (-Cdot1_y), (-Cdot2), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3);
//		m_impulse += df;
		this.m_impulse.SelfAdd(df);

		if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)
		{
			this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0);
		}
		else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)
		{
			this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0);
		}

		// f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) + f1(1:2)
//		b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * box2d.b2Vec2(m_K.ez.x, m_K.ez.y);
		var b_x = (-Cdot1_x) - (this.m_impulse.z - f1.z) * this.m_K.ez.x;
		var b_y = (-Cdot1_y) - (this.m_impulse.z - f1.z) * this.m_K.ez.y;
//		b2Vec2 f2r = m_K.Solve22(b) + box2d.b2Vec2(f1.x, f1.y);
		var f2r = this.m_K.Solve22(b_x, b_y, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r);
		f2r.x += f1.x;
		f2r.y += f1.y;
//		m_impulse.x = f2r.x;
		this.m_impulse.x = f2r.x;
//		m_impulse.y = f2r.y;
		this.m_impulse.y = f2r.y;

//		df = m_impulse - f1;
		df.x = this.m_impulse.x - f1.x;
		df.y = this.m_impulse.y - f1.y;
		df.z = this.m_impulse.z - f1.z;

//		b2Vec2 P = df.x * m_perp + df.z * m_axis;
		var P = box2d.b2AddVV(
			box2d.b2MulSV(df.x, this.m_perp, box2d.b2Vec2.s_t0),
			box2d.b2MulSV(df.z, this.m_axis, box2d.b2Vec2.s_t1),
			box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
//		float32 LA = df.x * m_s1 + df.y + df.z * m_a1;
		var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
//		float32 LB = df.x * m_s2 + df.y + df.z * m_a2;
		var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}
	else
	{
		// Limit is inactive, just solve the prismatic constraint in block form.
//		b2Vec2 df = m_K.Solve22(-Cdot1);
		var df = this.m_K.Solve22((-Cdot1_x), (-Cdot1_y), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2);
		this.m_impulse.x += df.x;
		this.m_impulse.y += df.y;

//		b2Vec2 P = df.x * m_perp;
		var P = box2d.b2MulSV(df.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
//		float32 LA = df.x * m_s1 + df.y;
		var LA = df.x * this.m_s1 + df.y;
//		float32 LB = df.x * m_s2 + df.y;
		var LB = df.x * this.m_s2 + df.y;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3();
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3();
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);
	
	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

//	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	b2Vec2 d = cB + rB - cA - rA;
	var d = box2d.b2SubVV(
		box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0),
		box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1),
		box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d);

//	b2Vec2 axis = b2Mul(qA, m_localXAxisA);
	var axis = box2d.b2MulRV(qA, this.m_localXAxisA, this.m_axis);
//	float32 a1 = b2Cross(d + rA, axis);
	var a1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), axis);
//	float32 a2 = b2Cross(rB, axis);
	var a2 = box2d.b2CrossVV(rB, axis);
//	b2Vec2 perp = b2Mul(qA, m_localYAxisA);
	var perp = box2d.b2MulRV(qA, this.m_localYAxisA, this.m_perp);

//	float32 s1 = b2Cross(d + rA, perp);
	var s1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), perp);
//	float32 s2 = b2Cross(rB, perp);
	var s2 = box2d.b2CrossVV(rB, perp);

//	box2d.b2Vec3 impulse;
	var impulse = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse;
//	b2Vec2 C1;
//	C1.x = b2Dot(perp, d);
	var C1_x = box2d.b2DotVV(perp, d);
//	C1.y = aB - aA - m_referenceAngle;
	var C1_y = aB - aA - this.m_referenceAngle;

	var linearError = box2d.b2Abs(C1_x);
	var angularError = box2d.b2Abs(C1_y);

	var active = false;
	var C2 = 0;
	if (this.m_enableLimit)
	{
//		float32 translation = b2Dot(axis, d);
		var translation = box2d.b2DotVV(axis, d);
		if (box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop)
		{
			// Prevent large angular corrections
			C2 = box2d.b2Clamp(translation, (-box2d.b2_maxLinearCorrection), box2d.b2_maxLinearCorrection);
			linearError = box2d.b2Max(linearError, box2d.b2Abs(translation));
			active = true;
		}
		else if (translation <= this.m_lowerTranslation)
		{
			// Prevent large linear corrections and allow some slop.
			C2 = box2d.b2Clamp(translation - this.m_lowerTranslation + box2d.b2_linearSlop, (-box2d.b2_maxLinearCorrection), 0);
			linearError = box2d.b2Max(linearError, this.m_lowerTranslation - translation);
			active = true;
		}
		else if (translation >= this.m_upperTranslation)
		{
			// Prevent large linear corrections and allow some slop.
			C2 = box2d.b2Clamp(translation - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection);
			linearError = box2d.b2Max(linearError, translation - this.m_upperTranslation);
			active = true;
		}
	}

	if (active)
	{
//		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
		var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
//		float32 k12 = iA * s1 + iB * s2;
		var k12 = iA * s1 + iB * s2;
//		float32 k13 = iA * s1 * a1 + iB * s2 * a2;
		var k13 = iA * s1 * a1 + iB * s2 * a2;
//		float32 k22 = iA + iB;
		var k22 = iA + iB;
		if (k22 === 0)
		{
			// For fixed rotation
			k22 = 1;
		}
//		float32 k23 = iA * a1 + iB * a2;
		var k23 = iA * a1 + iB * a2;
//		float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
		var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;

//		box2d.b2Mat33 K;
		var K = this.m_K3;
//		K.ex.Set(k11, k12, k13);
		K.ex.SetXYZ(k11, k12, k13);
//		K.ey.Set(k12, k22, k23);
		K.ey.SetXYZ(k12, k22, k23);
//		K.ez.Set(k13, k23, k33);
		K.ez.SetXYZ(k13, k23, k33);

//		box2d.b2Vec3 C;
//		C.x = C1.x;
//		C.y = C1.y;
//		C.z = C2;

//		impulse = K.Solve33(-C);
		impulse = K.Solve33((-C1_x), (-C1_y), (-C2), impulse);
	}
	else
	{
//		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
		var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
//		float32 k12 = iA * s1 + iB * s2;
		var k12 = iA * s1 + iB * s2;
//		float32 k22 = iA + iB;
		var k22 = iA + iB;
		if (k22 === 0)
		{
			k22 = 1;
		}

//		box2d.b2Mat22 K;
		var K2 = this.m_K2;
//		K.ex.Set(k11, k12);
		K2.ex.SetXY(k11, k12);
//		K.ey.Set(k12, k22);
		K2.ey.SetXY(k12, k22);

//		b2Vec2 impulse1 = K.Solve(-C1);
		var impulse1 = K2.Solve((-C1_x), (-C1_y), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1);
		impulse.x = impulse1.x;
		impulse.y = impulse1.y;
		impulse.z = 0;
	}

//	b2Vec2 P = impulse.x * perp + impulse.z * axis;
	var P = box2d.b2AddVV(
		box2d.b2MulSV(impulse.x, perp, box2d.b2Vec2.s_t0), 
		box2d.b2MulSV(impulse.z, axis, box2d.b2Vec2.s_t1), 
		box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P);
//	float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;
	var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
//	float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;
	var LB = impulse.x * s2 + impulse.y + impulse.z * a2;

//	cA -= mA * P;
	cA.SelfMulSub(mA, P);
	aA -= iA * LA;
//	cB += mB * P;
	cB.SelfMulAdd(mB, P);
	aB += iB * LB;

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return linearError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;
}
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3();;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2();;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();;

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PrismaticJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PrismaticJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	return inv_dt * (m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis);
	return out.SetXY(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_impulse.y;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * The local joint axis relative to bodyA. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function (out) { return out.Copy(this.m_localXAxisA); }

/** 
 * Get the reference angle. 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetJointTranslation = function ()
{
//	b2Vec2 pA = m_bodyA.GetWorldPoint(m_localAnchorA);
	var pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA);
//	b2Vec2 pB = m_bodyB.GetWorldPoint(m_localAnchorB);
	var pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB);
//	b2Vec2 d = pB - pA;
	var d = box2d.b2SubVV(pB, pA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d);
//	b2Vec2 axis = m_bodyA.GetWorldVector(m_localXAxisA);
	var axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);

//	float32 translation = b2Dot(d, axis);
	var translation = box2d.b2DotVV(d, axis);
	return translation;
}
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2();
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2();

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetJointSpeed = function ()
{
	/*box2d.b2Body*/ var bA = this.m_bodyA;
	/*box2d.b2Body*/ var bB = this.m_bodyB;

//	b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);
	box2d.b2SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);
	var rA = box2d.b2MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);
	box2d.b2SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);
	var rB = box2d.b2MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);
//	b2Vec2 pA = bA->m_sweep.c + rA;
	var pA = box2d.b2AddVV(bA.m_sweep.c, rA, box2d.b2Vec2.s_t0); // pA uses s_t0
//	b2Vec2 pB = bB->m_sweep.c + rB;
	var pB = box2d.b2AddVV(bB.m_sweep.c, rB, box2d.b2Vec2.s_t1); // pB uses s_t1
//	b2Vec2 d = pB - pA;
	var d = box2d.b2SubVV(pB, pA, box2d.b2Vec2.s_t2); // d uses s_t2
//	b2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);
	var axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);

	var vA = bA.m_linearVelocity;
	var vB = bB.m_linearVelocity;
	var wA = bA.m_angularVelocity;
	var wB = bB.m_angularVelocity;

//	float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));
	var speed = 
		box2d.b2DotVV(d, box2d.b2CrossSV(wA, axis, box2d.b2Vec2.s_t0)) + 
		box2d.b2DotVV(
			axis, 
			box2d.b2SubVV(
				box2d.b2AddVCrossSV(vB, wB, rB, box2d.b2Vec2.s_t0),
				box2d.b2AddVCrossSV(vA, wA, rA, box2d.b2Vec2.s_t1), 
				box2d.b2Vec2.s_t0));
	return speed;
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function ()
{
	return this.m_enableLimit;
}

/** 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2PrismaticJoint.prototype.EnableLimit = function (flag)
{
	if (flag !== this.m_enableLimit)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_enableLimit = flag;
		this.m_impulse.z = 0;
	}
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetLowerLimit = function ()
{
	return this.m_lowerTranslation;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetUpperLimit = function ()
{
	return this.m_upperTranslation;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} upper 
 * @param {number} lower 
 */
box2d.b2PrismaticJoint.prototype.SetLimits = function (lower, upper)
{
	if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_lowerTranslation = lower;
		this.m_upperTranslation = upper;
		this.m_impulse.z = 0;
	}
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function ()
{
	return this.m_enableMotor;
}

/** 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2PrismaticJoint.prototype.EnableMotor = function (flag)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_enableMotor = flag;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} speed 
 */
box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function (speed)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_motorSpeed = speed;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function ()
{
	return this.m_motorSpeed;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} force
 */
box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function (force)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_maxMotorForce = force;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function () { return this.m_maxMotorForce; }

/** 
 * @export 
 * @return {number}
 * @param {number} inv_dt 
 */
box2d.b2PrismaticJoint.prototype.GetMotorForce = function (inv_dt)
{
	return inv_dt * this.m_motorImpulse;
}

/** 
 * Dump to b2Log 
 * @export 
 * @return {void}
 */
box2d.b2PrismaticJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
		box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
		box2d.b2Log("  jd.enableLimit = %s;\n", (this.m_enableLimit)?('true'):('false'));
		box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
		box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
		box2d.b2Log("  jd.enableMotor = %s;\n", (this.m_enableMotor)?('true'):('false'));
		box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
		box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2GearJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');
goog.require('box2d.b2RevoluteJoint');
goog.require('box2d.b2PrismaticJoint');

/** 
 * Gear joint definition. This definition requires two existing 
 * revolute or prismatic joints (any combination will work). 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2GearJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_gearJoint); // base class constructor
}

goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef);

/** 
 * The first revolute/prismatic joint attached to the gear 
 * joint. 
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2GearJointDef.prototype.joint1 = null;

/** 
 * The second revolute/prismatic joint attached to the gear 
 * joint. 
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2GearJointDef.prototype.joint2 = null;

/** 
 * The gear ratio. 
 * @see box2d.b2GearJoint for explanation. 
 * @export 
 * @type {number}
 */
box2d.b2GearJointDef.prototype.ratio = 1;

/** 
 * A gear joint is used to connect two joints together. Either 
 * joint can be a revolute or prismatic joint. You specify a 
 * gear ratio to bind the motions together: 
 * coordinateA + ratio * coordinateB = constant 
 * The ratio can be negative or positive. If one joint is a 
 * revolute joint and the other joint is a prismatic joint, then 
 * the ratio will have units of length or units of 1/length. 
 * warning You have to manually destroy the gear joint if jointA 
 * or jointB is destroyed. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2GearJointDef} def 
 */
box2d.b2GearJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_joint1 = def.joint1;
	this.m_joint2 = def.joint2;

	this.m_localAnchorA = new box2d.b2Vec2();
	this.m_localAnchorB = new box2d.b2Vec2();
	this.m_localAnchorC = new box2d.b2Vec2();
	this.m_localAnchorD = new box2d.b2Vec2();

	this.m_localAxisC = new box2d.b2Vec2();
	this.m_localAxisD = new box2d.b2Vec2();

	this.m_lcA = new box2d.b2Vec2(), this.m_lcB = new box2d.b2Vec2(), this.m_lcC = new box2d.b2Vec2(), this.m_lcD = new box2d.b2Vec2();
	this.m_JvAC = new box2d.b2Vec2(), this.m_JvBD = new box2d.b2Vec2();

	this.m_qA = new box2d.b2Rot(), this.m_qB = new box2d.b2Rot(), this.m_qC = new box2d.b2Rot(), this.m_qD = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2(), this.m_lalcB = new box2d.b2Vec2(), this.m_lalcC = new box2d.b2Vec2(), this.m_lalcD = new box2d.b2Vec2();

	this.m_typeA = this.m_joint1.GetType();
	this.m_typeB = this.m_joint2.GetType();

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_typeA === box2d.b2JointType.e_revoluteJoint || this.m_typeA === box2d.b2JointType.e_prismaticJoint); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_typeB === box2d.b2JointType.e_revoluteJoint || this.m_typeB === box2d.b2JointType.e_prismaticJoint); }

	/*float32*/ var coordinateA, coordinateB;

	// TODO_ERIN there might be some problem with the joint edges in b2Joint.

	this.m_bodyC = this.m_joint1.GetBodyA();
	this.m_bodyA = this.m_joint1.GetBodyB();

	// Get geometry of joint1
	/*box2d.b2Transform*/ var xfA = this.m_bodyA.m_xf;
	/*float32*/ var aA = this.m_bodyA.m_sweep.a;
	/*box2d.b2Transform*/ var xfC = this.m_bodyC.m_xf;
	/*float32*/ var aC = this.m_bodyC.m_sweep.a;

	if (this.m_typeA === box2d.b2JointType.e_revoluteJoint)
	{
		/*box2d.b2RevoluteJoint*/ var revolute = def.joint1;
		this.m_localAnchorC.Copy(revolute.m_localAnchorA);
		this.m_localAnchorA.Copy(revolute.m_localAnchorB);
		this.m_referenceAngleA = revolute.m_referenceAngle;
		this.m_localAxisC.SetZero();

		coordinateA = aA - aC - this.m_referenceAngleA;
	}
	else
	{
		/*box2d.b2PrismaticJoint*/ var prismatic = def.joint1;
		this.m_localAnchorC.Copy(prismatic.m_localAnchorA);
		this.m_localAnchorA.Copy(prismatic.m_localAnchorB);
		this.m_referenceAngleA = prismatic.m_referenceAngle;
		this.m_localAxisC.Copy(prismatic.m_localXAxisA);

//		b2Vec2 pC = m_localAnchorC;
		var pC = this.m_localAnchorC;
//		b2Vec2 pA = b2MulT(xfC.q, b2Mul(xfA.q, m_localAnchorA) + (xfA.p - xfC.p));
		var pA = box2d.b2MulTRV(
			xfC.q,
			box2d.b2AddVV(
				box2d.b2MulRV(xfA.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), 
				box2d.b2SubVV(xfA.p, xfC.p, box2d.b2Vec2.s_t1),
				box2d.b2Vec2.s_t0),
			box2d.b2Vec2.s_t0); // pA uses s_t0
//		coordinateA = b2Dot(pA - pC, m_localAxisC);
		coordinateA = box2d.b2DotVV(box2d.b2SubVV(pA, pC, box2d.b2Vec2.s_t0), this.m_localAxisC);
	}

	this.m_bodyD = this.m_joint2.GetBodyA();
	this.m_bodyB = this.m_joint2.GetBodyB();

	// Get geometry of joint2
	/*box2d.b2Transform*/ var xfB = this.m_bodyB.m_xf;
	/*float32*/ var aB = this.m_bodyB.m_sweep.a;
	/*box2d.b2Transform*/ var xfD = this.m_bodyD.m_xf;
	/*float32*/ var aD = this.m_bodyD.m_sweep.a;

	if (this.m_typeB === box2d.b2JointType.e_revoluteJoint)
	{
		/*box2d.b2RevoluteJoint*/ var revolute = def.joint2;
		this.m_localAnchorD.Copy(revolute.m_localAnchorA);
		this.m_localAnchorB.Copy(revolute.m_localAnchorB);
		this.m_referenceAngleB = revolute.m_referenceAngle;
		this.m_localAxisD.SetZero();

		coordinateB = aB - aD - this.m_referenceAngleB;
	}
	else
	{
		/*box2d.b2PrismaticJoint*/ var prismatic = def.joint2;
		this.m_localAnchorD.Copy(prismatic.m_localAnchorA);
		this.m_localAnchorB.Copy(prismatic.m_localAnchorB);
		this.m_referenceAngleB = prismatic.m_referenceAngle;
		this.m_localAxisD.Copy(prismatic.m_localXAxisA);

//		b2Vec2 pD = m_localAnchorD;
		var pD = this.m_localAnchorD;
//		b2Vec2 pB = b2MulT(xfD.q, b2Mul(xfB.q, m_localAnchorB) + (xfB.p - xfD.p));
		var pB = box2d.b2MulTRV(
			xfD.q,
			box2d.b2AddVV(
				box2d.b2MulRV(xfB.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), 
				box2d.b2SubVV(xfB.p, xfD.p, box2d.b2Vec2.s_t1),
				box2d.b2Vec2.s_t0),
			box2d.b2Vec2.s_t0); // pB uses s_t0
//		coordinateB = b2Dot(pB - pD, m_localAxisD);
		coordinateB = box2d.b2DotVV(box2d.b2SubVV(pB, pD, box2d.b2Vec2.s_t0), this.m_localAxisD);
	}

	this.m_ratio = def.ratio;

	this.m_constant = coordinateA + this.m_ratio * coordinateB;

	this.m_impulse = 0;
}

goog.inherits(box2d.b2GearJoint, box2d.b2Joint);

/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2GearJoint.prototype.m_joint1 = null;
/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2GearJoint.prototype.m_joint2 = null;

/**
 * @export 
 * @type {box2d.b2JointType}
 */
box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint;
/**
 * @export 
 * @type {box2d.b2JointType}
 */
box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint;

// Body A is connected to body C
// Body B is connected to body D
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2GearJoint.prototype.m_bodyC = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2GearJoint.prototype.m_bodyD = null;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAnchorC = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAnchorD = null;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAxisC = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_localAxisD = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_referenceAngleA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_referenceAngleB = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_constant = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_ratio = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_impulse = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_indexC = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_indexD = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lcB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lcC = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lcD = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_mA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_mB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_mC = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_mD = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_iA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_iB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_iC = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_iD = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_JvAC = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_JvBD = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_JwA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_JwB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_JwC = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_JwD = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2GearJoint.prototype.m_mass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2GearJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2GearJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2GearJoint.prototype.m_qC = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2GearJoint.prototype.m_qD = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lalcC = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2GearJoint.prototype.m_lalcD = null;

/**
 * @param {box2d.b2SolverData} data
 */
box2d.b2GearJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_indexC = this.m_bodyC.m_islandIndex;
	this.m_indexD = this.m_bodyD.m_islandIndex;
	this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
	this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
	this.m_mA = this.m_bodyA.m_invMass;
	this.m_mB = this.m_bodyB.m_invMass;
	this.m_mC = this.m_bodyC.m_invMass;
	this.m_mD = this.m_bodyD.m_invMass;
	this.m_iA = this.m_bodyA.m_invI;
	this.m_iB = this.m_bodyB.m_invI;
	this.m_iC = this.m_bodyC.m_invI;
	this.m_iD = this.m_bodyD.m_invI;

	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var aC = data.positions[this.m_indexC].a;
	/*box2d.b2Vec2&*/ var vC = data.velocities[this.m_indexC].v;
	/*float32*/ var wC = data.velocities[this.m_indexC].w;

	/*float32*/ var aD = data.positions[this.m_indexD].a;
	/*box2d.b2Vec2&*/ var vD = data.velocities[this.m_indexD].v;
	/*float32*/ var wD = data.velocities[this.m_indexD].w;

//	box2d.b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
	var qA = this.m_qA.SetAngleRadians(aA), 
		qB = this.m_qB.SetAngleRadians(aB), 
		qC = this.m_qC.SetAngleRadians(aC), 
		qD = this.m_qD.SetAngleRadians(aD);

	this.m_mass = 0;

	if (this.m_typeA === box2d.b2JointType.e_revoluteJoint)
	{
		this.m_JvAC.SetZero();
		this.m_JwA = 1;
		this.m_JwC = 1;
		this.m_mass += this.m_iA + this.m_iC;
	}
	else
	{
//		b2Vec2 u = b2Mul(qC, m_localAxisC);
		var u = box2d.b2MulRV(qC, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
//		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
		box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);
		var rC = box2d.b2MulRV(qC, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC);
//		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
		box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);
		var rA = box2d.b2MulRV(qA, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA);
//		m_JvAC = u;
		this.m_JvAC.Copy(u);
//		m_JwC = b2Cross(rC, u);
		this.m_JwC = box2d.b2CrossVV(rC, u);
//		m_JwA = b2Cross(rA, u);
		this.m_JwA = box2d.b2CrossVV(rA, u);
		this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
	}

	if (this.m_typeB === box2d.b2JointType.e_revoluteJoint)
	{
		this.m_JvBD.SetZero();
		this.m_JwB = this.m_ratio;
		this.m_JwD = this.m_ratio;
		this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
	}
	else
	{
//		b2Vec2 u = b2Mul(qD, m_localAxisD);
		var u = box2d.b2MulRV(qD, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
//		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
		box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);
		var rD = box2d.b2MulRV(qD, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD);
//		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
		box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);
		var rB = box2d.b2MulRV(qB, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB);
//		m_JvBD = m_ratio * u;
		box2d.b2MulSV(this.m_ratio, u, this.m_JvBD);
//		m_JwD = m_ratio * b2Cross(rD, u);
		this.m_JwD = this.m_ratio * box2d.b2CrossVV(rD, u);
//		m_JwB = m_ratio * b2Cross(rB, u);
		this.m_JwB = this.m_ratio * box2d.b2CrossVV(rB, u);
		this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
	}

	// Compute effective mass.
	this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;

	if (data.step.warmStarting)
	{
//		vA += (m_mA * m_impulse) * m_JvAC;
		vA.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC);
		wA += this.m_iA * this.m_impulse * this.m_JwA;
//		vB += (m_mB * m_impulse) * m_JvBD;
		vB.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD);
		wB += this.m_iB * this.m_impulse * this.m_JwB;
//		vC -= (m_mC * m_impulse) * m_JvAC;
		vC.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC);
		wC -= this.m_iC * this.m_impulse * this.m_JwC;
//		vD -= (m_mD * m_impulse) * m_JvBD;
		vD.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD);
		wD -= this.m_iD * this.m_impulse * this.m_JwD;
	}
	else
	{
		this.m_impulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
//	data.velocities[this.m_indexC].v = vC;
	data.velocities[this.m_indexC].w = wC;
//	data.velocities[this.m_indexD].v = vD;
	data.velocities[this.m_indexD].w = wD;
}
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2();

/**
 * @param {box2d.b2SolverData} data
 */
box2d.b2GearJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;
	/*box2d.b2Vec2&*/ var vC = data.velocities[this.m_indexC].v;
	/*float32*/ var wC = data.velocities[this.m_indexC].w;
	/*box2d.b2Vec2&*/ var vD = data.velocities[this.m_indexD].v;
	/*float32*/ var wD = data.velocities[this.m_indexD].w;

//	float32 Cdot = b2Dot(m_JvAC, vA - vC) + b2Dot(m_JvBD, vB - vD);
	var Cdot = 
		box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(vA, vC, box2d.b2Vec2.s_t0)) + 
		box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(vB, vD, box2d.b2Vec2.s_t0));
	Cdot += (this.m_JwA * wA - this.m_JwC * wC) + (this.m_JwB * wB - this.m_JwD * wD);

	/*float32*/ var impulse = -this.m_mass * Cdot;
	this.m_impulse += impulse;

//	vA += (m_mA * impulse) * m_JvAC;
	vA.SelfMulAdd((this.m_mA * impulse), this.m_JvAC);
	wA += this.m_iA * impulse * this.m_JwA;
//	vB += (m_mB * impulse) * m_JvBD;
	vB.SelfMulAdd((this.m_mB * impulse), this.m_JvBD);
	wB += this.m_iB * impulse * this.m_JwB;
//	vC -= (m_mC * impulse) * m_JvAC;
	vC.SelfMulSub((this.m_mC * impulse), this.m_JvAC);
	wC -= this.m_iC * impulse * this.m_JwC;
//	vD -= (m_mD * impulse) * m_JvBD;
	vD.SelfMulSub((this.m_mD * impulse), this.m_JvBD);
	wD -= this.m_iD * impulse * this.m_JwD;

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
//	data.velocities[this.m_indexC].v = vC;
	data.velocities[this.m_indexC].w = wC;
//	data.velocities[this.m_indexD].v = vD;
	data.velocities[this.m_indexD].w = wD;
}

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2GearJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var cC = data.positions[this.m_indexC].c;
	/*float32*/ var aC = data.positions[this.m_indexC].a;
	/*box2d.b2Vec2&*/ var cD = data.positions[this.m_indexD].c;
	/*float32*/ var aD = data.positions[this.m_indexD].a;

//	box2d.b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
	var qA = this.m_qA.SetAngleRadians(aA), 
		qB = this.m_qB.SetAngleRadians(aB), 
		qC = this.m_qC.SetAngleRadians(aC), 
		qD = this.m_qD.SetAngleRadians(aD);

	/*float32*/ var linearError = 0;

	/*float32*/ var coordinateA, coordinateB;

	/*box2d.b2Vec2*/ var JvAC = this.m_JvAC, JvBD = this.m_JvBD;
	/*float32*/ var JwA, JwB, JwC, JwD;
	/*float32*/ var mass = 0;

	if (this.m_typeA === box2d.b2JointType.e_revoluteJoint)
	{
		JvAC.SetZero();
		JwA = 1;
		JwC = 1;
		mass += this.m_iA + this.m_iC;

		coordinateA = aA - aC - this.m_referenceAngleA;
	}
	else
	{
//		b2Vec2 u = b2Mul(qC, m_localAxisC);
		var u = box2d.b2MulRV(qC, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
//		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
		var rC = box2d.b2MulRV(qC, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC);
//		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
		var rA = box2d.b2MulRV(qA, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
//		JvAC = u;
		JvAC.Copy(u);
//		JwC = b2Cross(rC, u);
		JwC = box2d.b2CrossVV(rC, u);
//		JwA = b2Cross(rA, u);
		JwA = box2d.b2CrossVV(rA, u);
		mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;

//		b2Vec2 pC = m_localAnchorC - m_lcC;
		var pC = this.m_lalcC;
//		b2Vec2 pA = b2MulT(qC, rA + (cA - cC));
		var pA = box2d.b2MulTRV(
			qC,
			box2d.b2AddVV(
				rA, 
				box2d.b2SubVV(cA, cC, box2d.b2Vec2.s_t0), 
				box2d.b2Vec2.s_t0),
			box2d.b2Vec2.s_t0); // pA uses s_t0
//		coordinateA = b2Dot(pA - pC, m_localAxisC);
		coordinateA = box2d.b2DotVV(box2d.b2SubVV(pA, pC, box2d.b2Vec2.s_t0), this.m_localAxisC);
	}

	if (this.m_typeB === box2d.b2JointType.e_revoluteJoint)
	{
		JvBD.SetZero();
		JwB = this.m_ratio;
		JwD = this.m_ratio;
		mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);

		coordinateB = aB - aD - this.m_referenceAngleB;
	}
	else
	{
//		b2Vec2 u = b2Mul(qD, m_localAxisD);
		var u = box2d.b2MulRV(qD, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
//		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
		var rD = box2d.b2MulRV(qD, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD);
//		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
		var rB = box2d.b2MulRV(qB, this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
//		JvBD = m_ratio * u;
		box2d.b2MulSV(this.m_ratio, u, JvBD);
//		JwD = m_ratio * b2Cross(rD, u);
		JwD = this.m_ratio * box2d.b2CrossVV(rD, u);
//		JwB = m_ratio * b2Cross(rB, u);
		JwB = this.m_ratio * box2d.b2CrossVV(rB, u);
		mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;

//		b2Vec2 pD = m_localAnchorD - m_lcD;
		var pD = this.m_lalcD;
//		b2Vec2 pB = b2MulT(qD, rB + (cB - cD));
		var pB = box2d.b2MulTRV(
			qD,
			box2d.b2AddVV(
				rB, 
				box2d.b2SubVV(cB, cD, box2d.b2Vec2.s_t0), 
				box2d.b2Vec2.s_t0),
			box2d.b2Vec2.s_t0); // pB uses s_t0
//		coordinateB = b2Dot(pB - pD, m_localAxisD);
		coordinateB = box2d.b2DotVV(box2d.b2SubVV(pB, pD, box2d.b2Vec2.s_t0), this.m_localAxisD);
	}

	/*float32*/ var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant;

	/*float32*/ var impulse = 0;
	if (mass > 0)
	{
		impulse = -C / mass;
	}

//	cA += m_mA * impulse * JvAC;
	cA.SelfMulAdd(this.m_mA * impulse, JvAC);
	aA += this.m_iA * impulse * JwA;
//	cB += m_mB * impulse * JvBD;
	cB.SelfMulAdd(this.m_mB * impulse, JvBD);
	aB += this.m_iB * impulse * JwB;
//	cC -= m_mC * impulse * JvAC;
	cC.SelfMulSub(this.m_mC * impulse, JvAC);
	aC -= this.m_iC * impulse * JwC;
//	cD -= m_mD * impulse * JvBD;
	cD.SelfMulSub(this.m_mD * impulse, JvBD);
	aD -= this.m_iD * impulse * JwD;

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;
//	data.positions[this.m_indexC].c = cC;
	data.positions[this.m_indexC].a = aC;
//	data.positions[this.m_indexD].c = cD;
	data.positions[this.m_indexD].a = aD;

	// TODO_ERIN not implemented
	return linearError < box2d.b2_linearSlop;
}
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2();
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2();

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2GearJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2GearJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2GearJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	b2Vec2 P = m_impulse * m_JvAC;
//	return inv_dt * P;
	return box2d.b2MulSV(inv_dt * this.m_impulse, this.m_JvAC, out);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2GearJoint.prototype.GetReactionTorque = function (inv_dt)
{
//	float32 L = m_impulse * m_JwA;
//	return inv_dt * L;
	return inv_dt * this.m_impulse * this.m_JwA;
}

/** 
 * Get the first joint. 
 * @export 
 * @return {box2d.b2Joint}
 */
box2d.b2GearJoint.prototype.GetJoint1 = function () { return this.m_joint1; }

/** 
 * Get the second joint. 
 * @export 
 * @return {box2d.b2Joint}
 */
box2d.b2GearJoint.prototype.GetJoint2 = function () { return this.m_joint2; }

/** 
 * @export 
 * @return {number}
 */
box2d.b2GearJoint.prototype.GetRatio = function ()
{
	return this.m_ratio;
}

/** 
 * @export 
 * @return {void} 
 * @param {number} ratio
 */
box2d.b2GearJoint.prototype.SetRatio = function (ratio)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(ratio)); }
	this.m_ratio = ratio;
}

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2GearJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		var index1 = this.m_joint1.m_index;
		var index2 = this.m_joint2.m_index;
	
		box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.joint1 = joints[%d];\n", index1);
		box2d.b2Log("  jd.joint2 = joints[%d];\n", index2);
		box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Distance');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');

/** 
 * A distance proxy is used by the GJK algorithm. 
 * It encapsulates any shape.
 * @export 
 * @constructor
 */
box2d.b2DistanceProxy = function ()
{
	this.m_buffer = box2d.b2Vec2.MakeArray(2);
};

/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2DistanceProxy.prototype.m_buffer = null;
/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2DistanceProxy.prototype.m_vertices = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceProxy.prototype.m_count = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceProxy.prototype.m_radius = 0;

/**
 * @export 
 * @return {box2d.b2DistanceProxy} 
 */
box2d.b2DistanceProxy.prototype.Reset = function ()
{
	this.m_vertices = null;
	this.m_count = 0;
	this.m_radius = 0;
	return this;
}

/** 
 * Initialize the proxy using the given shape. The shape must 
 * remain in scope while the proxy is in use. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Shape} shape 
 * @param {number} index
 */
box2d.b2DistanceProxy.prototype.SetShape = function (shape, index)
{
	shape.SetupDistanceProxy(this, index);
}

/** 
 * Get the supporting vertex index in the given direction. 
 * @export 
 * @return {number} 
 * @param {box2d.b2Vec2} d 
 */
box2d.b2DistanceProxy.prototype.GetSupport = function (d)
{
	/** @type {number} */ var bestIndex = 0;
	/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_vertices[0], d);
	for (var i = 1; i < this.m_count; ++i)
	{
		/** @type {number} */ var value = box2d.b2DotVV(this.m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}

	return bestIndex;
}

/** 
 * Get the supporting vertex in the given direction. 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} d 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2DistanceProxy.prototype.GetSupportVertex = function (d, out)
{
	/** @type {number} */ var bestIndex = 0;
	/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_vertices[0], d);
	for (var i = 1; i < this.m_count; ++i)
	{
		/** @type {number} */ var value = box2d.b2DotVV(this.m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}

	return out.Copy(this.m_vertices[bestIndex]);
}

/** 
 * Get the vertex count. 
 * @export 
 * @return {number}
 */
box2d.b2DistanceProxy.prototype.GetVertexCount = function ()
{
	return this.m_count;
}

/** 
 * Get a vertex by index. Used by box2d.b2Distance. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {number} index 
 */
box2d.b2DistanceProxy.prototype.GetVertex = function (index)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count); }
	return this.m_vertices[index];
}

/** 
 * Used to warm start box2d.b2Distance. 
 * Set count to zero on first call.
 * @export 
 * @constructor
 */
box2d.b2SimplexCache = function ()
{
	this.indexA = box2d.b2MakeNumberArray(3);
	this.indexB = box2d.b2MakeNumberArray(3);
};

/**
 * @export 
 * @type {number}
 */
box2d.b2SimplexCache.prototype.metric = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2SimplexCache.prototype.count = 0;
/**
 * @export 
 * @type {Array.<number>}
 */
box2d.b2SimplexCache.prototype.indexA = null;
/**
 * @export 
 * @type {Array.<number>}
 */
box2d.b2SimplexCache.prototype.indexB = null;

/**
 * @export 
 * @return {box2d.b2SimplexCache} 
 */
box2d.b2SimplexCache.prototype.Reset = function ()
{
	this.metric = 0;
	this.count = 0;
	return this;
}

/** 
 * Input for box2d.b2Distance. 
 * You have to option to use the shape radii in the computation. 
 * @export 
 * @constructor
 */
box2d.b2DistanceInput = function ()
{
	this.proxyA = new box2d.b2DistanceProxy();
	this.proxyB = new box2d.b2DistanceProxy();
	this.transformA = new box2d.b2Transform();
	this.transformB = new box2d.b2Transform();
};

/**
 * @export 
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2DistanceInput.prototype.proxyA = null;
/**
 * @export 
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2DistanceInput.prototype.proxyB = null;
/**
 * @export 
 * @type {box2d.b2Transform}
 */
box2d.b2DistanceInput.prototype.transformA = null;
/**
 * @export 
 * @type {box2d.b2Transform}
 */
box2d.b2DistanceInput.prototype.transformB = null;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2DistanceInput.prototype.useRadii = false;

/**
 * @export 
 * @return {box2d.b2DistanceInput} 
 */
box2d.b2DistanceInput.prototype.Reset = function ()
{
	this.proxyA.Reset();
	this.proxyB.Reset();
	this.transformA.SetIdentity();
	this.transformB.SetIdentity();
	this.useRadii = false;
	return this;
}

/** 
 * Output for box2d.b2Distance. 
 * @export 
 * @constructor 
 */
box2d.b2DistanceOutput = function ()
{
	this.pointA = new box2d.b2Vec2();
	this.pointB = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceOutput.prototype.pointA = null;	///< closest point on shapeA
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceOutput.prototype.pointB = null;	///< closest point on shapeB
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceOutput.prototype.distance = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceOutput.prototype.iterations = 0; ///< number of GJK iterations used

/**
 * @export 
 * @return {box2d.b2DistanceOutput} 
 */
box2d.b2DistanceOutput.prototype.Reset = function ()
{
	this.pointA.SetZero();
	this.pointB.SetZero();
	this.distance = 0;
	this.iterations = 0;
	return this;
}

/**
 * GJK using Voronoi regions (Christer Ericson) and Barycentric 
 * coordinates. 
 */

/**
 * @export 
 * @type {number}
 */
box2d.b2_gjkCalls = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2_gjkIters = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2_gjkMaxIters = 0;

/**
 * @export 
 * @constructor
 */
box2d.b2SimplexVertex = function ()
{
	this.wA = new box2d.b2Vec2();
	this.wB = new box2d.b2Vec2();
	this.w = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2SimplexVertex.prototype.wA = null; // support point in proxyA
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2SimplexVertex.prototype.wB = null; // support point in proxyB
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2SimplexVertex.prototype.w = null; // wB - wA
/**
 * @export 
 * @type {number}
 */
box2d.b2SimplexVertex.prototype.a = 0; // barycentric coordinate for closest point
/**
 * @export 
 * @type {number}
 */
box2d.b2SimplexVertex.prototype.indexA = 0; // wA index
/**
 * @export 
 * @type {number}
 */
box2d.b2SimplexVertex.prototype.indexB = 0; // wB index

/**
 * @export 
 * @return {box2d.b2SimplexVertex} 
 * @param {box2d.b2SimplexVertex} other 
 */
box2d.b2SimplexVertex.prototype.Copy = function (other)
{
	this.wA.Copy(other.wA);		// support point in proxyA
	this.wB.Copy(other.wB);     // support point in proxyB
	this.w.Copy(other.w);       // wB - wA
	this.a = other.a;           // barycentric coordinate for closest point
	this.indexA = other.indexA; // wA index
	this.indexB = other.indexB; // wB index
	return this;
}

/**
 * @export 
 * @constructor
 */
box2d.b2Simplex = function ()
{
	this.m_v1 = new box2d.b2SimplexVertex();
	this.m_v2 = new box2d.b2SimplexVertex();
	this.m_v3 = new box2d.b2SimplexVertex();
	this.m_vertices = new Array(3);
	this.m_vertices[0] = this.m_v1;
	this.m_vertices[1] = this.m_v2;
	this.m_vertices[2] = this.m_v3;
}

/**
 * @export 
 * @type {box2d.b2SimplexVertex}
 */
box2d.b2Simplex.prototype.m_v1 = null;
/**
 * @export 
 * @type {box2d.b2SimplexVertex}
 */
box2d.b2Simplex.prototype.m_v2 = null;
/**
 * @export 
 * @type {box2d.b2SimplexVertex}
 */
box2d.b2Simplex.prototype.m_v3 = null;
/**
 * @export 
 * @type {Array.<box2d.b2SimplexVertex>}
 */
box2d.b2Simplex.prototype.m_vertices = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Simplex.prototype.m_count = 0;

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SimplexCache} cache 
 * @param {box2d.b2DistanceProxy} proxyA 
 * @param {box2d.b2Transform} transformA 
 * @param {box2d.b2DistanceProxy} proxyB 
 * @param {box2d.b2Transform} transformB 
 */
box2d.b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= cache.count && cache.count <= 3); }

	// Copy data from cache.
	this.m_count = cache.count;
	/** @type Array.<box2d.b2SimplexVertex> */ var vertices = this.m_vertices;
	for (var i = 0; i < this.m_count; ++i)
	{
		/** @type {box2d.b2SimplexVertex} */ var v = vertices[i];
		v.indexA = cache.indexA[i];
		v.indexB = cache.indexB[i];
		/** @type {box2d.b2Vec2} */ var wALocal = proxyA.GetVertex(v.indexA);
		/** @type {box2d.b2Vec2} */ var wBLocal = proxyB.GetVertex(v.indexB);
		box2d.b2MulXV(transformA, wALocal, v.wA);
		box2d.b2MulXV(transformB, wBLocal, v.wB);
		box2d.b2SubVV(v.wB, v.wA, v.w);
		v.a = 0;
	}

	// Compute the new simplex metric, if it is substantially different than
	// old metric then flush the simplex.
	if (this.m_count > 1)
	{
		/** @type {number} */ var metric1 = cache.metric;
		/** @type {number} */ var metric2 = this.GetMetric();
		if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < box2d.b2_epsilon)
		{
			// Reset the simplex.
			this.m_count = 0;
		}
	}

	// If the cache is empty or invalid ...
	if (this.m_count === 0)
	{
		/** type {box2d.b2SimplexVertex} */ var v = vertices[0];
		v.indexA = 0;
		v.indexB = 0;
		/** type {box2d.b2Vec2} */ var wALocal = proxyA.GetVertex(0);
		/** type {box2d.b2Vec2} */ var wBLocal = proxyB.GetVertex(0);
		box2d.b2MulXV(transformA, wALocal, v.wA);
		box2d.b2MulXV(transformB, wBLocal, v.wB);
		box2d.b2SubVV(v.wB, v.wA, v.w);
		v.a = 1;
		this.m_count = 1;
	}
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SimplexCache} cache 
 */
box2d.b2Simplex.prototype.WriteCache = function (cache)
{
	cache.metric = this.GetMetric();
	cache.count = this.m_count;
	/** @type {Array.<box2d.b2SimplexVertex>} */ var vertices = this.m_vertices;
	for (var i = 0; i < this.m_count; ++i)
	{
		cache.indexA[i] = vertices[i].indexA;
		cache.indexB[i] = vertices[i].indexB;
	}
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Simplex.prototype.GetSearchDirection = function (out)
{
	switch (this.m_count)
	{
	case 1:
		return box2d.b2NegV(this.m_v1.w, out);

	case 2:
		{
			var e12 = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, out);
			var sgn = box2d.b2CrossVV(e12, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0));
			if (sgn > 0)
			{
				// Origin is left of e12.
				return box2d.b2CrossOneV(e12, out);
			}
			else
			{
				// Origin is right of e12.
				return box2d.b2CrossVOne(e12, out);
			}
		}

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return out.SetZero();
	}
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Simplex.prototype.GetClosestPoint = function (out)
{
	switch (this.m_count)
	{
	case 0:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return out.SetZero();

	case 1:
		return out.Copy(this.m_v1.w);

	case 2:
		return out.SetXY(
			this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, 
			this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);

	case 3:
		return out.SetZero();

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return out.SetZero();
	}
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} pA
 * @param {box2d.b2Vec2} pB 
 */
box2d.b2Simplex.prototype.GetWitnessPoints = function (pA, pB)
{
	switch (this.m_count)
	{
	case 0:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		break;

	case 1:
		pA.Copy(this.m_v1.wA);
		pB.Copy(this.m_v1.wB);
		break;

	case 2:
		pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
		pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
		pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
		pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
		break;

	case 3:
		pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
		pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
		break;

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		break;
	}
}

/**
 * @export 
 * @return {number}
 */
box2d.b2Simplex.prototype.GetMetric = function ()
{
	switch (this.m_count)
	{
	case 0:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return 0;

	case 1:
		return 0;

	case 2:
		return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);

	case 3:
		return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return 0;
	}
}

/** 
 * Solve a line segment using barycentric coordinates.
 *
 * p = a1 * w1 + a2 * w2
 * a1 + a2 = 1
 *
 * The vector from the origin to the closest point on the line is
 * perpendicular to the line.
 * e12 = w2 - w1
 * dot(p, e) = 0
 * a1 * dot(w1, e) + a2 * dot(w2, e) = 0
 *
 * 2-by-2 linear system
 * [1      1     ][a1] = [1]
 * [w1.e12 w2.e12][a2] = [0]
 *
 * Define
 * d12_1 =  dot(w2, e12)
 * d12_2 = -dot(w1, e12)
 * d12 = d12_1 + d12_2
 *
 * Solution
 * a1 = d12_1 / d12
 * a2 = d12_2 / d12
 *  
 * @export 
 * @return {void} 
 */
box2d.b2Simplex.prototype.Solve2 = function ()
{
	/** @type {box2d.b2Vec2} */ var w1 = this.m_v1.w;
	/** @type {box2d.b2Vec2} */ var w2 = this.m_v2.w;
	/** @type {box2d.b2Vec2} */ var e12 = box2d.b2SubVV(w2, w1, box2d.b2Simplex.s_e12);

	// w1 region
	/** @type {number} */ var d12_2 = (-box2d.b2DotVV(w1, e12));
	if (d12_2 <= 0)
	{
		// a2 <= 0, so we clamp it to 0
		this.m_v1.a = 1;
		this.m_count = 1;
		return;
	}

	// w2 region
	/** @type {number} */ var d12_1 = box2d.b2DotVV(w2, e12);
	if (d12_1 <= 0)
	{
		// a1 <= 0, so we clamp it to 0
		this.m_v2.a = 1;
		this.m_count = 1;
		this.m_v1.Copy(this.m_v2);
		return;
	}

	// Must be in e12 region.
	/** @type {number} */ var inv_d12 = 1 / (d12_1 + d12_2);
	this.m_v1.a = d12_1 * inv_d12;
	this.m_v2.a = d12_2 * inv_d12;
	this.m_count = 2;
}

/**
 * Possible regions:
 * - points[2]
 * - edge points[0]-points[2]
 * - edge points[1]-points[2]
 * - inside the triangle
 * @export 
 * @return {void} 
 */
box2d.b2Simplex.prototype.Solve3 = function ()
{
	/** @type {box2d.b2Vec2} */ var w1 = this.m_v1.w;
	/** @type {box2d.b2Vec2} */ var w2 = this.m_v2.w;
	/** @type {box2d.b2Vec2} */ var w3 = this.m_v3.w;

	// Edge12
	// [1      1     ][a1] = [1]
	// [w1.e12 w2.e12][a2] = [0]
	// a3 = 0
	/** @type {box2d.b2Vec2} */ var e12 = box2d.b2SubVV(w2, w1, box2d.b2Simplex.s_e12);
	/** @type {number} */ var w1e12 = box2d.b2DotVV(w1, e12);
	/** @type {number} */ var w2e12 = box2d.b2DotVV(w2, e12);
	/** @type {number} */ var d12_1 = w2e12;
	/** @type {number} */ var d12_2 = (-w1e12);

	// Edge13
	// [1      1     ][a1] = [1]
	// [w1.e13 w3.e13][a3] = [0]
	// a2 = 0
	/** @type {box2d.b2Vec2} */ var e13 = box2d.b2SubVV(w3, w1, box2d.b2Simplex.s_e13);
	/** @type {number} */ var w1e13 = box2d.b2DotVV(w1, e13);
	/** @type {number} */ var w3e13 = box2d.b2DotVV(w3, e13);
	/** @type {number} */ var d13_1 = w3e13;
	/** @type {number} */ var d13_2 = (-w1e13);

	// Edge23
	// [1      1     ][a2] = [1]
	// [w2.e23 w3.e23][a3] = [0]
	// a1 = 0
	/** @type {box2d.b2Vec2} */ var e23 = box2d.b2SubVV(w3, w2, box2d.b2Simplex.s_e23);
	/** @type {number} */ var w2e23 = box2d.b2DotVV(w2, e23);
	/** @type {number} */ var w3e23 = box2d.b2DotVV(w3, e23);
	/** @type {number} */ var d23_1 = w3e23;
	/** @type {number} */ var d23_2 = (-w2e23);

	// Triangle123
	/** @type {number} */ var n123 = box2d.b2CrossVV(e12, e13);

	/** @type {number} */ var d123_1 = n123 * box2d.b2CrossVV(w2, w3);
	/** @type {number} */ var d123_2 = n123 * box2d.b2CrossVV(w3, w1);
	/** @type {number} */ var d123_3 = n123 * box2d.b2CrossVV(w1, w2);

	// w1 region
	if (d12_2 <= 0 && d13_2 <= 0)
	{
		this.m_v1.a = 1;
		this.m_count = 1;
		return;
	}

	// e12
	if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0)
	{
		/** @type {number} */ var inv_d12 = 1 / (d12_1 + d12_2);
		this.m_v1.a = d12_1 * inv_d12;
		this.m_v2.a = d12_2 * inv_d12;
		this.m_count = 2;
		return;
	}

	// e13
	if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0)
	{
		/** @type {number} */ var inv_d13 = 1 / (d13_1 + d13_2);
		this.m_v1.a = d13_1 * inv_d13;
		this.m_v3.a = d13_2 * inv_d13;
		this.m_count = 2;
		this.m_v2.Copy(this.m_v3);
		return;
	}

	// w2 region
	if (d12_1 <= 0 && d23_2 <= 0)
	{
		this.m_v2.a = 1;
		this.m_count = 1;
		this.m_v1.Copy(this.m_v2);
		return;
	}

	// w3 region
	if (d13_1 <= 0 && d23_1 <= 0)
	{
		this.m_v3.a = 1;
		this.m_count = 1;
		this.m_v1.Copy(this.m_v3);
		return;
	}

	// e23
	if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0)
	{
		/** @type {number} */ var inv_d23 = 1 / (d23_1 + d23_2);
		this.m_v2.a = d23_1 * inv_d23;
		this.m_v3.a = d23_2 * inv_d23;
		this.m_count = 2;
		this.m_v1.Copy(this.m_v3);
		return;
	}

	// Must be in triangle123
	/** @type {number} */ var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
	this.m_v1.a = d123_1 * inv_d123;
	this.m_v2.a = d123_2 * inv_d123;
	this.m_v3.a = d123_3 * inv_d123;
	this.m_count = 3;
}
box2d.b2Simplex.s_e12 = new box2d.b2Vec2();
box2d.b2Simplex.s_e13 = new box2d.b2Vec2();
box2d.b2Simplex.s_e23 = new box2d.b2Vec2();

/** 
 * Compute the closest points between two shapes. Supports any combination of:
 * box2d.b2CircleShape, box2d.b2PolygonShape, box2d.b2EdgeShape. The simplex cache is input/output.
 * On the first call set box2d.b2SimplexCache.count to zero.
 * @export 
 * @param {box2d.b2DistanceOutput} output 
 * @param {box2d.b2SimplexCache} cache 
 * @param {box2d.b2DistanceInput} input 
 * @return {void} 
 */
box2d.b2Distance = function (output, cache, input)
{
	++box2d.b2_gjkCalls;

	var proxyA = input.proxyA;
	var proxyB = input.proxyB;

	var transformA = input.transformA;
	var transformB = input.transformB;

	// Initialize the simplex.
	/** @type {box2d.b2Simplex} */ var simplex = box2d.b2Distance.s_simplex;
	simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);

	// Get simplex vertices as an array.
	/** @type {Array.<box2d.b2SimplexVertex>} */ var vertices = simplex.m_vertices;
	/** @type {number} */ var k_maxIters = 20;

	// These store the vertices of the last simplex so that we
	// can check for duplicates and prevent cycling.
	/** @type {Array.<number>} */ var saveA = box2d.b2Distance.s_saveA;
	/** @type {Array.<number>} */ var saveB = box2d.b2Distance.s_saveB;
	/** @type {number} */ var saveCount = 0;

	/** @type {number} */ var distanceSqr1 = box2d.b2_maxFloat;
	/** @type {number} */ var distanceSqr2 = distanceSqr1;

	// Main iteration loop.
	var iter = 0;
	while (iter < k_maxIters)
	{
		// Copy simplex so we can identify duplicates.
		saveCount = simplex.m_count;
		for (var i = 0; i < saveCount; ++i)
		{
			saveA[i] = vertices[i].indexA;
			saveB[i] = vertices[i].indexB;
		}

		switch (simplex.m_count)
		{
		case 1:
			break;

		case 2:
			simplex.Solve2();
			break;

		case 3:
			simplex.Solve3();
			break;

		default:
			if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		}

		// If we have 3 points, then the origin is in the corresponding triangle.
		if (simplex.m_count === 3)
		{
			break;
		}

		// Compute closest point.
		/** @type {box2d.b2Vec2} */ var p = simplex.GetClosestPoint(box2d.b2Distance.s_p);
		distanceSqr2 = p.GetLengthSquared();

		// Ensure progress
		/*
		TODO: to fix compile warning
		if (distanceSqr2 > distanceSqr1)
		{
			//break;
		}
		*/
		distanceSqr1 = distanceSqr2;

		// Get search direction.
		/** @type {box2d.b2Vec2} */ var d = simplex.GetSearchDirection(box2d.b2Distance.s_d);

		// Ensure the search direction is numerically fit.
		if (d.GetLengthSquared() < box2d.b2_epsilon_sq)
		{
			// The origin is probably contained by a line segment
			// or triangle. Thus the shapes are overlapped.

			// We can't return zero here even though there may be overlap.
			// In case the simplex is a point, segment, or triangle it is difficult
			// to determine if the origin is contained in the CSO or very close to it.
			break;
		}

		// Compute a tentative new simplex vertex using support points.
		/** @type {box2d.b2SimplexVertex} */ var vertex = vertices[simplex.m_count];
		vertex.indexA = proxyA.GetSupport(box2d.b2MulTRV(transformA.q, box2d.b2NegV(d, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA));
		box2d.b2MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);
		vertex.indexB = proxyB.GetSupport(box2d.b2MulTRV(transformB.q, d, box2d.b2Distance.s_supportB));
		box2d.b2MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);
		box2d.b2SubVV(vertex.wB, vertex.wA, vertex.w);

		// Iteration count is equated to the number of support point calls.
		++iter;
		++box2d.b2_gjkIters;

		// Check for duplicate support points. This is the main termination criteria.
		/** @type {boolean} */ var duplicate = false;
		for (var i = 0; i < saveCount; ++i)
		{
			if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i])
			{
				duplicate = true;
				break;
			}
		}

		// If we found a duplicate support point we must exit to avoid cycling.
		if (duplicate)
		{
			break;
		}

		// New vertex is ok and needed.
		++simplex.m_count;
	}

	box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, iter);

	// Prepare output.
	simplex.GetWitnessPoints(output.pointA, output.pointB);
	output.distance = box2d.b2DistanceVV(output.pointA, output.pointB);
	output.iterations = iter;

	// Cache the simplex.
	simplex.WriteCache(cache);

	// Apply radii if requested.
	if (input.useRadii)
	{
		/** @type {number} */ var rA = proxyA.m_radius;
		/** @type {number} */ var rB = proxyB.m_radius;

		if (output.distance > (rA + rB) && output.distance > box2d.b2_epsilon)
		{
			// Shapes are still no overlapped.
			// Move the witness points to the outer surface.
			output.distance -= rA + rB;
			/** @type {box2d.b2Vec2} */ var normal = box2d.b2SubVV(output.pointB, output.pointA, box2d.b2Distance.s_normal);
			normal.Normalize();
			output.pointA.SelfMulAdd(rA, normal);
			output.pointB.SelfMulSub(rB, normal);
		}
		else
		{
			// Shapes are overlapped when radii are considered.
			// Move the witness points to the middle.
			/** type {box2d.b2Vec2} */ var p = box2d.b2MidVV(output.pointA, output.pointB, box2d.b2Distance.s_p);
			output.pointA.Copy(p);
			output.pointB.Copy(p);
			output.distance = 0;
		}
	}
}
box2d.b2Distance.s_simplex = new box2d.b2Simplex();
box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_p = new box2d.b2Vec2();
box2d.b2Distance.s_d = new box2d.b2Vec2();
box2d.b2Distance.s_normal = new box2d.b2Vec2();
box2d.b2Distance.s_supportA = new box2d.b2Vec2();
box2d.b2Distance.s_supportB = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2WeldJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Weld joint definition. You need to specify local anchor 
 * points where they are attached and the relative body angle. 
 * The position of the anchor points is important for computing 
 * the reaction torque. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2WeldJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_weldJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2();
	this.localAnchorB = new box2d.b2Vec2();
}

goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJointDef.prototype.localAnchorB = null;

/** 
 * The bodyB angle minus bodyA angle in the reference state 
 * (radians). 
 * @export 
 * @type {number}
 */
box2d.b2WeldJointDef.prototype.referenceAngle = 0;

/** 
 * The mass-spring-damper frequency in Hertz. Rotation only. 
 * Disable softness with a value of 0. 
 * @export 
 * @type {number}
 */
box2d.b2WeldJointDef.prototype.frequencyHz = 0;

/** 
 * The damping ratio. 0 = no damping, 1 = critical damping. 
 * @export 
 * @type {number}
 */
box2d.b2WeldJointDef.prototype.dampingRatio = 0;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} anchor 
 */
box2d.b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
	this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();
}

/** 
 * A weld joint essentially glues two bodies together. A weld 
 * joint may distort somewhat because the island constraint 
 * solver is approximate. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2WeldJointDef} def 
 */
box2d.b2WeldJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_frequencyHz = def.frequencyHz;
	this.m_dampingRatio = def.dampingRatio;

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();
	this.m_referenceAngle = def.referenceAngle;
	this.m_impulse = new box2d.b2Vec3(0, 0, 0);

	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();
	this.m_mass = new box2d.b2Mat33();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_K = new box2d.b2Mat33();
}

goog.inherits(box2d.b2WeldJoint, box2d.b2Joint);

/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_frequencyHz = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_dampingRatio = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_bias = 0;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_referenceAngle = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_gamma = 0;
/**
 * @export 
 * @type {box2d.b2Vec3}
 */
box2d.b2WeldJoint.prototype.m_impulse = null;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WeldJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Mat33}
 */
box2d.b2WeldJoint.prototype.m_mass = null;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2WeldJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2WeldJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WeldJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Mat33}
 */
box2d.b2WeldJoint.prototype.m_K = null;

/**
 * @param {box2d.b2SolverData} data
 */
box2d.b2WeldJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*b2Mat33*/ var K = this.m_K;
	K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
	K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
	K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
	K.ex.y = K.ey.x;
	K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
	K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
	K.ex.z = K.ez.x;
	K.ey.z = K.ez.y;
	K.ez.z = iA + iB;

	if (this.m_frequencyHz > 0)
	{
		K.GetInverse22(this.m_mass);

		/*float32*/ var invM = iA + iB;
		/*float32*/ var m = invM > 0 ? 1 / invM : 0;

		/*float32*/ var C = aB - aA - this.m_referenceAngle;

		// Frequency
		/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;

		// Damping coefficient
		/*float32*/ var d = 2 * m * this.m_dampingRatio * omega;

		// Spring stiffness
		/*float32*/ var k = m * omega * omega;

		// magic formulas
		/*float32*/ var h = data.step.dt;
		this.m_gamma = h * (d + h * k);
		this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;
		this.m_bias = C * h * k * this.m_gamma;

		invM += this.m_gamma;
		this.m_mass.ez.z = invM !== 0 ? 1 / invM : 0;
	}
	else
	{
		K.GetSymInverse33(this.m_mass);
		this.m_gamma = 0;
		this.m_bias = 0;
	}

	if (data.step.warmStarting)
	{
		// Scale impulses to support a variable time step.
		this.m_impulse.SelfMul(data.step.dtRatio);

//		box2d.b2Vec2 P(m_impulse.x, m_impulse.y);
		var P = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_impulse.z);

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_impulse.z);
	}
	else
	{
		this.m_impulse.SetZero();
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	if (this.m_frequencyHz > 0)
	{
		/*float32*/ var Cdot2 = wB - wA;

		/*float32*/ var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
		this.m_impulse.z += impulse2;

		wA -= iA * impulse2;
		wB += iB * impulse2;

//		b2Vec2 Cdot1 = vB + b2CrossSV(wB, this.m_rB) - vA - b2CrossSV(wA, this.m_rA);
		var Cdot1 = box2d.b2SubVV(
			box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),
			box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),
			box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1)

//		b2Vec2 impulse1 = -b2Mul22(m_mass, Cdot1);
		var impulse1 = box2d.b2MulM33XY(this.m_mass, Cdot1.x, Cdot1.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
		this.m_impulse.x += impulse1.x;
		this.m_impulse.y += impulse1.y;

//		b2Vec2 P = impulse1;
		var P = impulse1;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
//		wA -= iA * b2Cross(m_rA, P);
		wA -= iA * box2d.b2CrossVV(this.m_rA, P);

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
//		wB += iB * b2Cross(m_rB, P);
		wB += iB * box2d.b2CrossVV(this.m_rB, P);
	}
	else
	{
//		b2Vec2 Cdot1 = vB + b2Cross(wB, this.m_rB) - vA - b2Cross(wA, this.m_rA);
		var Cdot1 = box2d.b2SubVV(
			box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),
			box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),
			box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1)
		/*float32*/ var Cdot2 = wB - wA;
//		b2Vec3 var Cdot(Cdot1.x, Cdot1.y, Cdot2);
	
//		b2Vec3 impulse = -b2Mul(m_mass, Cdot);
		var impulse = box2d.b2MulM33XYZ(this.m_mass, Cdot1.x, Cdot1.y, Cdot2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
		this.m_impulse.SelfAdd(impulse);
	
//		box2d.b2Vec2 P(impulse.x, impulse.y);
		var P = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(impulse.x, impulse.y);
	
//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);
	
//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2();
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2();
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3();
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2WeldJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

//	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	/*float32*/ var positionError, angularError;

	/*b2Mat33*/ var K = this.m_K;
	K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
	K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
	K.ez.x = -rA.y * iA - rB.y * iB;
	K.ex.y = K.ey.x;
	K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
	K.ez.y = rA.x * iA + rB.x * iB;
	K.ex.z = K.ez.x;
	K.ey.z = K.ez.y;
	K.ez.z = iA + iB;

	if (this.m_frequencyHz > 0)
	{
//		b2Vec2 C1 =  cB + rB - cA - rA;
		var C1 = 
			box2d.b2SubVV(
				box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), 
				box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1);
		positionError = C1.GetLength();
		angularError = 0;

//		b2Vec2 P = -K.Solve22(C1);
		var P = K.Solve22(C1.x, C1.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();

//		cA -= mA * P;
		cA.SelfMulSub(mA, P);
		aA -= iA * box2d.b2CrossVV(rA, P);

//		cB += mB * P;
		cB.SelfMulAdd(mB, P);
		aB += iB * box2d.b2CrossVV(rB, P);
	}
	else
	{
//		b2Vec2 C1 =  cB + rB - cA - rA;
		var C1 = 
			box2d.b2SubVV(
				box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), 
				box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1);
		/*float32*/ var C2 = aB - aA - this.m_referenceAngle;
	
		positionError = C1.GetLength();
		angularError = box2d.b2Abs(C2);
	
//		b2Vec3 C(C1.x, C1.y, C2);
	
//		b2Vec3 impulse = -K.Solve33(C);
		/*box2d.b2Vec3*/ var impulse = K.Solve33(C1.x, C1.y, C2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
	
//		b2Vec2 P(impulse.x, impulse.y);
		var P = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(impulse.x, impulse.y);
	
//		cA -= mA * P;
		cA.SelfMulSub(mA, P);
		aA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);
	
//		cB += mB * P;
		cB.SelfMulAdd(mB, P);
		aB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);
	}

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return positionError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;
}
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2();
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3();

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WeldJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WeldJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2WeldJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	box2d.b2Vec2 P(this.m_impulse.x, this.m_impulse.y);
//	return inv_dt * P;
	return out.SetXY(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2WeldJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_impulse.z;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WeldJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WeldJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * Get the reference angle. 
 * @export 
 * @return {number}
 */
box2d.b2WeldJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }

/** 
 * Set/get frequency in Hz. 
 * @return {void} 
 * @param {number} hz 
 */
box2d.b2WeldJoint.prototype.SetFrequency = function (hz) { this.m_frequencyHz = hz; }
/** 
 * @export 
 * @return {number}
 */
box2d.b2WeldJoint.prototype.GetFrequency = function () { return this.m_frequencyHz; }

/** 
 * Set/get damping ratio. 
 * @return {void} 
 * @param {number} ratio 
 */
box2d.b2WeldJoint.prototype.SetDampingRatio = function (ratio) { this.m_dampingRatio = ratio; }
/** 
 * @export 
 * @return {number}
 */
box2d.b2WeldJoint.prototype.GetDampingRatio = function () { return this.m_dampingRatio; }

/** 
 * Dump to b2Log 
 * @export 
 * @return {void}
 */
box2d.b2WeldJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
		box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
		box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2RopeJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Rope joint definition. This requires two body anchor points 
 * and a maximum lengths. 
 * Note: by default the connected objects will not collide. see 
 * collideConnected in box2d.b2JointDef. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2RopeJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_ropeJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2(-1, 0);
	this.localAnchorB = new box2d.b2Vec2(1, 0);
}

goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJointDef.prototype.localAnchorB = null;

/** 
 * The maximum length of the rope. 
 * Warning: this must be larger than box2d.b2_linearSlop or the 
 * joint will have no effect. 
 * @export 
 * @type {number}
 */
box2d.b2RopeJointDef.prototype.maxLength = 0;

/** 
 * A rope joint enforces a maximum distance between two points 
 * on two bodies. It has no other effect. 
 * Warning: if you attempt to change the maximum length during 
 * the simulation you will get some non-physical behavior. A 
 * model that would allow you to dynamically modify the length 
 * would have some sponginess, so I chose not to implement it 
 * that way. See box2d.b2DistanceJoint if you want to 
 * dynamically control length. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2RopeJointDef} def 
 */
box2d.b2RopeJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();
	this.m_maxLength = def.maxLength;

	this.m_u = new box2d.b2Vec2();
	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
}

goog.inherits(box2d.b2RopeJoint, box2d.b2Joint);

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_maxLength = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_length = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_impulse = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_u = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2RopeJoint.prototype.m_mass = 0;
/**
 * @export 
 * @type {box2d.b2LimitState}
 */
box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2RopeJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2RopeJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RopeJoint.prototype.m_lalcB = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2RopeJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	this.m_rA = b2Mul(qA, this.m_localAnchorA - this.m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	this.m_rB = b2Mul(qB, this.m_localAnchorB - this.m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	this.m_u = cB + this.m_rB - cA - this.m_rA;
	this.m_u.Copy(cB).SelfAdd(this.m_rB).SelfSub(cA).SelfSub(this.m_rA);

	this.m_length = this.m_u.GetLength();

	/*float32*/ var C = this.m_length - this.m_maxLength;
	if (C > 0)
	{
		this.m_state = box2d.b2LimitState.e_atUpperLimit;
	}
	else
	{
		this.m_state = box2d.b2LimitState.e_inactiveLimit;
	}

	if (this.m_length > box2d.b2_linearSlop)
	{
		this.m_u.SelfMul(1 / this.m_length);
	}
	else
	{
		this.m_u.SetZero();
		this.m_mass = 0;
		this.m_impulse = 0;
		return;
	}

	// Compute effective mass.
	/*float32*/ var crA = box2d.b2CrossVV(this.m_rA, this.m_u);
	/*float32*/ var crB = box2d.b2CrossVV(this.m_rB, this.m_u);
	/*float32*/ var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;

	this.m_mass = invMass !== 0 ? 1 / invMass : 0;

	if (data.step.warmStarting)
	{
		// Scale the impulse to support a variable time step.
		this.m_impulse *= data.step.dtRatio;

//		b2Vec2 P = m_impulse * m_u;
		var P = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P);
//		vA -= m_invMassA * P;
		vA.SelfMulSub(this.m_invMassA, P);
		wA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);
//		vB += m_invMassB * P;
		vB.SelfMulAdd(this.m_invMassB, P);
		wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);
	}
	else
	{
		this.m_impulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	// Cdot = dot(u, v + cross(w, r))
//	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
	var vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA);
//	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
	var vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB);
//	float32 C = m_length - m_maxLength;
	/*float32*/ var C = this.m_length - this.m_maxLength;
//	float32 Cdot = b2Dot(m_u, vpB - vpA);
	/*float32*/ var Cdot = box2d.b2DotVV(this.m_u, box2d.b2SubVV(vpB, vpA, box2d.b2Vec2.s_t0));

	// Predictive constraint.
	if (C < 0)
	{
		Cdot += data.step.inv_dt * C;
	}

	/*float32*/ var impulse = -this.m_mass * Cdot;
	/*float32*/ var oldImpulse = this.m_impulse;
	this.m_impulse = box2d.b2Min(0, this.m_impulse + impulse);
	impulse = this.m_impulse - oldImpulse;

//	b2Vec2 P = impulse * m_u;
	var P = box2d.b2MulSV(impulse, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
//	vA -= m_invMassA * P;
	vA.SelfMulSub(this.m_invMassA, P);
	wA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);
//	vB += m_invMassB * P;
	vB.SelfMulAdd(this.m_invMassB, P);
	wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2RopeJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	b2Vec2 rA = b2Mul(qA, this.m_localAnchorA - this.m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(qB, this.m_localAnchorB - this.m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	b2Vec2 u = cB + rB - cA - rA;
	/*box2d.b2Vec2*/ var u = this.m_u.Copy(cB).SelfAdd(rB).SelfSub(cA).SelfSub(rA);

	/*float32*/ var length = u.Normalize();
	/*float32*/ var C = length - this.m_maxLength;

	C = box2d.b2Clamp(C, 0, box2d.b2_maxLinearCorrection);

	/*float32*/ var impulse = -this.m_mass * C;
//	b2Vec2 P = impulse * u;
	var P = box2d.b2MulSV(impulse, u, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);

//	cA -= m_invMassA * P;
	cA.SelfMulSub(this.m_invMassA, P);
	aA -= this.m_invIA * box2d.b2CrossVV(rA, P);
//	cB += m_invMassB * P;
	cB.SelfMulAdd(this.m_invMassB, P);
	aB += this.m_invIB * box2d.b2CrossVV(rB, P);

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return length - this.m_maxLength < box2d.b2_linearSlop;
}
box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RopeJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RopeJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2RopeJoint.prototype.GetReactionForce = function (inv_dt, out)
{
	/*box2d.b2Vec2*/ var F = box2d.b2MulSV((inv_dt * this.m_impulse), this.m_u, out);
	return F;
//	return out.SetXY(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2RopeJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RopeJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2RopeJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * Set/Get the maximum length of the rope. 
 * @export 
 * @return {void} 
 * @param {number} length
 */
box2d.b2RopeJoint.prototype.SetMaxLength = function (length) { this.m_maxLength = length; }
/** 
 * @export 
 * @return {number} 
 */
box2d.b2RopeJoint.prototype.GetMaxLength = function ()
{
	return this.m_maxLength;
}

/** 
 * @export 
 * @return {box2d.b2LimitState}
 */
box2d.b2RopeJoint.prototype.GetLimitState = function ()
{
	return this.m_state;
}

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2RopeJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2GravityController');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Controller');
goog.require('box2d.b2Math');

/** 
 * Applies simplified gravity between every pair of bodies 
 * @export 
 * @constructor 
 * @extends {box2d.b2Controller} 
 */
box2d.b2GravityController = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2GravityController, box2d.b2Controller);

/** 
 * Specifies the strength of the gravitiation force 
 * @export 
 * @type {number} 
 */
box2d.b2GravityController.prototype.G = 1;
/** 
 * If true, gravity is proportional to r^-2, otherwise r^-1 
 * @export 
 * @type {boolean} 
 */
box2d.b2GravityController.prototype.invSqr = true;

/** 
 * @see b2Controller::Step 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2GravityController.prototype.Step = function (step)
{
	if (this.invSqr)
	{
		for (var i = this.m_bodyList; i; i = i.nextBody)
		{
			var body1 = i.body;
			var p1 = body1.GetWorldCenter();
			var mass1 = body1.GetMass();
			for (var j = this.m_bodyList; j !== i; j = j.nextBody)
			{
				var body2 = j.body;
				var p2 = body2.GetWorldCenter();
				var mass2 = body2.GetMass();
				var dx = p2.x - p1.x;
				var dy = p2.y - p1.y;
				var r2 = dx * dx + dy * dy;
				if (r2 < box2d.b2_epsilon)
					continue;
				var f = box2d.b2GravityController.prototype.Step.s_f.SetXY(dx, dy);
				f.SelfMul(this.G / r2 / box2d.b2Sqrt(r2) * mass1 * mass2);
				if (body1.IsAwake())
					body1.ApplyForce(f, p1);
				if (body2.IsAwake())
					body2.ApplyForce(f.SelfMul(-1), p2);
			}
		}
	}
	else
	{
		for (var i = this.m_bodyList; i; i = i.nextBody)
		{
			var body1 = i.body;
			var p1 = body1.GetWorldCenter();
			var mass1 = body1.GetMass();
			for (var j = this.m_bodyList; j !== i; j = j.nextBody)
			{
				var body2 = j.body;
				var p2 = body2.GetWorldCenter();
				var mass2 = body2.GetMass();
				var dx = p2.x - p1.x;
				var dy = p2.y - p1.y;
				var r2 = dx * dx + dy * dy;
				if (r2 < box2d.b2_epsilon)
					continue;
				var f = box2d.b2GravityController.prototype.Step.s_f.SetXY(dx, dy);
				f.SelfMul(this.G / r2 * mass1 * mass2);
				if (body1.IsAwake())
					body1.ApplyForce(f, p1);
				if (body2.IsAwake())
					body2.ApplyForce(f.SelfMul(-1), p2);
			}
		}
	}
}
box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2TimeStep');

goog.require('box2d.b2Settings');

/** 
 * Profiling data. Times are in milliseconds. 
 * @export 
 * @constructor
 */
box2d.b2Profile = function ()
{
};

/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.step = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.collide = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.solve = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.solveInit = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.solveVelocity = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.solvePosition = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.broadphase = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Profile.prototype.solveTOI = 0;

/** 
 * @export 
 * @return {box2d.b2Profile}
 */
box2d.b2Profile.prototype.Reset = function ()
{
	this.step = 0;
	this.collide = 0;
	this.solve = 0;
	this.solveInit = 0;
	this.solveVelocity = 0;
	this.solvePosition = 0;
	this.broadphase = 0;
	this.solveTOI = 0;
	return this;
}

/** 
 * This is an internal structure. 
 * @export 
 * @constructor
 */
box2d.b2TimeStep = function ()
{
};

/**
 * @export 
 * @type {number}
 */
box2d.b2TimeStep.prototype.dt = 0; // time step
/**
 * @export 
 * @type {number}
 */
box2d.b2TimeStep.prototype.inv_dt = 0; // inverse time step (0 if dt === 0).
/**
 * @export 
 * @type {number}
 */
box2d.b2TimeStep.prototype.dtRatio = 0; // dt * inv_dt0
/**
 * @export 
 * @type {number}
 */
box2d.b2TimeStep.prototype.velocityIterations = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2TimeStep.prototype.positionIterations = 0;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2TimeStep.prototype.warmStarting = false;

/** 
 * @export 
 * @return {box2d.b2TimeStep} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2TimeStep.prototype.Copy = function (step)
{
	this.dt = step.dt;				// time step                        
	this.inv_dt = step.inv_dt;  	// inverse time step (0 if dt === 0).
	this.dtRatio = step.dtRatio;	// dt * inv_dt0
	this.positionIterations = step.positionIterations;
	this.velocityIterations = step.velocityIterations;
	this.warmStarting = step.warmStarting;
	return this;
}

/** 
 * This is an internal structure. 
 * @export 
 * @constructor 
 */
box2d.b2Position = function ()
{
	this.c = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Position.prototype.c = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Position.prototype.a = 0;

/** 
 * @export 
 * @return {Array.<box2d.b2Position>}
 * @param {number} length 
 */
box2d.b2Position.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2Position(); } );
}

/** 
 * This is an internal structure. 
 * @export 
 * @constructor 
 */
box2d.b2Velocity = function ()
{
	this.v = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Velocity.prototype.v = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Velocity.prototype.w = 0;

/** 
 * @export 
 * @return {Array.<box2d.b2Velocity>}
 * @param {number} length 
 */
box2d.b2Velocity.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2Velocity(); } );
}

/** 
 * Solver Data 
 * @export 
 * @constructor
 */
box2d.b2SolverData = function ()
{
	this.step = new box2d.b2TimeStep();
};

/**
 * @export 
 * @type {box2d.b2TimeStep}
 */
box2d.b2SolverData.prototype.step = null;
/**
 * @export 
 * @type {Array.<box2d.b2Position>}
 */
box2d.b2SolverData.prototype.positions = null;
/**
 * @export 
 * @type {Array.<box2d.b2Velocity>}
 */
box2d.b2SolverData.prototype.velocities = null;

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Collision');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Distance');

/**
 * Structures and functions used for computing contact points, 
 * distance queries, and TOI queries. 
 */

/** 
 * @export 
 * @enum
 */
box2d.b2ContactFeatureType = 
{
	e_vertex	: 0,
	e_face		: 1
};
goog.exportProperty(box2d.b2ContactFeatureType, 'e_vertex', box2d.b2ContactFeatureType.e_vertex);
goog.exportProperty(box2d.b2ContactFeatureType, 'e_face'  , box2d.b2ContactFeatureType.e_face  );

/** 
 * The features that intersect to form the contact point 
 * This must be 4 bytes or less.
 * @export 
 * @constructor 
 * @param {box2d.b2ContactID} id 
 */
box2d.b2ContactFeature = function (id)
{
	this._id = id;
};

/**
 * @export 
 * @type {box2d.b2ContactID}
 */
box2d.b2ContactFeature.prototype._id = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactFeature.prototype._indexA = 0; ///< Feature index on shapeA   
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactFeature.prototype._indexB = 0; ///< Feature index on shapeB   
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactFeature.prototype._typeA = 0; ///< The feature type on shapeA
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactFeature.prototype._typeB = 0; ///< The feature type on shapeB

Object.defineProperty(
	box2d.b2ContactFeature.prototype, 'indexA',
	{
		enumerable: false,
		configurable: true,
		/** @this {box2d.b2ContactFeature} */
		get: function ()
		{
			return this._indexA;
		},
		/** @this {box2d.b2ContactFeature} */
		set: function (value)
		{
			this._indexA = value;
			// update the b2ContactID
			this._id._key = (this._id._key & 0xffffff00) | (this._indexA & 0x000000ff);
		}
	}
);

Object.defineProperty(
	box2d.b2ContactFeature.prototype, 'indexB',
	{
		enumerable: false,
		configurable: true,
		/** @this {box2d.b2ContactFeature} */
		get: function ()
		{
			return this._indexB;
		},
		/** @this {box2d.b2ContactFeature} */
		set: function (value)
		{
			this._indexB = value;
			// update the b2ContactID
			this._id._key = (this._id._key & 0xffff00ff) | ((this._indexB << 8) & 0x0000ff00);
		}
	}
);

Object.defineProperty(
	box2d.b2ContactFeature.prototype, 'typeA',
	{
		enumerable: false,
		configurable: true,
		/** @this {box2d.b2ContactFeature} */
		get: function ()
		{
			return this._typeA;
		},
		/** @this {box2d.b2ContactFeature} */
		set: function (value)
		{
			this._typeA = value;
			// update the b2ContactID
			this._id._key = (this._id._key & 0xff00ffff) | ((this._typeA << 16) & 0x00ff0000);
		}
	}
);

Object.defineProperty(
	box2d.b2ContactFeature.prototype, 'typeB',
	{
		enumerable: false,
		configurable: true,
		/** @this {box2d.b2ContactFeature} */
		get: function ()
		{
			return this._typeB;
		},
		/** @this {box2d.b2ContactFeature} */
		set: function (value)
		{
			this._typeB = value;
			// update the b2ContactID
			this._id._key = (this._id._key & 0x00ffffff) | ((this._typeB << 24) & 0xff000000);
		}
	}
);

/** 
 * Contact ids to facilitate warm starting. 
 * @export 
 * @constructor 
 */
box2d.b2ContactID = function ()
{
	this.cf = new box2d.b2ContactFeature(this);
}

/**
 * @export 
 * @type {box2d.b2ContactFeature}
 */
box2d.b2ContactID.prototype.cf = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactID.prototype.key = 0; ///< Used to quickly compare contact ids.

/**
 * @export 
 * @return {box2d.b2ContactID}
 * @param {box2d.b2ContactID} o
 */
box2d.b2ContactID.prototype.Copy = function (o)
{
	this.key = o.key;
	return this;
}

/**
 * @export 
 * @return {box2d.b2ContactID}
 */
box2d.b2ContactID.prototype.Clone = function ()
{
	return new box2d.b2ContactID().Copy(this);
}

Object.defineProperty(
	box2d.b2ContactID.prototype, 'key',
	{
		enumerable: false,
		configurable: true,
		/** @this {box2d.b2ContactID} */
		get: function ()
		{
			return this._key;
		},
		/** @this {box2d.b2ContactID} */
		set: function (value)
		{
			this._key = value;
			// update the b2ContactFeature
			this.cf._indexA = this._key & 0x000000ff;
			this.cf._indexB = (this._key >> 8) & 0x000000ff;
			this.cf._typeA = (this._key >> 16) & 0x000000ff;
			this.cf._typeB = (this._key >> 24) & 0x000000ff;
		}
	}
);

/**
 * A manifold point is a contact point belonging to a contact
 * manifold. It holds details related to the geometry and dynamics
 * of the contact points.
 * The local point usage depends on the manifold type:
 * -e_circles: the local center of circleB
 * -e_faceA: the local center of cirlceB or the clip point of polygonB
 * -e_faceB: the clip point of polygonA
 * This structure is stored across time steps, so we keep it small.
 * Note: the impulses are used for internal caching and may not
 * provide reliable contact forces, especially for high speed collisions.
 * @export 
 * @constructor
 */
box2d.b2ManifoldPoint = function ()
{
	this.localPoint = new box2d.b2Vec2();
	this.id = new box2d.b2ContactID();
}

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ManifoldPoint.prototype.localPoint = null; ///< usage depends on manifold type
/**
 * @export 
 * @type {number}
 */
box2d.b2ManifoldPoint.prototype.normalImpulse = 0; ///< the non-penetration impulse
/**
 * @export 
 * @type {number}
 */
box2d.b2ManifoldPoint.prototype.tangentImpulse = 0; ///< the friction impulse
/**
 * @export 
 * @type {box2d.b2ContactID}
 */
box2d.b2ManifoldPoint.prototype.id = null; ///< uniquely identifies a contact point between two shapes

/**
 * @export 
 * @return {Array.<box2d.b2ManifoldPoint>}
 * @param {number} length 
 */
box2d.b2ManifoldPoint.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2ManifoldPoint(); } );
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2ManifoldPoint.prototype.Reset = function ()
{
	this.localPoint.SetZero();
	this.normalImpulse = 0;
	this.tangentImpulse = 0;
	this.id.key = 0;
}

/**
 * @export 
 * @return {box2d.b2ManifoldPoint}
 * @param {box2d.b2ManifoldPoint} o 
 */
box2d.b2ManifoldPoint.prototype.Copy = function (o)
{
	this.localPoint.Copy(o.localPoint);
	this.normalImpulse = o.normalImpulse;
	this.tangentImpulse = o.tangentImpulse;
	this.id.Copy(o.id);
	return this;
}

/** 
 * @export 
 * @enum
 */
box2d.b2ManifoldType = 
{
	e_unknown	: -1,
	e_circles	: 0,
	e_faceA		: 1,
	e_faceB		: 2
};
goog.exportProperty(box2d.b2ManifoldType, 'e_unknown', box2d.b2ManifoldType.e_unknown);
goog.exportProperty(box2d.b2ManifoldType, 'e_circles', box2d.b2ManifoldType.e_circles);
goog.exportProperty(box2d.b2ManifoldType, 'e_faceA'  , box2d.b2ManifoldType.e_faceA  );
goog.exportProperty(box2d.b2ManifoldType, 'e_faceB'  , box2d.b2ManifoldType.e_faceB  );

/** 
 * A manifold for two touching convex shapes.
 * Box2D supports multiple types of contact:
 * - clip point versus plane with radius
 * - point versus point with radius (circles)
 * The local point usage depends on the manifold type:
 * -e_circles: the local center of circleA
 * -e_faceA: the center of faceA
 * -e_faceB: the center of faceB
 * Similarly the local normal usage:
 * -e_circles: not used
 * -e_faceA: the normal on polygonA
 * -e_faceB: the normal on polygonB
 * We store contacts in this way so that position correction can
 * account for movement, which is critical for continuous physics.
 * All contact scenarios must be expressed in one of these types.
 * This structure is stored across time steps, so we keep it small.
 * @export 
 * @constructor
 */
box2d.b2Manifold = function ()
{
	this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints);
	this.localNormal = new box2d.b2Vec2();
	this.localPoint = new box2d.b2Vec2();
	this.type = box2d.b2ManifoldType.e_unknown;
	this.pointCount = 0;
}

/**
 * @export 
 * @type {Array.<box2d.b2ManifoldPoint>}
 */
box2d.b2Manifold.prototype.points = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Manifold.prototype.localNormal = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Manifold.prototype.localPoint = null;
/**
 * @export 
 * @type {box2d.b2ManifoldType}
 */
box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown;
/**
 * @export 
 * @type {number}
 */
box2d.b2Manifold.prototype.pointCount = 0;

/** 
 * @export 
 * @return {void} 
 */
box2d.b2Manifold.prototype.Reset = function ()
{
	for (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)
	{
		//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.points[i] instanceof box2d.b2ManifoldPoint); }
		this.points[i].Reset();
	}
	this.localNormal.SetZero();
	this.localPoint.SetZero();
	this.type = box2d.b2ManifoldType.e_unknown;
	this.pointCount = 0;
}

/** 
 * @export 
 * @return {box2d.b2Manifold} 
 * @param {box2d.b2Manifold} o 
 */
box2d.b2Manifold.prototype.Copy = function (o)
{
	this.pointCount = o.pointCount;
	for (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)
	{
		//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.points[i] instanceof box2d.b2ManifoldPoint); }
		this.points[i].Copy(o.points[i]);
	}
	this.localNormal.Copy(o.localNormal);
	this.localPoint.Copy(o.localPoint);
	this.type = o.type;
	return this;
}

/**
 * @export 
 * @return {box2d.b2Manifold}
 */
box2d.b2Manifold.prototype.Clone = function ()
{
	return new box2d.b2Manifold().Copy(this);
}

/** 
 * This is used to compute the current state of a contact 
 * manifold. 
 * @export 
 * @constructor
 */
box2d.b2WorldManifold = function ()
{
	this.normal = new box2d.b2Vec2();
	this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);
	this.separations = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
}

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WorldManifold.prototype.normal = null; ///< world vector pointing from A to B
/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2WorldManifold.prototype.points = null; ///< world contact point (point of intersection)
/**
 * @export 
 * @type {Array.<number>}
 */
box2d.b2WorldManifold.prototype.separations = null; ///< a negative value indicates overlap, in meters

/** 
 * Evaluate the manifold with supplied transforms. This assumes 
 * modest motion from the original state. This does not change 
 * the point count, impulses, etc. The radii must come from the 
 * shapes that generated the manifold. 
 * @export 
 * @param {box2d.b2Manifold} manifold
 * @param {box2d.b2Transform} xfA
 * @param {number} radiusA
 * @param {box2d.b2Transform} xfB
 * @param {number} radiusB 
 * @return {void} 
 */
box2d.b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB)
{
	if (manifold.pointCount === 0)
	{
		return;
	}

	switch (manifold.type)
	{
	case box2d.b2ManifoldType.e_circles:
		{
			this.normal.SetXY(1, 0);
			var pointA = box2d.b2MulXV(xfA, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA);
			var pointB = box2d.b2MulXV(xfB, manifold.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
			if (box2d.b2DistanceSquaredVV(pointA, pointB) > box2d.b2_epsilon_sq)
			{
				box2d.b2SubVV(pointB, pointA, this.normal).SelfNormalize();
			}

			var cA = box2d.b2AddVMulSV(pointA, radiusA, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
			var cB = box2d.b2SubVMulSV(pointB, radiusB, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
			box2d.b2MidVV(cA, cB, this.points[0]);
			this.separations[0] = box2d.b2DotVV(box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);
		}
		break;

	case box2d.b2ManifoldType.e_faceA:
		{
			box2d.b2MulRV(xfA.q, manifold.localNormal, this.normal);
			var planePoint = box2d.b2MulXV(xfA, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);

			for (var i = 0, ict = manifold.pointCount; i < ict; ++i)
			{
				var clipPoint = box2d.b2MulXV(xfB, manifold.points[i].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint);
				var s = radiusA - box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal);
				var cA = box2d.b2AddVMulSV(clipPoint, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
				var cB = box2d.b2SubVMulSV(clipPoint, radiusB, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
				box2d.b2MidVV(cA, cB, this.points[i]);
				this.separations[i] = box2d.b2DotVV(box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);
			}
		}
		break;

	case box2d.b2ManifoldType.e_faceB:
		{
			box2d.b2MulRV(xfB.q, manifold.localNormal, this.normal);
			var planePoint = box2d.b2MulXV(xfB, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);

			for (var i = 0, ict = manifold.pointCount; i < ict; ++i)
			{
				var clipPoint = box2d.b2MulXV(xfA, manifold.points[i].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint);
				var s = radiusB - box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal);
				var cB = box2d.b2AddVMulSV(clipPoint, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
				var cA = box2d.b2SubVMulSV(clipPoint, radiusA, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
				box2d.b2MidVV(cA, cB, this.points[i]);
				this.separations[i] = box2d.b2DotVV(box2d.b2SubVV(cA, cB, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cA - cB, normal);
			}

			// Ensure normal points from A to B.
			this.normal.SelfNeg();
		}
		break;
	}
}
box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2();
box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2();
box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2();
box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2();
box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2();
box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2();

/** 
 * This is used for determining the state of contact points. 
 * @export 
 * @enum
 */
box2d.b2PointState = 
{
	b2_nullState	: 0, ///< point does not exist
	b2_addState		: 1, ///< point was added in the update
	b2_persistState	: 2, ///< point persisted across the update
	b2_removeState	: 3  ///< point was removed in the update
};
goog.exportProperty(box2d.b2PointState, 'b2_nullState   ', box2d.b2PointState.b2_nullState   );
goog.exportProperty(box2d.b2PointState, 'b2_addState    ', box2d.b2PointState.b2_addState    );
goog.exportProperty(box2d.b2PointState, 'b2_persistState', box2d.b2PointState.b2_persistState);
goog.exportProperty(box2d.b2PointState, 'b2_removeState ', box2d.b2PointState.b2_removeState );

/** 
 * Compute the point states given two manifolds. The states 
 * pertain to the transition from manifold1 to manifold2. So 
 * state1 is either persist or remove while state2 is either add 
 * or persist. 
 * @export 
 * @return {void}
 * @param {Array.<box2d.b2PointState>} state1 
 * @param {Array.<box2d.b2PointState>} state2 
 * @param {box2d.b2Manifold} manifold1 
 * @param {box2d.b2Manifold} manifold2 
 */
box2d.b2GetPointStates = function (state1, state2, manifold1, manifold2)
{
	// Detect persists and removes.
	for (var i = 0, ict = manifold1.pointCount; i < ict; ++i)
	{
		var id = manifold1.points[i].id;
		var key = id.key;

		state1[i] = box2d.b2PointState.b2_removeState;

		for (var j = 0, jct = manifold2.pointCount; j < jct; ++j)
		{
			if (manifold2.points[j].id.key === key)
			{
				state1[i] = box2d.b2PointState.b2_persistState;
				break;
			}
		}
	}
	for (var ict = box2d.b2_maxManifoldPoints; i < ict; ++i)
	{
		state1[i] = box2d.b2PointState.b2_nullState;
	}

	// Detect persists and adds.
	for (var i = 0, ict = manifold2.pointCount; i < ict; ++i)
	{
		var id = manifold2.points[i].id;
		var key = id.key;

		state2[i] = box2d.b2PointState.b2_addState;

		for (var j = 0, jct = manifold1.pointCount; j < jct; ++j)
		{
			if (manifold1.points[j].id.key === key)
			{
				state2[i] = box2d.b2PointState.b2_persistState;
				break;
			}
		}
	}
	for (var ict = box2d.b2_maxManifoldPoints; i < ict; ++i)
	{
		state2[i] = box2d.b2PointState.b2_nullState;
	}
}

/** 
 * Used for computing contact manifolds. 
 * @export 
 * @constructor
 */
box2d.b2ClipVertex = function ()
{
	this.v = new box2d.b2Vec2();
	this.id = new box2d.b2ContactID();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ClipVertex.prototype.v = null;
/**
 * @export 
 * @type {box2d.b2ContactID}
 */
box2d.b2ClipVertex.prototype.id = null;

/**
 * @export 
 * @return {Array.<box2d.b2ClipVertex>} 
 * @param {number=} length 
 */
box2d.b2ClipVertex.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2ClipVertex(); });
}

/**
 * @export 
 * @return {box2d.b2ClipVertex}
 * @param {box2d.b2ClipVertex} other 
 */
box2d.b2ClipVertex.prototype.Copy = function (other)
{
	this.v.Copy(other.v);
	this.id.Copy(other.id);
	return this;
}

/** 
 * Ray-cast input data. The ray extends from p1 to p1 + 
 * maxFraction * (p2 - p1). 
 * @export 
 * @constructor
 */
box2d.b2RayCastInput = function ()
{
	this.p1 = new box2d.b2Vec2();
	this.p2 = new box2d.b2Vec2();
	this.maxFraction = 1;
}

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RayCastInput.prototype.p1 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RayCastInput.prototype.p2 = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RayCastInput.prototype.maxFraction = 1;

/**
 * @export 
 * @return {box2d.b2RayCastInput} 
 * @param {box2d.b2RayCastInput} o
 */
box2d.b2RayCastInput.prototype.Copy = function (o)
{
	this.p1.Copy(o.p1);
	this.p2.Copy(o.p2);
	this.maxFraction = o.maxFraction;
	return this;
}

/** 
 * Ray-cast output data. The ray hits at p1 + fraction * (p2 - 
 * p1), where p1 and p2 come from box2d.b2RayCastInput. 
 * @export 
 * @constructor
 */
box2d.b2RayCastOutput = function ()
{
	this.normal = new box2d.b2Vec2();
	this.fraction = 0;
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2RayCastOutput.prototype.normal = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2RayCastOutput.prototype.fraction = 0;

/**
 * @export 
 * @return {box2d.b2RayCastOutput} 
 * @param {box2d.b2RayCastOutput} o 
 */
box2d.b2RayCastOutput.prototype.Copy = function (o)
{
	this.normal.Copy(o.normal);
	this.fraction = o.fraction;
	return this;
}

/** 
 * An axis aligned bounding box. 
 * @export 
 * @constructor
 */
box2d.b2AABB = function ()
{
	this.lowerBound = new box2d.b2Vec2();
	this.upperBound = new box2d.b2Vec2();

	this.m_out_center = new box2d.b2Vec2();
	this.m_out_extent = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2AABB.prototype.lowerBound = null; ///< the lower vertex
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2AABB.prototype.upperBound = null; ///< the upper vertex

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2AABB.prototype.m_out_center = null; // access using GetCenter()
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2AABB.prototype.m_out_extent = null; // access using GetExtents()

/**
 * @export 
 * @return {box2d.b2AABB} 
 * @param {box2d.b2AABB} o 
 */
box2d.b2AABB.prototype.Copy = function (o)
{
	this.lowerBound.Copy(o.lowerBound);
	this.upperBound.Copy(o.upperBound);
	return this;
}

/** 
 * Verify that the bounds are sorted. 
 * @export 
 * @return {boolean}
 */
box2d.b2AABB.prototype.IsValid = function ()
{
	var d_x = this.upperBound.x - this.lowerBound.x;
	var d_y = this.upperBound.y - this.lowerBound.y;
	var valid = d_x >= 0 && d_y >= 0;
	valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
	return valid;
}

/** 
 * Get the center of the AABB. 
 * @export 
 * @return {box2d.b2Vec2}
 */
box2d.b2AABB.prototype.GetCenter = function ()
{
	return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center);
}

/** 
 * Get the extents of the AABB (half-widths). 
 * @export 
 * @return {box2d.b2Vec2} 
 */
box2d.b2AABB.prototype.GetExtents = function ()
{
	return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent);
}

/** 
 * Get the perimeter length 
 * @export 
 * @return {number} 
 */
box2d.b2AABB.prototype.GetPerimeter = function ()
{
	var wx = this.upperBound.x - this.lowerBound.x;
	var wy = this.upperBound.y - this.lowerBound.y;
	return 2 * (wx + wy);
}

/** 
 * Combine an AABB into this one. 
 * @export 
 * @return {box2d.b2AABB} 
 * @param {box2d.b2AABB} aabb
 */
box2d.b2AABB.prototype.Combine1 = function (aabb)
{
	this.lowerBound.x = box2d.b2Min(this.lowerBound.x, aabb.lowerBound.x);
	this.lowerBound.y = box2d.b2Min(this.lowerBound.y, aabb.lowerBound.y);
	this.upperBound.x = box2d.b2Max(this.upperBound.x, aabb.upperBound.x);
	this.upperBound.y = box2d.b2Max(this.upperBound.y, aabb.upperBound.y);
	return this;
}

/** 
 * Combine two AABBs into this one. 
 * @export 
 * @return {box2d.b2AABB} 
 * @param {box2d.b2AABB} aabb1
 * @param {box2d.b2AABB} aabb2
 */
box2d.b2AABB.prototype.Combine2 = function (aabb1, aabb2)
{
	this.lowerBound.x = box2d.b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);
	this.lowerBound.y = box2d.b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);
	this.upperBound.x = box2d.b2Max(aabb1.upperBound.x, aabb2.upperBound.x);
	this.upperBound.y = box2d.b2Max(aabb1.upperBound.y, aabb2.upperBound.y);
	return this;
}

/**
 * @export 
 * @return {box2d.b2AABB}
 * @param {box2d.b2AABB} aabb1
 * @param {box2d.b2AABB} aabb2
 * @param {box2d.b2AABB} out
 */
box2d.b2AABB.Combine = function (aabb1, aabb2, out)
{
	out.Combine2(aabb1, aabb2);
	return out;
}

/** 
 * Does this aabb contain the provided AABB. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2AABB} aabb 
 */
box2d.b2AABB.prototype.Contains = function (aabb)
{
	var result = true;
	result = result && this.lowerBound.x <= aabb.lowerBound.x;
	result = result && this.lowerBound.y <= aabb.lowerBound.y;
	result = result && aabb.upperBound.x <= this.upperBound.x;
	result = result && aabb.upperBound.y <= this.upperBound.y;
	return result;
}

/** 
 * From Real-time Collision Detection, p179. 
 * @export 
 * @return {boolean}
 * @param {box2d.b2RayCastOutput} output
 * @param {box2d.b2RayCastInput} input
 */
box2d.b2AABB.prototype.RayCast = function (output, input)
{
	var tmin = (-box2d.b2_maxFloat);
	var tmax = box2d.b2_maxFloat;

	var p_x = input.p1.x;
	var p_y = input.p1.y;
	var d_x = input.p2.x - input.p1.x;
	var d_y = input.p2.y - input.p1.y;
	var absD_x = box2d.b2Abs(d_x);
	var absD_y = box2d.b2Abs(d_y);

	var normal = output.normal;

	if (absD_x < box2d.b2_epsilon)
	{
		// Parallel.
		if (p_x < this.lowerBound.x || this.upperBound.x < p_x)
		{
			return false;
		}
	}
	else
	{
		var inv_d = 1 / d_x;
		var t1 = (this.lowerBound.x - p_x) * inv_d;
		var t2 = (this.upperBound.x - p_x) * inv_d;

		// Sign of the normal vector.
		var s = (-1);

		if (t1 > t2)
		{
			var t3 = t1;
			t1 = t2;
			t2 = t3;
			s = 1;
		}

		// Push the min up
		if (t1 > tmin)
		{
			normal.x = s;
			normal.y = 0;
			tmin = t1;
		}

		// Pull the max down
		tmax = box2d.b2Min(tmax, t2);

		if (tmin > tmax)
		{
			return false;
		}
	}

	if (absD_y < box2d.b2_epsilon)
	{
		// Parallel.
		if (p_y < this.lowerBound.y || this.upperBound.y < p_y)
		{
			return false;
		}
	}
	else
	{
		var inv_d = 1 / d_y;
		var t1 = (this.lowerBound.y - p_y) * inv_d;
		var t2 = (this.upperBound.y - p_y) * inv_d;

		// Sign of the normal vector.
		var s = (-1);

		if (t1 > t2)
		{
			var t3 = t1;
			t1 = t2;
			t2 = t3;
			s = 1;
		}

		// Push the min up
		if (t1 > tmin)
		{
			normal.x = 0;
			normal.y = s;
			tmin = t1;
		}

		// Pull the max down
		tmax = box2d.b2Min(tmax, t2);

		if (tmin > tmax)
		{
			return false;
		}
	}

	// Does the ray start inside the box?
	// Does the ray intersect beyond the max fraction?
	if (tmin < 0 || input.maxFraction < tmin)
	{
		return false;
	}

	// Intersection.
	output.fraction = tmin;

	return true;
}

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2AABB} other 
 */
box2d.b2AABB.prototype.TestOverlap = function (other)
{
	var d1_x = other.lowerBound.x - this.upperBound.x;
	var d1_y = other.lowerBound.y - this.upperBound.y;
	var d2_x = this.lowerBound.x - other.upperBound.x;
	var d2_y = this.lowerBound.y - other.upperBound.y;

	if (d1_x > 0 || d1_y > 0)
		return false;

	if (d2_x > 0 || d2_y > 0)
		return false;

	return true;
}

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2AABB} a
 * @param {box2d.b2AABB} b 
 */
box2d.b2TestOverlapAABB = function (a, b)
{
	var d1_x = b.lowerBound.x - a.upperBound.x;
	var d1_y = b.lowerBound.y - a.upperBound.y;
	var d2_x = a.lowerBound.x - b.upperBound.x;
	var d2_y = a.lowerBound.y - b.upperBound.y;

	if (d1_x > 0 || d1_y > 0)
		return false;

	if (d2_x > 0 || d2_y > 0)
		return false;

	return true;
}

/** 
 * Clipping for contact manifolds. 
 * Sutherland-Hodgman clipping. 
 * @export 
 * @return {number} 
 * @param {Array.<box2d.b2ClipVertex>} vOut 
 * @param {Array.<box2d.b2ClipVertex>} vIn
 * @param {box2d.b2Vec2} normal 
 * @param {number} offset 
 * @param {number} vertexIndexA 
 */
box2d.b2ClipSegmentToLine = function (vOut, vIn, normal, offset, vertexIndexA)
{
	// Start with no output points
	var numOut = 0;

	var vIn0 = vIn[0];
	var vIn1 = vIn[1];

	// Calculate the distance of end points to the line
	var distance0 = box2d.b2DotVV(normal, vIn0.v) - offset;
	var distance1 = box2d.b2DotVV(normal, vIn1.v) - offset;

	// If the points are behind the plane
	if (distance0 <= 0) vOut[numOut++].Copy(vIn0);
	if (distance1 <= 0) vOut[numOut++].Copy(vIn1);

	// If the points are on different sides of the plane
	if (distance0 * distance1 < 0)
	{
		// Find intersection point of edge and plane
		var interp = distance0 / (distance0 - distance1);
		var v = vOut[numOut].v;
		v.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);
		v.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);

		// VertexA is hitting edgeB.
		var id = vOut[numOut].id;
		id.cf.indexA = vertexIndexA;
		id.cf.indexB = vIn0.id.cf.indexB;
		id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
		id.cf.typeB = box2d.b2ContactFeatureType.e_face;
		++numOut;
	}

	return numOut;
}

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Shape} shapeA 
 * @param {box2d.b2Shape} shapeB 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2TestOverlapShape = function (shapeA, indexA, shapeB, indexB, xfA, xfB)
{
	var input = box2d.b2TestOverlapShape.s_input.Reset();
	input.proxyA.SetShape(shapeA, indexA);
	input.proxyB.SetShape(shapeB, indexB);
	input.transformA.Copy(xfA);
	input.transformB.Copy(xfB);
	input.useRadii = true;

	var simplexCache = box2d.b2TestOverlapShape.s_simplexCache.Reset();
	simplexCache.count = 0;

	var output = box2d.b2TestOverlapShape.s_output.Reset();

	box2d.b2Distance(output, simplexCache, input);

	return output.distance < 10 * box2d.b2_epsilon;
}
box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput();
box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache();
box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Timer');

goog.require('box2d.b2Settings');

/** 
 * Timer for profiling. This has platform specific code and may 
 * not work on every platform. 
 * @export 
 * @constructor
 */
box2d.b2Timer = function ()
{
	this.m_start = new Date().getTime();
}

/**
 * @export 
 * @type {number} 
 */
box2d.b2Timer.prototype.m_start = 0;

/**
 * @export 
 * @return {box2d.b2Timer}
 */
box2d.b2Timer.prototype.Reset = function ()
{
	this.m_start = new Date().getTime();
	return this;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2Timer.prototype.GetMilliseconds = function ()
{
	return new Date().getTime() - this.m_start;
}

/**
 * @export 
 * @constructor
 */
box2d.b2Counter = function ()
{
}

/**
 * @export 
 * @type {number} 
 */
box2d.b2Counter.prototype.m_count = 0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Counter.prototype.m_min_count = 0;
/**
 * @export 
 * @type {number} 
 */
box2d.b2Counter.prototype.m_max_count = 0;

/**
 * @export 
 * @return {number} 
 */
box2d.b2Counter.prototype.GetCount = function ()
{
	return this.m_count;
}

/**
 * @export 
 * @return {number} 
 */
box2d.b2Counter.prototype.GetMinCount = function ()
{
	return this.m_min_count;
}

/** 
 * @export 
 * @return {number} 
 */
box2d.b2Counter.prototype.GetMaxCount = function ()
{
	return this.m_max_count;
}

/** 
 * @export 
 * @return {number} 
 */
box2d.b2Counter.prototype.ResetCount = function ()
{
	var count = this.m_count;
	this.m_count = 0;
	return count;
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Counter.prototype.ResetMinCount = function ()
{
	this.m_min_count = 0;
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Counter.prototype.ResetMaxCount = function ()
{
	this.m_max_count = 0;
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Counter.prototype.Increment = function ()
{
	this.m_count++;

	if (this.m_max_count < this.m_count)
	{
		this.m_max_count = this.m_count;
	}
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Counter.prototype.Decrement = function ()
{
	this.m_count--;

	if (this.m_min_count > this.m_count)
	{
		this.m_min_count = this.m_count;
	}
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2TimeOfImpact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Distance');
goog.require('box2d.b2Math');
goog.require('box2d.b2Timer');

/**
 * @export
 * @type {number}
 */
box2d.b2_toiTime = 0.0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiMaxTime = 0.0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiCalls = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiIters = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiMaxIters = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiRootIters = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2_toiMaxRootIters = 0;

/** 
 * Input parameters for b2TimeOfImpact 
 * @export
 * @constructor
 */
box2d.b2TOIInput = function ()
{
	this.proxyA = new box2d.b2DistanceProxy();
	this.proxyB = new box2d.b2DistanceProxy();
	this.sweepA = new box2d.b2Sweep();
	this.sweepB = new box2d.b2Sweep();
};

/**
 * @export
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2TOIInput.prototype.proxyA = null;
/**
 * @export
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2TOIInput.prototype.proxyB = null;
/**
 * @export
 * @type {box2d.b2Sweep}
 */
box2d.b2TOIInput.prototype.sweepA = null;
/**
 * @export
 * @type {box2d.b2Sweep}
 */
box2d.b2TOIInput.prototype.sweepB = null;
/**
 * @export
 * @type {number}
 */
box2d.b2TOIInput.prototype.tMax = 0; // defines sweep interval [0, tMax]

/**
 * @export 
 * @enum
 */
box2d.b2TOIOutputState = 
{
	e_unknown		: 0,
	e_failed		: 1,
	e_overlapped	: 2,
	e_touching		: 3,
	e_separated		: 4
};
goog.exportProperty(box2d.b2TOIOutputState, 'e_unknown'   , box2d.b2TOIOutputState.e_unknown   );
goog.exportProperty(box2d.b2TOIOutputState, 'e_failed'    , box2d.b2TOIOutputState.e_failed    );
goog.exportProperty(box2d.b2TOIOutputState, 'e_overlapped', box2d.b2TOIOutputState.e_overlapped);
goog.exportProperty(box2d.b2TOIOutputState, 'e_touching'  , box2d.b2TOIOutputState.e_touching  );
goog.exportProperty(box2d.b2TOIOutputState, 'e_separated' , box2d.b2TOIOutputState.e_separated );

/** 
 * Output parameters for b2TimeOfImpact. 
 * @export
 * @constructor
 */
box2d.b2TOIOutput = function ()
{
};

/**
 * @export
 * @type {box2d.b2TOIOutputState}
 */
box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown;
/**
 * @export
 * @type {number}
 */
box2d.b2TOIOutput.prototype.t = 0;

/**
 * @export 
 * @enum
 */
box2d.b2SeparationFunctionType = 
{
	e_unknown	: -1,
	e_points	: 0,
	e_faceA		: 1,
	e_faceB		: 2
};
goog.exportProperty(box2d.b2SeparationFunctionType, 'e_unknown', box2d.b2SeparationFunctionType.e_unknown);
goog.exportProperty(box2d.b2SeparationFunctionType, 'e_points' , box2d.b2SeparationFunctionType.e_points );
goog.exportProperty(box2d.b2SeparationFunctionType, 'e_faceA'  , box2d.b2SeparationFunctionType.e_faceA  );
goog.exportProperty(box2d.b2SeparationFunctionType, 'e_faceB'  , box2d.b2SeparationFunctionType.e_faceB  );

/**
 * @export
 * @constructor
 */
box2d.b2SeparationFunction = function ()
{
	this.m_sweepA = new box2d.b2Sweep();
	this.m_sweepB = new box2d.b2Sweep();
	this.m_localPoint = new box2d.b2Vec2();
	this.m_axis = new box2d.b2Vec2();
};

/**
 * @export
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2SeparationFunction.prototype.m_proxyA = null;
/**
 * @export
 * @type {box2d.b2DistanceProxy}
 */
box2d.b2SeparationFunction.prototype.m_proxyB = null;
/**
 * @export
 * @type {box2d.b2Sweep}
 */
box2d.b2SeparationFunction.prototype.m_sweepA = null;
/**
 * @export
 * @type {box2d.b2Sweep}
 */
box2d.b2SeparationFunction.prototype.m_sweepB = null;
/**
 * @export
 * @type {box2d.b2SeparationFunctionType}
 */
box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown;
/**
 * @export
 * @type {box2d.b2Vec2}
 */
box2d.b2SeparationFunction.prototype.m_localPoint = null;
/**
 * @export
 * @type {box2d.b2Vec2}
 */
box2d.b2SeparationFunction.prototype.m_axis = null;

/** 
 * TODO_ERIN might not need to return the separation 
 * @export
 * @return {number}
 * @param {box2d.b2SimplexCache} cache
 * @param {box2d.b2DistanceProxy} proxyA
 * @param {box2d.b2Sweep} sweepA
 * @param {box2d.b2DistanceProxy} proxyB
 * @param {box2d.b2Sweep} sweepB
 * @param {number} t1
 */
box2d.b2SeparationFunction.prototype.Initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1)
{
	this.m_proxyA = proxyA;
	this.m_proxyB = proxyB;
	/** @type {number} */ var count = cache.count;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 < count && count < 3); }

	this.m_sweepA.Copy(sweepA);
	this.m_sweepB.Copy(sweepB);

	/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;
	this.m_sweepA.GetTransform(xfA, t1);
	this.m_sweepB.GetTransform(xfB, t1);

	if (count === 1)
	{
		this.m_type = box2d.b2SeparationFunctionType.e_points;
		/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
		/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
		/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);
		/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);
		box2d.b2SubVV(pointB, pointA, this.m_axis);
		/** @type {number} */ var s = this.m_axis.Normalize();
		return s;
	}
	else if (cache.indexA[0] === cache.indexA[1])
	{
		// Two points on B and one on A.
		this.m_type = box2d.b2SeparationFunctionType.e_faceB;
		/** @type {box2d.b2Vec2} */ var localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
		/** @type {box2d.b2Vec2} */ var localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);

		box2d.b2CrossVOne(box2d.b2SubVV(localPointB2, localPointB1, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
		/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);

		box2d.b2MidVV(localPointB1, localPointB2, this.m_localPoint);
		/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);

		/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
		/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);

		/** type {number} */ var s = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal);
		if (s < 0)
		{
			this.m_axis.SelfNeg();
			s = -s;
		}
		return s;
	}
	else
	{
		// Two points on A and one or two points on B.
		this.m_type = box2d.b2SeparationFunctionType.e_faceA;
		/** @type {box2d.b2Vec2} */ var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
		/** @type {box2d.b2Vec2} */ var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);

		box2d.b2CrossVOne(box2d.b2SubVV(localPointA2, localPointA1, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
		/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);

		box2d.b2MidVV(localPointA1, localPointA2, this.m_localPoint);
		/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);

		/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
		/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);

		/** type {number} */ var s = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal);
		if (s < 0)
		{
			this.m_axis.SelfNeg();
			s = -s;
		}
		return s;
	}
}

/**
 * @export
 * @return {number}
 * @param {Array.<number>} indexA
 * @param {Array.<number>} indexB
 * @param {number} t
 */
box2d.b2SeparationFunction.prototype.FindMinSeparation = function (indexA, indexB, t)
{
	/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;
	this.m_sweepA.GetTransform(xfA, t);
	this.m_sweepB.GetTransform(xfB, t);

	switch (this.m_type)
	{
	case box2d.b2SeparationFunctionType.e_points:
		{
			/** @type {box2d.b2Vec2} */ var axisA = box2d.b2MulTRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA);
			/** @type {box2d.b2Vec2} */ var axisB = box2d.b2MulTRV(xfB.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);

			indexA[0] = this.m_proxyA.GetSupport(axisA);
			indexB[0] = this.m_proxyB.GetSupport(axisB);

			/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA[0]);
			/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB[0]);

			/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);
			/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);

			/** @type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.m_axis)
			return separation;
		}

	case box2d.b2SeparationFunctionType.e_faceA:
		{
			/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
			/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);

			/** type {box2d.b2Vec2} */ var axisB = box2d.b2MulTRV(xfB.q, box2d.b2NegV(normal, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);

			indexA[0] = -1;
			indexB[0] = this.m_proxyB.GetSupport(axisB);

			/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB[0]);
			/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);

			/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal)
			return separation;
		}

	case box2d.b2SeparationFunctionType.e_faceB:
		{
			/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
			/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);

			/** type {box2d.b2Vec2} */ var axisA = box2d.b2MulTRV(xfA.q, box2d.b2NegV(normal, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA);

			indexB[0] = -1;
			indexA[0] = this.m_proxyA.GetSupport(axisA);

			/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA[0]);
			/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);

			/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal)
			return separation;
		}

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		indexA[0] = -1;
		indexB[0] = -1;
		return 0;
	}
}

/**
 * @export
 * @return {number}
 * @param {number} indexA
 * @param {number} indexB
 * @param {number} t
 */
box2d.b2SeparationFunction.prototype.Evaluate = function (indexA, indexB, t)
{
	/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;
	this.m_sweepA.GetTransform(xfA, t);
	this.m_sweepB.GetTransform(xfB, t);

	switch (this.m_type)
	{
	case box2d.b2SeparationFunctionType.e_points:
		{
			/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA);
			/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB);

			/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);
			/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);
			/** @type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.m_axis)

			return separation;
		}

	case box2d.b2SeparationFunctionType.e_faceA:
		{
			/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
			/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);

			/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB);
			/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);

			/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal)
			return separation;
		}

	case box2d.b2SeparationFunctionType.e_faceB:
		{
			/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
			/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);

			/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA);
			/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);

			/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal)
			return separation;
		}

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return 0;
	}
}

/**
 * Compute the upper bound on time before two shapes penetrate. 
 * Time is represented as a fraction between [0,tMax]. This uses
 * a swept separating axis and may miss some intermediate, 
 * non-tunneling collision. If you change the time interval, you 
 * should call this function again. 
 * Note: use box2d.b2Distance to compute the contact point and 
 * normal at the time of impact. 
 * @export
 * @return {void}
 * @param {box2d.b2TOIOutput} output
 * @param {box2d.b2TOIInput} input
 */
box2d.b2TimeOfImpact = function (output, input)
{
	var timer = box2d.b2TimeOfImpact.s_timer.Reset();

	++box2d.b2_toiCalls;

	output.state = box2d.b2TOIOutputState.e_unknown;
	output.t = input.tMax;

	/** @type {box2d.b2DistanceProxy} */ var proxyA = input.proxyA;
	/** @type {box2d.b2DistanceProxy} */ var proxyB = input.proxyB;

	/** @type {box2d.b2Sweep} */ var sweepA = box2d.b2TimeOfImpact.s_sweepA.Copy(input.sweepA);
	/** @type {box2d.b2Sweep} */ var sweepB = box2d.b2TimeOfImpact.s_sweepB.Copy(input.sweepB);

	// Large rotations can make the root finder fail, so we normalize the
	// sweep angles.
	sweepA.Normalize();
	sweepB.Normalize();

	/** @type {number} */ var tMax = input.tMax;

	/** @type {number} */ var totalRadius = proxyA.m_radius + proxyB.m_radius;
	/** @type {number} */ var target = box2d.b2Max(box2d.b2_linearSlop, totalRadius - 3 * box2d.b2_linearSlop);
	/** @type {number} */ var tolerance = 0.25 * box2d.b2_linearSlop;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(target > tolerance); }

	/** @type {number} */ var t1 = 0;
	/** @type {number} */ var k_maxIterations = 20; // TODO_ERIN b2Settings
	/** @type {number} */ var iter = 0;

	// Prepare input for distance query.
	/** @type {box2d.b2SimplexCache} */ var cache = box2d.b2TimeOfImpact.s_cache;
	cache.count = 0;
	/** @type {box2d.b2DistanceInput} */ var distanceInput = box2d.b2TimeOfImpact.s_distanceInput;
	distanceInput.proxyA = input.proxyA;
	distanceInput.proxyB = input.proxyB;
	distanceInput.useRadii = false;

	// The outer loop progressively attempts to compute new separating axes.
	// This loop terminates when an axis is repeated (no progress is made).
	for (;;)
	{
		/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;
		/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;
		sweepA.GetTransform(xfA, t1);
		sweepB.GetTransform(xfB, t1);

		// Get the distance between shapes. We can also use the results
		// to get a separating axis.
		distanceInput.transformA.Copy(xfA);
		distanceInput.transformB.Copy(xfB);
		/** @type {box2d.b2DistanceOutput} */ var distanceOutput = box2d.b2TimeOfImpact.s_distanceOutput;
		box2d.b2Distance(distanceOutput, cache, distanceInput);

		// If the shapes are overlapped, we give up on continuous collision.
		if (distanceOutput.distance <= 0)
		{
			// Failure!
			output.state = box2d.b2TOIOutputState.e_overlapped;
			output.t = 0;
			break;
		}

		if (distanceOutput.distance < target + tolerance)
		{
			// Victory!
			output.state = box2d.b2TOIOutputState.e_touching;
			output.t = t1;
			break;
		}

		// Initialize the separating axis.
		/** @type {box2d.b2SeparationFunction} */ var fcn = box2d.b2TimeOfImpact.s_fcn;
		fcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
/*
#if 0
		// Dump the curve seen by the root finder
		{
			const int32 N = 100;
			float32 dx = 1.0f / N;
			float32 xs[N+1];
			float32 fs[N+1];

			float32 x = 0.0f;

			for (int32 i = 0; i <= N; ++i)
			{
				sweepA.GetTransform(&xfA, x);
				sweepB.GetTransform(&xfB, x);
				float32 f = fcn.Evaluate(xfA, xfB) - target;

				printf("%g %g\n", x, f);

				xs[i] = x;
				fs[i] = f;

				x += dx;
			}
		}
#endif
*/

		// Compute the TOI on the separating axis. We do this by successively
		// resolving the deepest point. This loop is bounded by the number of vertices.
		/** @type {boolean} */ var done = false;
		/** @type {number} */ var t2 = tMax;
		/** @type {number} */ var pushBackIter = 0;
		for (;;)
		{
			// Find the deepest point at t2. Store the witness point indices.
			/** @type Array.<number>} */ var indexA = box2d.b2TimeOfImpact.s_indexA;
			/** @type Array.<number>} */ var indexB = box2d.b2TimeOfImpact.s_indexB;
			/** @type {number} */ var s2 = fcn.FindMinSeparation(indexA, indexB, t2);

			// Is the final configuration separated?
			if (s2 > (target + tolerance))
			{
				// Victory!
				output.state = box2d.b2TOIOutputState.e_separated;
				output.t = tMax;
				done = true;
				break;
			}

			// Has the separation reached tolerance?
			if (s2 > (target - tolerance))
			{
				// Advance the sweeps
				t1 = t2;
				break;
			}

			// Compute the initial separation of the witness points.
			/** @type {number} */ var s1 = fcn.Evaluate(indexA[0], indexB[0], t1);

			// Check for initial overlap. This might happen if the root finder
			// runs out of iterations.
			if (s1 < (target - tolerance))
			{
				output.state = box2d.b2TOIOutputState.e_failed;
				output.t = t1;
				done = true;
				break;
			}

			// Check for touching
			if (s1 <= (target + tolerance))
			{
				// Victory! t1 should hold the TOI (could be 0.0).
				output.state = box2d.b2TOIOutputState.e_touching;
				output.t = t1;
				done = true;
				break;
			}

			// Compute 1D root of: f(x) - target = 0
			/** @type {number} */ var rootIterCount = 0;
			/** @type {number} */ var a1 = t1;
			/** @type {number} */ var a2 = t2;
			for (;;)
			{
				// Use a mix of the secant rule and bisection.
				/** @type {number} */ var t = 0;
				if (rootIterCount & 1)
				{
					// Secant rule to improve convergence.
					t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
				}
				else
				{
					// Bisection to guarantee progress.
					t = 0.5 * (a1 + a2);
				}

				++rootIterCount;
				++box2d.b2_toiRootIters;

				/** @type {number} */ var s = fcn.Evaluate(indexA[0], indexB[0], t);

				if (box2d.b2Abs(s - target) < tolerance)
				{
					// t2 holds a tentative value for t1
					t2 = t;
					break;
				}

				// Ensure we continue to bracket the root.
				if (s > target)
				{
					a1 = t;
					s1 = s;
				}
				else
				{
					a2 = t;
					s2 = s;
				}

				if (rootIterCount === 50)
				{
					break;
				}
			}

			box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, rootIterCount);

			++pushBackIter;

			if (pushBackIter === box2d.b2_maxPolygonVertices)
			{
				break;
			}
		}

		++iter;
		++box2d.b2_toiIters;

		if (done)
		{
			break;
		}

		if (iter === k_maxIterations)
		{
			// Root finder got stuck. Semi-victory.
			output.state = box2d.b2TOIOutputState.e_failed;
			output.t = t1;
			break;
		}
	}

	box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, iter);

	var time = timer.GetMilliseconds();
	box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, time);
	box2d.b2_toiTime += time;
}
box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer();
box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache();
box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput();
box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput();
box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform();
box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform();
box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction();
box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep();
box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep();
box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2();
box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2();
box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2();
box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2();
box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Contact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Collision');
goog.require('box2d.b2TimeOfImpact');

/**
 * Friction mixing law. The idea is to allow either fixture to
 * drive the restitution to zero. For example, anything slides
 * on ice.
 * @export
 * @return {number}
 * @param {number} friction1
 * @param {number} friction2
 */
box2d.b2MixFriction = function (friction1, friction2)
{
	return box2d.b2Sqrt(friction1 * friction2);
}

/**
 * Restitution mixing law. The idea is allow for anything to
 * bounce off an inelastic surface. For example, a superball
 * bounces on anything.
 * @export
 * @return {number}
 * @param {number} restitution1
 * @param {number} restitution2
 */
box2d.b2MixRestitution = function (restitution1, restitution2)
{
	return restitution1 > restitution2 ? restitution1 : restitution2;
}

/**
 * A contact edge is used to connect bodies and contacts
 * together in a contact graph where each body is a node and
 * each contact is an edge. A contact edge belongs to a doubly
 * linked list maintained in each attached body. Each contact
 * has two contact nodes, one for each attached body.
 * @export
 * @constructor
 */
box2d.b2ContactEdge = function ()
{
};

/**
 * @export
 * @type {box2d.b2Body}
 */
box2d.b2ContactEdge.prototype.other = null; ///< provides quick access to the other body attached.
/**
 * @export
 * @type {box2d.b2Contact}
 */
box2d.b2ContactEdge.prototype.contact = null; ///< the contact
/**
 * @export
 * @type {box2d.b2ContactEdge}
 */
box2d.b2ContactEdge.prototype.prev = null; ///< the previous contact edge in the body's contact list
/**
 * @export
 * @type {box2d.b2ContactEdge}
 */
box2d.b2ContactEdge.prototype.next = null; ///< the next contact edge in the body's contact list

/**
 * Flags stored in m_flags
 * @enum
 */
box2d.b2ContactFlag = 
{
	e_none			: 0,
	e_islandFlag	: 0x0001, /// Used when crawling contact graph when forming islands.
	e_touchingFlag	: 0x0002, /// Set when the shapes are touching.
	e_enabledFlag	: 0x0004, /// This contact can be disabled (by user)
	e_filterFlag	: 0x0008, /// This contact needs filtering because a fixture filter was changed.
	e_bulletHitFlag	: 0x0010, /// This bullet contact had a TOI event
	e_toiFlag		: 0x0020  /// This contact has a valid TOI in m_toi
};
goog.exportProperty(box2d.b2ContactFlag, 'e_none'         , box2d.b2ContactFlag.e_none         );
goog.exportProperty(box2d.b2ContactFlag, 'e_islandFlag'   , box2d.b2ContactFlag.e_islandFlag   );
goog.exportProperty(box2d.b2ContactFlag, 'e_touchingFlag' , box2d.b2ContactFlag.e_touchingFlag );
goog.exportProperty(box2d.b2ContactFlag, 'e_enabledFlag'  , box2d.b2ContactFlag.e_enabledFlag  );
goog.exportProperty(box2d.b2ContactFlag, 'e_filterFlag'   , box2d.b2ContactFlag.e_filterFlag   );
goog.exportProperty(box2d.b2ContactFlag, 'e_bulletHitFlag', box2d.b2ContactFlag.e_bulletHitFlag);
goog.exportProperty(box2d.b2ContactFlag, 'e_toiFlag'      , box2d.b2ContactFlag.e_toiFlag      );

/**
 * The class manages contact between two shapes. A contact
 * exists for each overlapping AABB in the broad-phase (except
 * if filtered). Therefore a contact object may exist that has
 * no contact points.
 * @export
 * @constructor
 */
box2d.b2Contact = function ()
{
	this.m_nodeA = new box2d.b2ContactEdge();
	this.m_nodeB = new box2d.b2ContactEdge();
	this.m_manifold = new box2d.b2Manifold();
	this.m_oldManifold = new box2d.b2Manifold();
}

/**
 * @export
 * @type {box2d.b2ContactFlag}
 */
box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none;

/**
 * World pool and list pointers.
 * @export
 * @type {box2d.b2Contact}
 */
box2d.b2Contact.prototype.m_prev = null;
/**
 * @export
 * @type {box2d.b2Contact}
 */
box2d.b2Contact.prototype.m_next = null;

/**
 * Nodes for connecting bodies.
 * @export
 * @type {box2d.b2ContactEdge}
 */
box2d.b2Contact.prototype.m_nodeA = null;
/**
 * @export
 * @type {box2d.b2ContactEdge}
 */
box2d.b2Contact.prototype.m_nodeB = null;

/**
 * @export
 * @type {box2d.b2Fixture}
 */
box2d.b2Contact.prototype.m_fixtureA = null;
/**
 * @export
 * @type {box2d.b2Fixture}
 */
box2d.b2Contact.prototype.m_fixtureB = null;

/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_indexA = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_indexB = 0;

/**
 * @export
 * @type {box2d.b2Manifold}
 */
box2d.b2Contact.prototype.m_manifold = null;

/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_toiCount = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_toi = 0;

/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_friction = 0;
/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_restitution = 0;

/**
 * @export
 * @type {number}
 */
box2d.b2Contact.prototype.m_tangentSpeed = 0;

/**
 * @export
 * @type {box2d.b2Manifold}
 */
box2d.b2Contact.prototype.m_oldManifold = null;

/**
 * Get the contact manifold. Do not modify the manifold unless
 * you understand the internals of Box2D.
 * @export
 * @return {box2d.b2Manifold}
 */
box2d.b2Contact.prototype.GetManifold = function ()
{
	return this.m_manifold;
}

/**
 * Get the world manifold.
 * @export
 * @return {void}
 * @param {box2d.b2WorldManifold} worldManifold
 */
box2d.b2Contact.prototype.GetWorldManifold = function (worldManifold)
{
	var bodyA = this.m_fixtureA.GetBody();
	var bodyB = this.m_fixtureB.GetBody();
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
}

/**
 * Is this contact touching?
 * @export
 * @return {boolean}
 */
box2d.b2Contact.prototype.IsTouching = function ()
{
	return (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag;
}

/**
 * Enable/disable this contact. This can be used inside the
 * pre-solve contact listener. The contact is only disabled for
 * the current time step (or sub-step in continuous collisions).
 * @export
 * @return {void}
 * @param {boolean} flag
 */
box2d.b2Contact.prototype.SetEnabled = function (flag)
{
	if (flag)
	{
		this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
	}
	else
	{
		this.m_flags &= ~box2d.b2ContactFlag.e_enabledFlag;
	}
}

/**
 * Has this contact been disabled?
 * @export
 * @return {boolean}
 */
box2d.b2Contact.prototype.IsEnabled = function ()
{
	return (this.m_flags & box2d.b2ContactFlag.e_enabledFlag) === box2d.b2ContactFlag.e_enabledFlag;
}

/**
 * Get the next contact in the world's contact list.
 * @export
 * @return {box2d.b2Contact}
 */
box2d.b2Contact.prototype.GetNext = function ()
{
	return this.m_next;
}

/**
 * Get fixture A in this contact.
 * @export
 * @return {box2d.b2Fixture}
 */
box2d.b2Contact.prototype.GetFixtureA = function ()
{
	return this.m_fixtureA;
}

/**
 * @export
 * @return {number}
 */
box2d.b2Contact.prototype.GetChildIndexA = function ()
{
	return this.m_indexA;
}

/**
 * Get fixture B in this contact.
 * @export
 * @return {box2d.b2Fixture}
 */
box2d.b2Contact.prototype.GetFixtureB = function ()
{
	return this.m_fixtureB;
}

/**
 * @export
 * @return {number}
 */
box2d.b2Contact.prototype.GetChildIndexB = function ()
{
	return this.m_indexB;
}

/**
 * Evaluate this contact with your own manifold and transforms.
 * @export
 * @return {void}
 * @param {box2d.b2Manifold} manifold
 * @param {box2d.b2Transform} xfA
 * @param {box2d.b2Transform} xfB
 */
box2d.b2Contact.prototype.Evaluate = function (manifold, xfA, xfB)
{
}

/**
 * Flag this contact for filtering. Filtering will occur the
 * next time step.
 * @export
 * @return {void}
 */
box2d.b2Contact.prototype.FlagForFiltering = function ()
{
	this.m_flags |= box2d.b2ContactFlag.e_filterFlag;
}

/**
 * Override the default friction mixture. You can call this in
 * box2d.b2ContactListener::PreSolve.
 * This value persists until set or reset.
 * @export
 * @return {void}
 * @param {number} friction
 */
box2d.b2Contact.prototype.SetFriction = function (friction)
{
	this.m_friction = friction;
}

/**
 * Get the friction.
 * @export
 * @return {number}
 */
box2d.b2Contact.prototype.GetFriction = function ()
{
	return this.m_friction;
}

/**
 * Reset the friction mixture to the default value.
 * @export
 * @return {void}
 */
box2d.b2Contact.prototype.ResetFriction = function ()
{
	this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
}

/**
 * Override the default restitution mixture. You can call this
 * in box2d.b2ContactListener::PreSolve.
 * The value persists until you set or reset.
 * @export
 * @return {void}
 * @param {number} restitution
 */
box2d.b2Contact.prototype.SetRestitution = function (restitution)
{
	this.m_restitution = restitution;
}

/**
 * Get the restitution.
 * @export
 * @return {number}
 */
box2d.b2Contact.prototype.GetRestitution = function ()
{
	return this.m_restitution;
}

/**
 * Reset the restitution to the default value.
 * @export
 * @return {void}
 */
box2d.b2Contact.prototype.ResetRestitution = function ()
{
	this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
}

/**
 * Set the desired tangent speed for a conveyor belt behavior.
 * In meters per second.
 * @export
 * @return {void}
 * @param {number} speed
 */
box2d.b2Contact.prototype.SetTangentSpeed = function (speed)
{
	this.m_tangentSpeed = speed;
}

/**
 * Get the desired tangent speed. In meters per second.
 * @export
 * @return {number}
 */
box2d.b2Contact.prototype.GetTangentSpeed = function ()
{
	return this.m_tangentSpeed;
}

/**
 * @export
 * @return {void}
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2Contact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	this.m_flags = box2d.b2ContactFlag.e_enabledFlag;

	this.m_fixtureA = fixtureA;
	this.m_fixtureB = fixtureB;

	this.m_indexA = indexA;
	this.m_indexB = indexB;

	this.m_manifold.pointCount = 0;

	this.m_prev = null;
	this.m_next = null;

	this.m_nodeA.contact = null;
	this.m_nodeA.prev = null;
	this.m_nodeA.next = null;
	this.m_nodeA.other = null;

	this.m_nodeB.contact = null;
	this.m_nodeB.prev = null;
	this.m_nodeB.next = null;
	this.m_nodeB.other = null;

	this.m_toiCount = 0;

	this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
	this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
}

/**
 * Update the contact manifold and touching status.
 * Note: do not assume the fixture AABBs are overlapping or are
 * valid.
 * @export
 * @return {void}
 * @param {box2d.b2ContactListener} listener
 */
box2d.b2Contact.prototype.Update = function (listener)
{
	var tManifold = this.m_oldManifold;
	this.m_oldManifold = this.m_manifold;
	this.m_manifold = tManifold;

	// Re-enable this contact.
	this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;

	var touching = false;
	var wasTouching = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag;

	var sensorA = this.m_fixtureA.IsSensor();
	var sensorB = this.m_fixtureB.IsSensor();
	var sensor = sensorA || sensorB;

	var bodyA = this.m_fixtureA.GetBody();
	var bodyB = this.m_fixtureB.GetBody();
	var xfA = bodyA.GetTransform();
	var xfB = bodyB.GetTransform();

//	var aabbOverlap = box2d.b2TestOverlapAABB(this.m_fixtureA.GetAABB(0), this.m_fixtureB.GetAABB(0));

	// Is this contact a sensor?
	if (sensor)
	{
//		if (aabbOverlap)
//		{
			var shapeA = this.m_fixtureA.GetShape();
			var shapeB = this.m_fixtureB.GetShape();
			touching = box2d.b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
//		}

		// Sensors don't generate manifolds.
		this.m_manifold.pointCount = 0;
	}
	else
	{
//		if (aabbOverlap)
//		{
			this.Evaluate(this.m_manifold, xfA, xfB);
			touching = this.m_manifold.pointCount > 0;

			// Match old contact ids to new contact ids and copy the
			// stored impulses to warm start the solver.
			for (var i = 0; i < this.m_manifold.pointCount; ++i)
			{
				var mp2 = this.m_manifold.points[i];
				mp2.normalImpulse = 0;
				mp2.tangentImpulse = 0;
				var id2 = mp2.id;

				for (var j = 0; j < this.m_oldManifold.pointCount; ++j)
				{
					var mp1 = this.m_oldManifold.points[j];

					if (mp1.id.key === id2.key)
					{
						mp2.normalImpulse = mp1.normalImpulse;
						mp2.tangentImpulse = mp1.tangentImpulse;
						break;
					}
				}
			}
//		}
//		else
//		{
//			this.m_manifold.pointCount = 0;
//		}

		if (touching !== wasTouching)
		{
			bodyA.SetAwake(true);
			bodyB.SetAwake(true);
		}
	}

	if (touching)
	{
		this.m_flags |= box2d.b2ContactFlag.e_touchingFlag;
	}
	else
	{
		this.m_flags &= ~box2d.b2ContactFlag.e_touchingFlag;
	}

	if (wasTouching === false && touching === true && listener)
	{
		listener.BeginContact(this);
	}

	if (wasTouching === true && touching === false && listener)
	{
		listener.EndContact(this);
	}

	if (sensor === false && touching && listener)
	{
		listener.PreSolve(this, this.m_oldManifold);
	}
}

/**
 * @export
 * @return {number}
 * @param {box2d.b2Sweep} sweepA
 * @param {box2d.b2Sweep} sweepB
 */
box2d.b2Contact.prototype.ComputeTOI = function (sweepA, sweepB)
{
	var input = box2d.b2Contact.prototype.ComputeTOI.s_input;
	input.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);
	input.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);
	input.sweepA.Copy(sweepA);
	input.sweepB.Copy(sweepB);
	input.tMax = box2d.b2_linearSlop;

	var output = box2d.b2Contact.prototype.ComputeTOI.s_output;

	box2d.b2TimeOfImpact(output, input);

	return output.t;
}
box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput();
box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2PolygonAndCircleContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');

/**
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2PolygonAndCircleContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact);

/**
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2PolygonAndCircleContact.Create = function (allocator)
{
	return new box2d.b2PolygonAndCircleContact();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2PolygonAndCircleContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2PolygonAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_polygonShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2PolygonAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2PolygonShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }
	box2d.b2CollidePolygonAndCircle(
		manifold, 
		(shapeA instanceof box2d.b2PolygonShape)? shapeA : null, xfA, 
		(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2EdgeAndPolygonContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');

/**
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2EdgeAndPolygonContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact);

/**
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2EdgeAndPolygonContact.Create = function (allocator)
{
	return new box2d.b2EdgeAndPolygonContact();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2EdgeAndPolygonContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2EdgeAndPolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_edgeShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_polygonShape); }
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2EdgeShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }
	box2d.b2CollideEdgeAndPolygon(
		manifold, 
		(shapeA instanceof box2d.b2EdgeShape)? shapeA : null, xfA, 
		(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Shape');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Distance');

/** 
 * This holds the mass data computed for a shape. 
 * @export 
 * @constructor
 */
box2d.b2MassData = function ()
{
	this.center = new box2d.b2Vec2(0, 0);
};

/** 
 * The mass of the shape, usually in kilograms. 
 * @export 
 * @type {number}
 */
box2d.b2MassData.prototype.mass = 0;

/** 
 * The position of the shape's centroid relative to the shape's 
 * origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MassData.prototype.center = null;

/** 
 * The rotational inertia of the shape about the local origin. 
 * @export 
 * @type {number}
 */
box2d.b2MassData.prototype.I = 0;

/** 
 * @export 
 * @enum
 */
box2d.b2ShapeType = 
{
	e_unknown			: -1,
	e_circleShape		: 0,
	e_edgeShape			: 1,
	e_polygonShape		: 2,
	e_chainShape		: 3,
	e_shapeTypeCount	: 4
};
goog.exportProperty(box2d.b2ShapeType, 'e_unknown'       , box2d.b2ShapeType.e_unknown       );
goog.exportProperty(box2d.b2ShapeType, 'e_circleShape'   , box2d.b2ShapeType.e_circleShape   );
goog.exportProperty(box2d.b2ShapeType, 'e_edgeShape'     , box2d.b2ShapeType.e_edgeShape     );
goog.exportProperty(box2d.b2ShapeType, 'e_polygonShape'  , box2d.b2ShapeType.e_polygonShape  );
goog.exportProperty(box2d.b2ShapeType, 'e_chainShape'    , box2d.b2ShapeType.e_chainShape    );
goog.exportProperty(box2d.b2ShapeType, 'e_shapeTypeCount', box2d.b2ShapeType.e_shapeTypeCount);

/** 
 * A shape is used for collision detection. You can create a 
 * shape however you like. 
 * Shapes used for simulation in box2d.b2World are created 
 * automatically when a box2d.b2Fixture is created. Shapes may 
 * encapsulate a one or more child shapes. 
 * @export 
 * @constructor 
 * @param {box2d.b2ShapeType} type 
 * @param {number} radius 
 */
box2d.b2Shape = function (type, radius)
{
	this.m_type = type;
	this.m_radius = radius;
}

/**
 * @export 
 * @type {box2d.b2ShapeType}
 */
box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown;
/**
 * @export 
 * @type {number}
 */
box2d.b2Shape.prototype.m_radius = 0;

/** 
 * Clone the concrete shape using the provided allocator. 
 * @export 
 * @return {box2d.b2Shape}
 */
box2d.b2Shape.prototype.Clone = function ()
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
	return null;
}

/**
 * @export 
 * @return {box2d.b2Shape} 
 * @param {box2d.b2Shape} other 
 */
box2d.b2Shape.prototype.Copy = function (other)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_type === other.m_type); }
	this.m_radius = other.m_radius;
	return this;
}

/** 
 * Get the type of this shape. You can use this to down cast to 
 * the concrete shape. 
 * @export 
 * @return {box2d.b2ShapeType} the shape type.
 */
box2d.b2Shape.prototype.GetType = function ()
{
	return this.m_type;
}

/** 
 * Get the number of child primitives. 
 * @export 
 * @return {number}
 */
box2d.b2Shape.prototype.GetChildCount = function ()
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
	return 0;
}

/** 
 * Test a point for containment in this shape. This only works 
 * for convex shapes. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Transform} xf the shape world transform.
 * @param {box2d.b2Vec2} p a point in world coordinates.
 */
box2d.b2Shape.prototype.TestPoint = function (xf, p)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
	return false;
}

/** 
 * Cast a ray against a child shape. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output the ray-cast results.
 * @param {box2d.b2RayCastInput} input the ray-cast input parameters.
 * @param {box2d.b2Transform} transform the transform to be applied to the shape.
 * @param {number} childIndex the child shape index
 */
box2d.b2Shape.prototype.RayCast = function (output, input, transform, childIndex)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
	return false;
}

/** 
 * Given a transform, compute the associated axis aligned 
 * bounding box for a child shape. 
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb returns the axis aligned box.
 * @param {box2d.b2Transform} xf the world transform of the shape.
 * @param {number} childIndex the child shape
 */
box2d.b2Shape.prototype.ComputeAABB = function (aabb, xf, childIndex)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
}

/** 
 * Compute the mass properties of this shape using its 
 * dimensions and density. 
 * The inertia tensor is computed about the local origin.
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData returns the mass data for this shape.
 * @param {number} density the density in kilograms per meter squared.
 */
box2d.b2Shape.prototype.ComputeMass = function (massData, density)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
}

/**
 * @return {void} 
 * @param {box2d.b2DistanceProxy} proxy 
 * @param {number} index 
 */
box2d.b2Shape.prototype.SetupDistanceProxy = function (proxy, index)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} normal
 * @param {number} offset
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} c
 */
box2d.b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
	return 0;
}

/** 
 * Dump this shape to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2Shape.prototype.Dump = function ()
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, "pure virtual"); }
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2PolygonShape');

goog.require('box2d.b2Shape');

/** 
 * A convex polygon. It is assumed that the interior of the 
 * polygon is to the left of each edge. 
 * Polygons have a maximum number of vertices equal to 
 * box2d.b2_maxPolygonVertices. In most cases you should not 
 * need many vertices for a convex polygon. 
 * @export 
 * @constructor
 * @extends {box2d.b2Shape} 
 */
box2d.b2PolygonShape = function ()
{
	goog.base(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius); // base class constructor

	this.m_centroid = new box2d.b2Vec2(0, 0);
	this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
	this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
}

goog.inherits(box2d.b2PolygonShape, box2d.b2Shape);

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PolygonShape.prototype.m_centroid = null;
/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2PolygonShape.prototype.m_vertices = null;
/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2PolygonShape.prototype.m_normals = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PolygonShape.prototype.m_count = 0;

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {box2d.b2Shape} 
 */
box2d.b2PolygonShape.prototype.Clone = function ()
{
	return new box2d.b2PolygonShape().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Shape} 
 * @param {box2d.b2Shape} other
 */
box2d.b2PolygonShape.prototype.Copy = function (other)
{
	goog.base(this, 'Copy', other);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2PolygonShape); }

	this.m_centroid.Copy(other.m_centroid);
	this.m_count = other.m_count;
	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		this.m_vertices[i].Copy(other.m_vertices[i]);
		this.m_normals[i].Copy(other.m_normals[i]);
	}
	return this;
}

/** 
 * Build vertices to represent an axis-aligned box centered on 
 * the local origin. 
 * @export 
 * @return {box2d.b2PolygonShape} 
 * @param {number} hx the half-width.
 * @param {number} hy the half-height.
 */
box2d.b2PolygonShape.prototype.SetAsBox = function (hx, hy)
{
	this.m_count = 4;
	this.m_vertices[0].SetXY((-hx), (-hy));
	this.m_vertices[1].SetXY(hx, (-hy));
	this.m_vertices[2].SetXY(hx, hy);
	this.m_vertices[3].SetXY((-hx), hy);
	this.m_normals[0].SetXY(0, (-1));
	this.m_normals[1].SetXY(1, 0);
	this.m_normals[2].SetXY(0, 1);
	this.m_normals[3].SetXY((-1), 0);
	this.m_centroid.SetZero();
	return this;
}

/** 
 * Build vertices to represent an oriented box. 
 * @export 
 * @return {box2d.b2PolygonShape} 
 * @param {number} hx the half-width.
 * @param {number} hy the half-height.
 * @param {box2d.b2Vec2} center the center of the box in local coordinates.
 * @param {number} angle the rotation of the box in local coordinates.
 */
box2d.b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle)
{
	this.m_count = 4;
	this.m_vertices[0].SetXY((-hx), (-hy));
	this.m_vertices[1].SetXY(hx, (-hy));
	this.m_vertices[2].SetXY(hx, hy);
	this.m_vertices[3].SetXY((-hx), hy);
	this.m_normals[0].SetXY(0, (-1));
	this.m_normals[1].SetXY(1, 0);
	this.m_normals[2].SetXY(0, 1);
	this.m_normals[3].SetXY((-1), 0);
	this.m_centroid.Copy(center);

	var xf = new box2d.b2Transform();
	xf.SetPosition(center);
	xf.SetRotationAngleRadians(angle);

	// Transform vertices and normals.
	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		box2d.b2MulXV(xf, this.m_vertices[i], this.m_vertices[i]);
		box2d.b2MulRV(xf.q, this.m_normals[i], this.m_normals[i]);
	}

	return this;
}

/**
 * Create a convex hull from the given array of local points.
 * The count must be in the range [3, b2_maxPolygonVertices].
 * warning the points may be re-ordered, even if they form a 
 * convex polygon 
 * warning collinear points are handled but not removed. 
 * Collinear points may lead to poor stacking behavior. 
 * @export 
 * @return {box2d.b2PolygonShape} 
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number=} count
 */
box2d.b2PolygonShape.prototype.Set = function (vertices, count)
{
	if (count === undefined) count = vertices.length;

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(3 <= count && count <= box2d.b2_maxPolygonVertices); }
	if (count < 3)
	{
		return this.SetAsBox(1, 1);
	}
	
	var n = box2d.b2Min(count, box2d.b2_maxPolygonVertices);

	// Perform welding and copy vertices into local buffer.
	var ps = box2d.b2PolygonShape.prototype.Set.s_ps;
	var tempCount = 0;
	for (var i = 0; i < n; ++i)
	{
		var /*b2Vec2*/ v = vertices[i];

		var /*bool*/ unique = true;
		for (var /*int32*/ j = 0; j < tempCount; ++j)
		{
			if (box2d.b2DistanceSquaredVV(v, ps[j]) < 0.5 * box2d.b2_linearSlop)
			{
				unique = false;
				break;
			}
		}

		if (unique)
		{
			ps[tempCount++].Copy(v); // ps[tempCount++] = v;
		}
	}

	n = tempCount;
	if (n < 3)
	{
		// Polygon is degenerate.
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		return this.SetAsBox(1.0, 1.0);
	}

	// Create the convex hull using the Gift wrapping algorithm
	// http://en.wikipedia.org/wiki/Gift_wrapping_algorithm

	// Find the right most point on the hull
	var i0 = 0;
	var x0 = ps[0].x;
	for (var i = 1; i < n; ++i)
	{
		var x = ps[i].x;
		if (x > x0 || (x === x0 && ps[i].y < ps[i0].y))
		{
			i0 = i;
			x0 = x;
		}
	}

	var hull = box2d.b2PolygonShape.prototype.Set.s_hull;
	var m = 0;
	var ih = i0;

	for (;;)
	{
		hull[m] = ih;

		var ie = 0;
		for (var j = 1; j < n; ++j)
		{
			if (ie === ih)
			{
				ie = j;
				continue;
			}

			var r = box2d.b2SubVV(ps[ie], ps[hull[m]], box2d.b2PolygonShape.prototype.Set.s_r);
			var v = box2d.b2SubVV(ps[j], ps[hull[m]], box2d.b2PolygonShape.prototype.Set.s_v);
			var c = box2d.b2CrossVV(r, v);
			if (c < 0)
			{
				ie = j;
			}

			// Collinearity check
			if (c === 0 && v.GetLengthSquared() > r.GetLengthSquared())
			{
				ie = j;
			}
		}

		++m;
		ih = ie;

		if (ie === i0)
		{
			break;
		}
	}
	
	this.m_count = m;

	// Copy vertices.
	for (var i = 0; i < m; ++i)
	{
		this.m_vertices[i].Copy(ps[hull[i]]);
	}

	// Compute normals. Ensure the edges have non-zero length.
	for (var i = 0, ict = m; i < ict; ++i)
	{
		var vertexi1 = this.m_vertices[i];
		var vertexi2 = this.m_vertices[(i + 1) % ict];
		var edge = box2d.b2SubVV(vertexi2, vertexi1, box2d.b2Vec2.s_t0); // edge uses s_t0
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(edge.GetLengthSquared() > box2d.b2_epsilon_sq); }
		box2d.b2CrossVOne(edge, this.m_normals[i]).SelfNormalize();
	}

	// Compute the polygon centroid.
	box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);

	return this;
}
box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2();

/**
 * @export 
 * @return {box2d.b2PolygonShape} 
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number=} count 
 */
box2d.b2PolygonShape.prototype.SetAsVector = function (vertices, count)
{
	this.Set(vertices, count);
	return this;
}

/**
 * @export 
 * @return {box2d.b2PolygonShape} 
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number=} count 
 */
box2d.b2PolygonShape.prototype.SetAsArray = function (vertices, count)
{
	this.Set(vertices, count);
	return this;
}

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {number}
 */
box2d.b2PolygonShape.prototype.GetChildCount = function ()
{
	return 1;
}

/** 
 * @see box2d.b2Shape::TestPoint 
 * @export 
 * @return {boolean}
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} p
 */
box2d.b2PolygonShape.prototype.TestPoint = function (xf, p)
{
	var pLocal = box2d.b2MulTXV(xf, p, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal);

	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		var dot = box2d.b2DotVV(this.m_normals[i], box2d.b2SubVV(pLocal, this.m_vertices[i], box2d.b2Vec2.s_t0));
		if (dot > 0)
		{
			return false;
		}
	}

	return true;
}
box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2();

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output 
 * @param {box2d.b2RayCastInput} input 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2PolygonShape.prototype.RayCast = function (output, input, xf, childIndex)
{
	// Put the ray into the polygon's frame of reference.
	var p1 = box2d.b2MulTXV(xf, input.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1);
	var p2 = box2d.b2MulTXV(xf, input.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2);
	var d = box2d.b2SubVV(p2, p1, box2d.b2PolygonShape.prototype.RayCast.s_d);

	var lower = 0, upper = input.maxFraction;

	var index = -1;

	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		// p = p1 + a * d
		// dot(normal, p - v) = 0
		// dot(normal, p1 - v) + a * dot(normal, d) = 0
		var numerator = box2d.b2DotVV(this.m_normals[i], box2d.b2SubVV(this.m_vertices[i], p1, box2d.b2Vec2.s_t0));
		var denominator = box2d.b2DotVV(this.m_normals[i], d);

		if (denominator === 0)
		{
			if (numerator < 0)
			{
				return false;
			}
		}
		else
		{
			// Note: we want this predicate without division:
			// lower < numerator / denominator, where denominator < 0
			// Since denominator < 0, we have to flip the inequality:
			// lower < numerator / denominator <==> denominator * lower > numerator.
			if (denominator < 0 && numerator < lower * denominator)
			{
				// Increase lower.
				// The segment enters this half-space.
				lower = numerator / denominator;
				index = i;
			}
			else if (denominator > 0 && numerator < upper * denominator)
			{
				// Decrease upper.
				// The segment exits this half-space.
				upper = numerator / denominator;
			}
		}

		// The use of epsilon here causes the assert on lower to trip
		// in some cases. Apparently the use of epsilon was to make edge
		// shapes work, but now those are handled separately.
		//if (upper < lower - box2d.b2_epsilon)
		if (upper < lower)
		{
			return false;
		}
	}

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= lower && lower <= input.maxFraction); }

	if (index >= 0)
	{
		output.fraction = lower;
		box2d.b2MulRV(xf.q, this.m_normals[index], output.normal);
		return true;
	}

	return false;
}
box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeAABB 
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2PolygonShape.prototype.ComputeAABB = function (aabb, xf, childIndex)
{
	var lower = box2d.b2MulXV(xf, this.m_vertices[0], aabb.lowerBound);
	var upper = aabb.upperBound.Copy(lower);

	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		var v = box2d.b2MulXV(xf, this.m_vertices[i], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
		box2d.b2MinV(v, lower, lower);
		box2d.b2MaxV(v, upper, upper);
	}

	var r = this.m_radius;
	lower.SelfSubXY(r, r);
	upper.SelfAddXY(r, r);
}
box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeMass 
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData 
 * @param {number} density 
 */
box2d.b2PolygonShape.prototype.ComputeMass = function (massData, density)
{
	// Polygon mass, centroid, and inertia.
	// Let rho be the polygon density in mass per unit area.
	// Then:
	// mass = rho * int(dA)
	// centroid.x = (1/mass) * rho * int(x * dA)
	// centroid.y = (1/mass) * rho * int(y * dA)
	// I = rho * int((x*x + y*y) * dA)
	//
	// We can compute these integrals by summing all the integrals
	// for each triangle of the polygon. To evaluate the integral
	// for a single triangle, we make a change of variables to
	// the (u,v) coordinates of the triangle:
	// x = x0 + e1x * u + e2x * v
	// y = y0 + e1y * u + e2y * v
	// where 0 <= u && 0 <= v && u + v <= 1.
	//
	// We integrate u from [0,1-v] and then v from [0,1].
	// We also need to use the Jacobian of the transformation:
	// D = cross(e1, e2)
	//
	// Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
	//
	// The rest of the derivation is handled by computer algebra.

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_count >= 3); }

	var center = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero();
	var area = 0;
	var I = 0;

	// s is the reference point for forming triangles.
	// It's location doesn't change the result (except for rounding error).
	var s = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero();

	// This code would put the reference point inside the polygon.
	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		s.SelfAdd(this.m_vertices[i]);
	}
	s.SelfMul(1 / this.m_count);

	var k_inv3 = 1 / 3;

	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		// Triangle vertices.
		var e1 = box2d.b2SubVV(this.m_vertices[i], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e1);
		var e2 = box2d.b2SubVV(this.m_vertices[(i + 1) % ict], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e2);

		var D = box2d.b2CrossVV(e1, e2);

		var triangleArea = 0.5 * D;
		area += triangleArea;

		// Area weighted centroid
		center.SelfAdd(box2d.b2MulSV(triangleArea * k_inv3, box2d.b2AddVV(e1, e2, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));

		var ex1 = e1.x;
		var ey1 = e1.y;
		var ex2 = e2.x;
		var ey2 = e2.y;

		var intx2 = ex1*ex1 + ex2*ex1 + ex2*ex2;
		var inty2 = ey1*ey1 + ey2*ey1 + ey2*ey2;

		I += (0.25 * k_inv3 * D) * (intx2 + inty2);
	}

	// Total mass
	massData.mass = density * area;

	// Center of mass
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(area > box2d.b2_epsilon); }
	center.SelfMul(1 / area);
	box2d.b2AddVV(center, s, massData.center);

	// Inertia tensor relative to the local origin (point s).
	massData.I = density * I;
	
	// Shift to center of mass then to original body origin.
	massData.I += massData.mass * (box2d.b2DotVV(massData.center, massData.center) - box2d.b2DotVV(center, center));
}
box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2();

/** 
 * Validate convexity. This is a very time consuming operation. 
 * @export 
 * @return {boolean} true if valid
 */
box2d.b2PolygonShape.prototype.Validate = function ()
{
	for (var i = 0; i < this.m_count; ++i)
	{
		var i1 = i;
		var i2 = (i + 1) % this.m_count;
		var p = this.m_vertices[i1];
		var e = box2d.b2SubVV(this.m_vertices[i2], p, box2d.b2PolygonShape.prototype.Validate.s_e);

		for (var j = 0; j < this.m_count; ++j)
		{
			if (j === i1 || j === i2)
			{
				continue;
			}

			var v = box2d.b2SubVV(this.m_vertices[j], p, box2d.b2PolygonShape.prototype.Validate.s_v);
			var c = box2d.b2CrossVV(e, v);
			if (c < 0)
			{
				return false;
			}
		}
	}

	return true;
}
box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2();

/**
 * @return {void} 
 * @param {box2d.b2DistanceProxy} proxy 
 * @param {number} index 
 */
box2d.b2PolygonShape.prototype.SetupDistanceProxy = function (proxy, index)
{
	proxy.m_vertices = this.m_vertices;
	proxy.m_count = this.m_count;
	proxy.m_radius = this.m_radius;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} normal
 * @param {number} offset
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} c
 */
box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
{
	// Transform plane into shape co-ordinates
	var normalL = box2d.b2MulTRV(xf.q, normal, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL);
	var offsetL = offset - box2d.b2DotVV(normal, xf.p);

	var depths = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths;
	var diveCount = 0;
	var intoIndex = -1;
	var outoIndex = -1;

	var lastSubmerged = false;
	for (var i = 0, ict = this.m_count; i < ict; ++i)
	{
		depths[i] = box2d.b2DotVV(normalL, this.m_vertices[i]) - offsetL;
		var isSubmerged = depths[i] < (-box2d.b2_epsilon);
		if (i > 0)
		{
			if (isSubmerged)
			{
				if (!lastSubmerged)
				{
					intoIndex = i - 1;
					diveCount++;
				}
			}
			else
			{
				if (lastSubmerged)
				{
					outoIndex = i - 1;
					diveCount++;
				}
			}
		}
		lastSubmerged = isSubmerged;
	}
	switch (diveCount)
	{
	case 0:
		if (lastSubmerged)
		{
			// Completely submerged
			var md = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md;
			this.ComputeMass(md, 1);
			box2d.b2MulXV(xf, md.center, c);
			return md.mass;
		}
		else
		{
			//Completely dry
			return 0;
		}
		break;
	case 1:
		if (intoIndex === (-1))
		{
			intoIndex = this.m_count - 1;
		}
		else
		{
			outoIndex = this.m_count - 1;
		}
		break;
	}
	var intoIndex2 = ((intoIndex + 1) % this.m_count);
	var outoIndex2 = ((outoIndex + 1) % this.m_count);
	var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
	var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);

	var intoVec = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(
		this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, 
		this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
	var outoVec = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(
		this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, 
		this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);

	// Initialize accumulator
	var area = 0;
	var center = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero();
	var p2 = this.m_vertices[intoIndex2];
	var p3 = null;

	// An awkward loop from intoIndex2+1 to outIndex2
	var i = intoIndex2;
	while (i !== outoIndex2)
	{
		i = (i + 1) % this.m_count;
		if (i === outoIndex2)
			p3 = outoVec;
		else
			p3	= this.m_vertices[i];

		var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
		area += triangleArea;
		// Area weighted centroid
		center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
		center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;

		p2 = p3;
	}

	//Normalize and transform centroid
	center.SelfMul(1 / area);
	box2d.b2MulXV(xf, center, c);

	return area;
}
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData();
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2();
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2();

/** 
 * Dump this shape to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2PolygonShape.prototype.Dump = function ()
{
	box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n");
	box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
	for (var i = 0; i < this.m_count; ++i)
	{
		box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
	}
	box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count);
}

/**
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {Array.<box2d.b2Vec2>} vs 
 * @param {number} count 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PolygonShape.ComputeCentroid = function (vs, count, out)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 3); }

	var c = out; c.SetZero();
	var area = 0;

	// s is the reference point for forming triangles.
	// It's location doesn't change the result (except for rounding error).
	var pRef = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero();
/*
#if 0
	// This code would put the reference point inside the polygon.
	for (var i = 0; i < count; ++i)
	{
    	pRef.SelfAdd(vs[i]);
	}
	pRef.SelfMul(1 / count);
#endif
*/

	var inv3 = 1 / 3;

	for (var i = 0; i < count; ++i)
	{
		// Triangle vertices.
		var p1 = pRef;
		var p2 = vs[i];
		var p3 = vs[(i + 1) % count];

		var e1 = box2d.b2SubVV(p2, p1, box2d.b2PolygonShape.ComputeCentroid.s_e1);
		var e2 = box2d.b2SubVV(p3, p1, box2d.b2PolygonShape.ComputeCentroid.s_e2);

		var D = box2d.b2CrossVV(e1, e2);

		var triangleArea = 0.5 * D;
		area += triangleArea;

		// Area weighted centroid
		c.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);
		c.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);
	}

	// Centroid
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(area > box2d.b2_epsilon); }
	c.SelfMul(1 / area);
	return c;
}
box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2();
box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2();
box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2();

/*
box2d.b2PolygonShape.ComputeOBB = function (obb, vs, count)
{
	var i = 0;
	var p = new Array(count + 1);
	for (i = 0; i < count; ++i)
	{
		p[i] = vs[i];
	}
	p[count] = p[0];
	var minArea = box2d.b2_maxFloat;
	for (i = 1; i <= count; ++i)
	{
		var root = p[i - 1];
		var uxX = p[i].x - root.x;
		var uxY = p[i].y - root.y;
		var length = box2d.b2Sqrt(uxX * uxX + uxY * uxY);
		uxX /= length;
		uxY /= length;
		var uyX = (-uxY);
		var uyY = uxX;
		var lowerX = box2d.b2_maxFloat;
		var lowerY = box2d.b2_maxFloat;
		var upperX = (-box2d.b2_maxFloat);
		var upperY = (-box2d.b2_maxFloat);
		for (var j = 0; j < count; ++j)
		{
			var dX = p[j].x - root.x;
			var dY = p[j].y - root.y;
			var rX = (uxX * dX + uxY * dY);
			var rY = (uyX * dX + uyY * dY);
			if (rX < lowerX) lowerX = rX;
			if (rY < lowerY) lowerY = rY;
			if (rX > upperX) upperX = rX;
			if (rY > upperY) upperY = rY;
		}
		var area = (upperX - lowerX) * (upperY - lowerY);
		if (area < 0.95 * minArea)
		{
			minArea = area;
			obb.R.ex.x = uxX;
			obb.R.ex.y = uxY;
			obb.R.ey.x = uyX;
			obb.R.ey.y = uyY;
			var center_x = 0.5 * (lowerX + upperX);
			var center_y = 0.5 * (lowerY + upperY);
			var tMat = obb.R;
			obb.center.x = root.x + (tMat.ex.x * center_x + tMat.ey.x * center_y);
			obb.center.y = root.y + (tMat.ex.y * center_x + tMat.ey.y * center_y);
			obb.extents.x = 0.5 * (upperX - lowerX);
			obb.extents.y = 0.5 * (upperY - lowerY);
		}
	}
}
*/

/*
 * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

goog.provide('box2d.b2CollideEdge');

goog.require('box2d.b2Collision');

/** 
 * Compute the collision manifold between an edge and a circle. 
 * Compute contact points for edge versus circle. 
 * This accounts for edge connectivity.
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2EdgeShape} edgeA
 * @param {box2d.b2Transform} xfA
 * @param {box2d.b2CircleShape} circleB
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2CollideEdgeAndCircle = function (manifold, edgeA, xfA, circleB, xfB)
{
	manifold.pointCount = 0;
	
	// Compute circle in frame of edge
	/** @type {box2d.b2Vec2} */ var Q = box2d.b2MulTXV(xfA, box2d.b2MulXV(xfB, circleB.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q);
	
	/** @type {box2d.b2Vec2} */ var A = edgeA.m_vertex1;
	/** @type {box2d.b2Vec2} */ var B = edgeA.m_vertex2;
	/** @type {box2d.b2Vec2} */ var e = box2d.b2SubVV(B, A, box2d.b2CollideEdgeAndCircle.s_e);
	
	// Barycentric coordinates
	/** @type {number} */ var u = box2d.b2DotVV(e, box2d.b2SubVV(B, Q, box2d.b2Vec2.s_t0));
	/** @type {number} */ var v = box2d.b2DotVV(e, box2d.b2SubVV(Q, A, box2d.b2Vec2.s_t0));
	
	/** @type {number} */ var radius = edgeA.m_radius + circleB.m_radius;
	
//	/** @type {box2d.b2ContactFeature} */ var cf = new box2d.b2ContactFeature();
	/** @type {box2d.b2ContactID} */ var id = box2d.b2CollideEdgeAndCircle.s_id;
	id.cf.indexB = 0;
	id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
	
	// Region A
	if (v <= 0)
	{
		/** @type {box2d.b2Vec2} */ var P = A;
		/** @type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);
		/** @type {number} */ var dd = box2d.b2DotVV(d, d);
		if (dd > radius * radius)
		{
			return;
		}
		
		// Is there an edge connected to A?
		if (edgeA.m_hasVertex0)
		{
			/** @type {box2d.b2Vec2} */ var A1 = edgeA.m_vertex0;
			/** @type {box2d.b2Vec2} */ var B1 = A;
			/** @type {box2d.b2Vec2} */ var e1 = box2d.b2SubVV(B1, A1, box2d.b2CollideEdgeAndCircle.s_e1);
			/** @type {number} */ var u1 = box2d.b2DotVV(e1, box2d.b2SubVV(B1, Q, box2d.b2Vec2.s_t0));
			
			// Is the circle in Region AB of the previous edge?
			if (u1 > 0)
			{
				return;
			}
		}
		
		id.cf.indexA = 0;
		id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_circles;
		manifold.localNormal.SetZero();
		manifold.localPoint.Copy(P);
		manifold.points[0].id.Copy(id);
//		manifold.points[0].id.key = 0;
//		manifold.points[0].id.cf = cf;
		manifold.points[0].localPoint.Copy(circleB.m_p);
		return;
	}
	
	// Region B
	if (u <= 0)
	{
		/** type {box2d.b2Vec2} */ var P = B;
		/** type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);
		/** type {number} */ var dd = box2d.b2DotVV(d, d);
		if (dd > radius * radius)
		{
			return;
		}
		
		// Is there an edge connected to B?
		if (edgeA.m_hasVertex3)
		{
			/** @type {box2d.b2Vec2} */ var B2 = edgeA.m_vertex3;
			/** @type {box2d.b2Vec2} */ var A2 = B;
			/** @type {box2d.b2Vec2} */ var e2 = box2d.b2SubVV(B2, A2, box2d.b2CollideEdgeAndCircle.s_e2);
			/** @type {number} */ var v2 = box2d.b2DotVV(e2, box2d.b2SubVV(Q, A2, box2d.b2Vec2.s_t0));
			
			// Is the circle in Region AB of the next edge?
			if (v2 > 0)
			{
				return;
			}
		}
		
		id.cf.indexA = 1;
		id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_circles;
		manifold.localNormal.SetZero();
		manifold.localPoint.Copy(P);
		manifold.points[0].id.Copy(id);
//		manifold.points[0].id.key = 0;
//		manifold.points[0].id.cf = cf;
		manifold.points[0].localPoint.Copy(circleB.m_p);
		return;
	}
	
	// Region AB
	/** @type {number} */ var den = box2d.b2DotVV(e, e);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(den > 0); }
	/** type {box2d.b2Vec2} */ var P = box2d.b2CollideEdgeAndCircle.s_P;
	P.x = (1 / den) * (u * A.x + v * B.x);
	P.y = (1 / den) * (u * A.y + v * B.y);
	/** type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);
	/** type {number} */ var dd = box2d.b2DotVV(d, d);
	if (dd > radius * radius)
	{
		return;
	}
	
	/** @type {box2d.b2Vec2} */ var n = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-e.y, e.x);
	if (box2d.b2DotVV(n, box2d.b2SubVV(Q, A, box2d.b2Vec2.s_t0)) < 0)
	{
		n.SetXY(-n.x, -n.y);
	}
	n.Normalize();
	
	id.cf.indexA = 0;
	id.cf.typeA = box2d.b2ContactFeatureType.e_face;
	manifold.pointCount = 1;
	manifold.type = box2d.b2ManifoldType.e_faceA;
	manifold.localNormal.Copy(n);
	manifold.localPoint.Copy(A);
	manifold.points[0].id.Copy(id);
//	manifold.points[0].id.key = 0;
//	manifold.points[0].id.cf = cf;
	manifold.points[0].localPoint.Copy(circleB.m_p);
}
box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2();
box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID();

/** 
 * @export 
 * @enum
 */
box2d.b2EPAxisType = 
{
	e_unknown	: 0, 
	e_edgeA		: 1, 
	e_edgeB		: 2
};
goog.exportProperty(box2d.b2EPAxisType, 'e_unknown', box2d.b2EPAxisType.e_unknown);
goog.exportProperty(box2d.b2EPAxisType, 'e_edgeA'  , box2d.b2EPAxisType.e_edgeA  );
goog.exportProperty(box2d.b2EPAxisType, 'e_edgeB'  , box2d.b2EPAxisType.e_edgeB  );
	
/** 
 * This structure is used to keep track of the best separating 
 * axis. 
 * @export 
 * @constructor
 */
box2d.b2EPAxis = function ()
{
};

/**
 * @export 
 * @type {box2d.b2EPAxisType}
 */
box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown;
/**
 * @export 
 * @type {number}
 */
box2d.b2EPAxis.prototype.index = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2EPAxis.prototype.separation = 0;

/** 
 * This holds polygon B expressed in frame A. 
 * @export 
 * @constructor
 */
box2d.b2TempPolygon = function ()
{
	this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
	this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
	this.count = 0;
};

/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2TempPolygon.prototype.vertices = null;
/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2TempPolygon.prototype.normals = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2TempPolygon.prototype.count = 0;

/** 
 * Reference face used for clipping 
 * @export 
 * @constructor
 */
box2d.b2ReferenceFace = function ()
{
	this.i1 = 0;
	this.i2 = 0;
	
	this.v1 = new box2d.b2Vec2();
	this.v2 = new box2d.b2Vec2();
	
	this.normal = new box2d.b2Vec2();
	
	this.sideNormal1 = new box2d.b2Vec2();
	this.sideOffset1 = 0;
	
	this.sideNormal2 = new box2d.b2Vec2();
	this.sideOffset2 = 0;
};

/**
 * @export 
 * @type {number}
 */
box2d.b2ReferenceFace.prototype.i1 = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ReferenceFace.prototype.i2 = 0;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ReferenceFace.prototype.v1 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ReferenceFace.prototype.v2 = null;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ReferenceFace.prototype.normal = null;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ReferenceFace.prototype.sideNormal1 = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ReferenceFace.prototype.sideOffset1 = 0;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ReferenceFace.prototype.sideNormal2 = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ReferenceFace.prototype.sideOffset2 = 0;

/**
 * @export
 * @enum
 */
box2d.b2EPColliderVertexType = 
{
	e_isolated	: 0,
	e_concave	: 1,
	e_convex	: 2
};
goog.exportProperty(box2d.b2EPColliderVertexType, 'e_isolated', box2d.b2EPColliderVertexType.e_isolated);
goog.exportProperty(box2d.b2EPColliderVertexType, 'e_concave' , box2d.b2EPColliderVertexType.e_concave );
goog.exportProperty(box2d.b2EPColliderVertexType, 'e_convex'  , box2d.b2EPColliderVertexType.e_convex  );
	
/** 
 * This class collides and edge and a polygon, taking into 
 * account edge adjacency. 
 * @export 
 * @constructor
 */
box2d.b2EPCollider = function ()
{
	this.m_polygonB = new box2d.b2TempPolygon();
	
	this.m_xf = new box2d.b2Transform();
	this.m_centroidB = new box2d.b2Vec2();
	this.m_v0 = new box2d.b2Vec2(), this.m_v1 = new box2d.b2Vec2(), this.m_v2 = new box2d.b2Vec2(), this.m_v3 = new box2d.b2Vec2();
	this.m_normal0 = new box2d.b2Vec2(), this.m_normal1 = new box2d.b2Vec2(), this.m_normal2 = new box2d.b2Vec2();
	this.m_normal = new box2d.b2Vec2();
	this.m_type1 = box2d.b2EPColliderVertexType.e_isolated, this.m_type2 = box2d.b2EPColliderVertexType.e_isolated;
	this.m_lowerLimit = new box2d.b2Vec2(), this.m_upperLimit = new box2d.b2Vec2();
	this.m_radius = 0;
	this.m_front = false;
};

/**
 * @export 
 * @type {box2d.b2TempPolygon}
 */
box2d.b2EPCollider.prototype.m_polygonB = null;

/**
 * @export 
 * @type {box2d.b2Transform}
 */
box2d.b2EPCollider.prototype.m_xf = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_centroidB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_v0 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_v1 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_v2 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_v3 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_normal0 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_normal1 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_normal2 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_normal = null;
/**
 * @export 
 * @type {box2d.b2EPColliderVertexType}
 */
box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
/**
 * @export 
 * @type {box2d.b2EPColliderVertexType}
 */
box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_lowerLimit = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EPCollider.prototype.m_upperLimit = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2EPCollider.prototype.m_radius = 0;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2EPCollider.prototype.m_front = false;

/** 
 * Algorithm:
 * 1. Classify v1 and v2
 * 2. Classify polygon centroid as front or back
 * 3. Flip normal if necessary
 * 4. Initialize normal range to [-pi, pi] about face normal
 * 5. Adjust normal range according to adjacent edges
 * 6. Visit each separating axes, only accept axes within the range
 * 7. Return if _any_ axis indicates separation
 * 8. Clip
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2EdgeShape} edgeA 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2PolygonShape} polygonB 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2EPCollider.prototype.Collide = function (manifold, edgeA, xfA, polygonB, xfB)
{
	box2d.b2MulTXX(xfA, xfB, this.m_xf);
	
	box2d.b2MulXV(this.m_xf, polygonB.m_centroid, this.m_centroidB);
	
	this.m_v0.Copy(edgeA.m_vertex0);
	this.m_v1.Copy(edgeA.m_vertex1);
	this.m_v2.Copy(edgeA.m_vertex2);
	this.m_v3.Copy(edgeA.m_vertex3);
	
	/** @type {boolean} */ var hasVertex0 = edgeA.m_hasVertex0;
	/** @type {boolean} */ var hasVertex3 = edgeA.m_hasVertex3;
	
	/** @type {box2d.b2Vec2} */ var edge1 = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
	edge1.Normalize();
	this.m_normal1.SetXY(edge1.y, -edge1.x);
	/** @type {number} */ var offset1 = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0));
	/** @type {number} */ var offset0 = 0;
	/** @type {number} */ var offset2 = 0;
	/** @type {boolean} */ var convex1 = false;
	/** @type {boolean} */ var convex2 = false;
	
	// Is there a preceding edge?
	if (hasVertex0)
	{
		/** @type {box2d.b2Vec2} */ var edge0 = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0);
		edge0.Normalize();
		this.m_normal0.SetXY(edge0.y, -edge0.x);
		convex1 = box2d.b2CrossVV(edge0, edge1) >= 0;
		offset0 = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0));
	}
	
	// Is there a following edge?
	if (hasVertex3)
	{
		/** @type {box2d.b2Vec2} */ var edge2 = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2);
		edge2.Normalize();
		this.m_normal2.SetXY(edge2.y, -edge2.x);
		convex2 = box2d.b2CrossVV(edge1, edge2) > 0;
		offset2 = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0));
	}
	
	// Determine front or back collision. Determine collision normal limits.
	if (hasVertex0 && hasVertex3)
	{
		if (convex1 && convex2)
		{
			this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal0);
				this.m_upperLimit.Copy(this.m_normal2);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
			}
		}
		else if (convex1)
		{
			this.m_front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal0);
				this.m_upperLimit.Copy(this.m_normal1);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
			}
		}
		else if (convex2)
		{
			this.m_front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal1);
				this.m_upperLimit.Copy(this.m_normal2);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
			}
		}
		else
		{
			this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal1);
				this.m_upperLimit.Copy(this.m_normal1);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
			}
		}
	}
	else if (hasVertex0)
	{
		if (convex1)
		{
			this.m_front = offset0 >= 0 || offset1 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal0);
				this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal1);
				this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
			}
		}
		else
		{
			this.m_front = offset0 >= 0 && offset1 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal1);
				this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal1);
				this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
			}
		}
	}
	else if (hasVertex3)
	{
		if (convex2)
		{
			this.m_front = offset1 >= 0 || offset2 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal2);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal1);
			}
		}
		else
		{
			this.m_front = offset1 >= 0 && offset2 >= 0;
			if (this.m_front)
			{
				this.m_normal.Copy(this.m_normal1);
				this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal1);
			}
			else
			{
				this.m_normal.Copy(this.m_normal1).SelfNeg();
				this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
				this.m_upperLimit.Copy(this.m_normal1);
			}
		}		
	}
	else
	{
		this.m_front = offset1 >= 0;
		if (this.m_front)
		{
			this.m_normal.Copy(this.m_normal1);
			this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
			this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
		}
		else
		{
			this.m_normal.Copy(this.m_normal1).SelfNeg();
			this.m_lowerLimit.Copy(this.m_normal1);
			this.m_upperLimit.Copy(this.m_normal1);
		}
	}
	
	// Get polygonB in frameA
	this.m_polygonB.count = polygonB.m_count;
	for (var i = 0, ict = polygonB.m_count; i < ict; ++i)
	{
		box2d.b2MulXV(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);
		box2d.b2MulRV(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);
	}
	
	this.m_radius = 2 * box2d.b2_polygonRadius;
	
	manifold.pointCount = 0;
	
	/** @type {box2d.b2EPAxis} */ var edgeAxis = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
	
	// If no valid normal can be found than this edge should not collide.
	if (edgeAxis.type === box2d.b2EPAxisType.e_unknown)
	{
		return;
	}
	
	if (edgeAxis.separation > this.m_radius)
	{
		return;
	}
	
	/** @type {box2d.b2EPAxis} */ var polygonAxis = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis);
	if (polygonAxis.type !== box2d.b2EPAxisType.e_unknown && polygonAxis.separation > this.m_radius)
	{
		return;
	}
	
	// Use hysteresis for jitter reduction.
	/** @type {number} */ var k_relativeTol = 0.98;
	/** @type {number} */ var k_absoluteTol = 0.001;
	
	/** @type {box2d.b2EPAxis} */ var primaryAxis;
	if (polygonAxis.type === box2d.b2EPAxisType.e_unknown)
	{
		primaryAxis = edgeAxis;
	}
	else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol)
	{
		primaryAxis = polygonAxis;
	}
	else
	{
		primaryAxis = edgeAxis;
	}
	
	/** @type {Array.<box2d.b2ClipVertex>} */ var ie = box2d.b2EPCollider.s_ie;
	/** @type {box2d.b2ReferenceFace} */ var rf = box2d.b2EPCollider.s_rf;
	if (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)
	{
		manifold.type = box2d.b2ManifoldType.e_faceA;
		
		// Search for the polygon normal that is most anti-parallel to the edge normal.
		/** @type {number} */ var bestIndex = 0;
		/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);
		for (var i = 1, ict = this.m_polygonB.count; i < ict; ++i)
		{
			/** @type {number} */ var value = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[i]);
			if (value < bestValue)
			{
				bestValue = value;
				bestIndex = i;
			}
		}
		
		/** @type {number} */ var i1 = bestIndex;
		/** @type {number} */ var i2 = (i1 + 1) % this.m_polygonB.count;
		
		var ie0 = ie[0];
		ie0.v.Copy(this.m_polygonB.vertices[i1]);
		ie0.id.cf.indexA = 0;
		ie0.id.cf.indexB = i1;
		ie0.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
		ie0.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
		
		var ie1 = ie[1];
		ie1.v.Copy(this.m_polygonB.vertices[i2]);
		ie1.id.cf.indexA = 0;
		ie1.id.cf.indexB = i2;
		ie1.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
		ie1.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
		
		if (this.m_front)
		{
			rf.i1 = 0;
			rf.i2 = 1;
			rf.v1.Copy(this.m_v1);
			rf.v2.Copy(this.m_v2);
			rf.normal.Copy(this.m_normal1);
		}
		else
		{
			rf.i1 = 1;
			rf.i2 = 0;
			rf.v1.Copy(this.m_v2);
			rf.v2.Copy(this.m_v1);
			rf.normal.Copy(this.m_normal1).SelfNeg();
		}		
	}
	else
	{
		manifold.type = box2d.b2ManifoldType.e_faceB;
		
		var ie0 = ie[0];
		ie0.v.Copy(this.m_v1);
		ie0.id.cf.indexA = 0;
		ie0.id.cf.indexB = primaryAxis.index;
		ie0.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
		ie0.id.cf.typeB = box2d.b2ContactFeatureType.e_face;
		
		var ie1 = ie[1];
		ie1.v.Copy(this.m_v2);
		ie1.id.cf.indexA = 0;
		ie1.id.cf.indexB = primaryAxis.index;		
		ie1.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
		ie1.id.cf.typeB = box2d.b2ContactFeatureType.e_face;
		
		rf.i1 = primaryAxis.index;
		rf.i2 = (rf.i1 + 1) % this.m_polygonB.count;
		rf.v1.Copy(this.m_polygonB.vertices[rf.i1]);
		rf.v2.Copy(this.m_polygonB.vertices[rf.i2]);
		rf.normal.Copy(this.m_polygonB.normals[rf.i1]);
	}
	
	rf.sideNormal1.SetXY(rf.normal.y, -rf.normal.x);
	rf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();
	rf.sideOffset1 = box2d.b2DotVV(rf.sideNormal1, rf.v1);
	rf.sideOffset2 = box2d.b2DotVV(rf.sideNormal2, rf.v2);
	
	// Clip incident edge against extruded edge1 side edges.
	/** @type {Array.<box2d.b2ClipVertex>} */ var clipPoints1 = box2d.b2EPCollider.s_clipPoints1;
	/** @type {Array.<box2d.b2ClipVertex>} */ var clipPoints2 = box2d.b2EPCollider.s_clipPoints2;
	/** @type {number} */ var np = 0;
	
	// Clip to box side 1
	np = box2d.b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
	
	if (np < box2d.b2_maxManifoldPoints)
	{
		return;
	}
	
	// Clip to negative box side 1
	np = box2d.b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
	
	if (np < box2d.b2_maxManifoldPoints)
	{
		return;
	}
	
	// Now clipPoints2 contains the clipped points.
	if (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)
	{
		manifold.localNormal.Copy(rf.normal);
		manifold.localPoint.Copy(rf.v1);
	}
	else
	{
		manifold.localNormal.Copy(polygonB.m_normals[rf.i1]);
		manifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);
	}
	
	/** @type {number} */ var pointCount = 0;
	for (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)
	{
		/** @type {number} */ var separation;
		
		separation = box2d.b2DotVV(rf.normal, box2d.b2SubVV(clipPoints2[i].v, rf.v1, box2d.b2Vec2.s_t0));
		
		if (separation <= this.m_radius)
		{
			/** @type {box2d.b2ManifoldPoint} */ var cp = manifold.points[pointCount];
			
			if (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)
			{
				box2d.b2MulTXV(this.m_xf, clipPoints2[i].v, cp.localPoint);
				cp.id = clipPoints2[i].id;
			}
			else
			{
				cp.localPoint.Copy(clipPoints2[i].v);
				cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
				cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
				cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
				cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
			}
			
			++pointCount;
		}
	}
	
	manifold.pointCount = pointCount;
}

box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2();
box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2();
box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2();
box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace();
box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis();
box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis();

/**
 * @export 
 * @return {box2d.b2EPAxis}
 * @param {box2d.b2EPAxis} out 
 */
box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function (out)
{
	/** @type {box2d.b2EPAxis} */ var axis = out;
	axis.type = box2d.b2EPAxisType.e_edgeA;
	axis.index = this.m_front ? 0 : 1;
	axis.separation = box2d.b2_maxFloat;
	
	for (var i = 0, ict = this.m_polygonB.count; i < ict; ++i)
	{
		/** @type {number} */ var s = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));
		if (s < axis.separation)
		{
			axis.separation = s;
		}
	}
	
	return axis;
}

/** 
 * @export 
 * @return {box2d.b2EPAxis}
 * @param {box2d.b2EPAxis} out 
 */
box2d.b2EPCollider.prototype.ComputePolygonSeparation = function (out)
{
	/** @type {box2d.b2EPAxis} */ var axis = out;
	axis.type = box2d.b2EPAxisType.e_unknown;
	axis.index = -1;
	axis.separation = -box2d.b2_maxFloat;

	/** @type {box2d.b2Vec2} */ var perp = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x);

	for (var i = 0, ict = this.m_polygonB.count; i < ict; ++i)
	{
		/** @type {box2d.b2Vec2} */ var n = box2d.b2NegV(this.m_polygonB.normals[i], box2d.b2EPCollider.s_n);
		
		/** @type {number} */ var s1 = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));
		/** @type {number} */ var s2 = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v2, box2d.b2Vec2.s_t0));
		/** @type {number} */ var s = box2d.b2Min(s1, s2);
		
		if (s > this.m_radius)
		{
			// No collision
			axis.type = box2d.b2EPAxisType.e_edgeB;
			axis.index = i;
			axis.separation = s;
			return axis;
		}
		
		// Adjacency
		if (box2d.b2DotVV(n, perp) >= 0)
		{
			if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
			{
				continue;
			}
		}
		else
		{
			if (box2d.b2DotVV(box2d.b2SubVV(n, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
			{
				continue;
			}
		}
		
		if (s > axis.separation)
		{
			axis.type = box2d.b2EPAxisType.e_edgeB;
			axis.index = i;
			axis.separation = s;
		}
	}
	
	return axis;
}
box2d.b2EPCollider.s_n = new box2d.b2Vec2();
box2d.b2EPCollider.s_perp = new box2d.b2Vec2();

/** 
 * Compute the collision manifold between an edge and a polygon.
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2EdgeShape} edgeA
 * @param {box2d.b2Transform} xfA
 * @param {box2d.b2PolygonShape} polygonB
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2CollideEdgeAndPolygon = function (manifold, edgeA, xfA, polygonB, xfB)
{
	/** @type {box2d.b2EPCollider} */ var collider = box2d.b2CollideEdgeAndPolygon.s_collider;
	collider.Collide(manifold, edgeA, xfA, polygonB, xfB);
}
box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider();

/*
* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2EdgeShape');

goog.require('box2d.b2Shape');

/** 
 * A line segment (edge) shape. These can be connected in chains 
 * or loops to other edge shapes. The connectivity information 
 * is used to ensure correct contact normals. 
 * @export 
 * @constructor
 * @extends {box2d.b2Shape} 
 */
box2d.b2EdgeShape = function ()
{
	goog.base(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius); // base class constructor

	this.m_vertex1 = new box2d.b2Vec2();
	this.m_vertex2 = new box2d.b2Vec2();

	this.m_vertex0 = new box2d.b2Vec2();
	this.m_vertex3 = new box2d.b2Vec2();
}

goog.inherits(box2d.b2EdgeShape, box2d.b2Shape);

/** 
 * These are the edge vertices 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EdgeShape.prototype.m_vertex1 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EdgeShape.prototype.m_vertex2 = null;

/** 
 * Optional adjacent vertices. These are used for smooth 
 * collision. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EdgeShape.prototype.m_vertex0 = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2EdgeShape.prototype.m_vertex3 = null;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2EdgeShape.prototype.m_hasVertex0 = false;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2EdgeShape.prototype.m_hasVertex3 = false;

/** 
 * Set this as an isolated edge. 
 * @export 
 * @return {box2d.b2EdgeShape} 
 * @param {box2d.b2Vec2} v1
 * @param {box2d.b2Vec2} v2 
 */
box2d.b2EdgeShape.prototype.Set = function (v1, v2)
{
	this.m_vertex1.Copy(v1);
	this.m_vertex2.Copy(v2);
	this.m_hasVertex0 = false;
	this.m_hasVertex3 = false;
	return this;
}

box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set;

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {box2d.b2Shape} 
 */
box2d.b2EdgeShape.prototype.Clone = function ()
{
	return new box2d.b2EdgeShape().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Shape} 
 * @param {box2d.b2Shape} other
 */
box2d.b2EdgeShape.prototype.Copy = function (other)
{
	goog.base(this, 'Copy', other);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2EdgeShape); }

	this.m_vertex1.Copy(other.m_vertex1);
	this.m_vertex2.Copy(other.m_vertex2);
	this.m_vertex0.Copy(other.m_vertex0);
	this.m_vertex3.Copy(other.m_vertex3);
	this.m_hasVertex0 = other.m_hasVertex0;
	this.m_hasVertex3 = other.m_hasVertex3;

	return this;
}

/** 
 * @see box2d.b2Shape::GetChildCount 
 * @export 
 * @return {number}
 */
box2d.b2EdgeShape.prototype.GetChildCount = function ()
{
	return 1;
}

/** 
 * @see box2d.b2Shape::TestPoint 
 * @export 
 * @return {boolean}
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} p
 */
box2d.b2EdgeShape.prototype.TestPoint = function (xf, p)
{
	return false;
}

/** 
 * Implement box2d.b2Shape.
 * p = p1 + t * d
 * v = v1 + s * e
 * p1 + t * d = v1 + s * e
 * s * e - t * d = p1 - v1
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output 
 * @param {box2d.b2RayCastInput} input 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2EdgeShape.prototype.RayCast = function (output, input, xf, childIndex)
{
	// Put the ray into the edge's frame of reference.
	var p1 = box2d.b2MulTXV(xf, input.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1);
	var p2 = box2d.b2MulTXV(xf, input.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2);
	var d = box2d.b2SubVV(p2, p1, box2d.b2EdgeShape.prototype.RayCast.s_d);

	var v1 = this.m_vertex1;
	var v2 = this.m_vertex2;
	var e = box2d.b2SubVV(v2, v1, box2d.b2EdgeShape.prototype.RayCast.s_e);
	var normal = output.normal.SetXY(e.y, -e.x).SelfNormalize();

	// q = p1 + t * d
	// dot(normal, q - v1) = 0
	// dot(normal, p1 - v1) + t * dot(normal, d) = 0
	var numerator = box2d.b2DotVV(normal, box2d.b2SubVV(v1, p1, box2d.b2Vec2.s_t0));
	var denominator = box2d.b2DotVV(normal, d);

	if (denominator === 0)
	{
		return false;
	}

	var t = numerator / denominator;
	if (t < 0 || input.maxFraction < t)
	{
		return false;
	}

	var q = box2d.b2AddVMulSV(p1, t, d, box2d.b2EdgeShape.prototype.RayCast.s_q);

	// q = v1 + s * r
	// s = dot(q - v1, r) / dot(r, r)
	var r = box2d.b2SubVV(v2, v1, box2d.b2EdgeShape.prototype.RayCast.s_r);
	var rr = box2d.b2DotVV(r, r);
	if (rr === 0)
	{
		return false;
	}

	var s = box2d.b2DotVV(box2d.b2SubVV(q, v1, box2d.b2Vec2.s_t0), r) / rr;
	if (s < 0 || 1 < s)
	{
		return false;
	}

	output.fraction = t;
	box2d.b2MulRV(xf.q, output.normal, output.normal);
	if (numerator > 0)
	{
		output.normal.SelfNeg();
	}
	return true;
}
box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeAABB 
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2EdgeShape.prototype.ComputeAABB = function (aabb, xf, childIndex)
{
	var v1 = box2d.b2MulXV(xf, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1);
	var v2 = box2d.b2MulXV(xf, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);

	box2d.b2MinV(v1, v2, aabb.lowerBound);
	box2d.b2MaxV(v1, v2, aabb.upperBound);

	var r = this.m_radius;
	aabb.lowerBound.SelfSubXY(r, r);
	aabb.upperBound.SelfAddXY(r, r);
}
box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2();
box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeMass 
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData 
 * @param {number} density 
 */
box2d.b2EdgeShape.prototype.ComputeMass = function (massData, density)
{
	massData.mass = 0;
	box2d.b2MidVV(this.m_vertex1, this.m_vertex2, massData.center);
	massData.I = 0;
}

/**
 * @return {void} 
 * @param {box2d.b2DistanceProxy} proxy 
 * @param {number} index 
 */
box2d.b2EdgeShape.prototype.SetupDistanceProxy = function (proxy, index)
{
	proxy.m_vertices = new Array(2);
	proxy.m_vertices[0] = this.m_vertex1;
	proxy.m_vertices[1] = this.m_vertex2;
	proxy.m_count = 2;
	proxy.m_radius = this.m_radius;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} normal
 * @param {number} offset
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} c
 */
box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
{
	c.SetZero();
	return 0;
}

/** 
 * Dump this shape to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2EdgeShape.prototype.Dump = function ()
{
	box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n");
	box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
	box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
	box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
	box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
	box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y);
	box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0);
	box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3);
}

/*
* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ChainShape');

goog.require('box2d.b2Shape');
goog.require('box2d.b2EdgeShape');

/** 
 * A chain shape is a free form sequence of line segments.
 * The chain has two-sided collision, so you can use inside and outside collision.
 * Therefore, you may use any winding order.
 * Since there may be many vertices, they are allocated using b2Alloc.
 * Connectivity information is used to create smooth collisions.
 * WARNING: The chain will not collide properly if there are self-intersections.
 * @export 
 * @constructor
 * @extends {box2d.b2Shape} 
 */
box2d.b2ChainShape = function ()
{
	goog.base(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius); // base class constructor

	this.m_prevVertex = new box2d.b2Vec2();
	this.m_nextVertex = new box2d.b2Vec2();
}

goog.inherits(box2d.b2ChainShape, box2d.b2Shape);

/** 
 * The vertices. Owned by this class. 
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2ChainShape.prototype.m_vertices = null;

/** 
 * The vertex count. 
 * @export 
 * @type {number}
 */
box2d.b2ChainShape.prototype.m_count = 0;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ChainShape.prototype.m_prevVertex = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ChainShape.prototype.m_nextVertex = null;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2ChainShape.prototype.m_hasPrevVertex = false;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2ChainShape.prototype.m_hasNextVertex = false;

/** 
 * Create a loop. This automatically adjusts connectivity. 
 * @export 
 * @return {box2d.b2ChainShape} 
 * @param {Array.<box2d.b2Vec2>} vertices an array of vertices, these are copied
 * @param {number=} count the vertex count
 */
box2d.b2ChainShape.prototype.CreateLoop = function (vertices, count)
{
	count = count || vertices.length;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_vertices === null && this.m_count === 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 3); }
	if (box2d.ENABLE_ASSERTS)
	{
		for (var i = 1; i < count; ++i)
		{
			var v1 = vertices[i-1];
			var v2 = vertices[i];
			// If the code crashes here, it means your vertices are too close together.
			box2d.b2Assert(box2d.b2DistanceSquaredVV(v1, v2) > box2d.b2_linearSlop * box2d.b2_linearSlop);
		}
	}

	this.m_count = count + 1;
	this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
	for (var i = 0; i < count; ++i)
	{
		this.m_vertices[i].Copy(vertices[i]);
	}
	this.m_vertices[count].Copy(this.m_vertices[0]);
	this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);
	this.m_nextVertex.Copy(this.m_vertices[1]);
	this.m_hasPrevVertex = true;
	this.m_hasNextVertex = true;
	return this;
}

/** 
 * Create a chain with isolated end vertices. 
 * @export 
 * @return {box2d.b2ChainShape} 
 * @param {Array.<box2d.b2Vec2>} vertices an array of vertices, these are copied
 * @param {number=} count the vertex count
 */
box2d.b2ChainShape.prototype.CreateChain = function (vertices, count)
{
	count = count || vertices.length;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_vertices === null && this.m_count === 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 2); }
	if (box2d.ENABLE_ASSERTS)
	{
		for (var i = 1; i < count; ++i)
		{
			var v1 = vertices[i-1];
			var v2 = vertices[i];
			// If the code crashes here, it means your vertices are too close together.
			box2d.b2Assert(box2d.b2DistanceSquaredVV(v1, v2) > box2d.b2_linearSlop * box2d.b2_linearSlop);
		}
	}

	this.m_count = count;
	this.m_vertices = box2d.b2Vec2.MakeArray(count);
	for (var i = 0; i < count; ++i)
	{
		this.m_vertices[i].Copy(vertices[i]);
	}
	this.m_hasPrevVertex = false;
	this.m_hasNextVertex = false;

	this.m_prevVertex.SetZero();
	this.m_nextVertex.SetZero();

	return this;
}

/**
 * Establish connectivity to a vertex that precedes the first vertex.
 * Don't call this for loops.
 * @export 
 * @return {box2d.b2ChainShape} 
 * @param {box2d.b2Vec2} prevVertex 
 */
box2d.b2ChainShape.prototype.SetPrevVertex = function (prevVertex)
{
	this.m_prevVertex.Copy(prevVertex);
	this.m_hasPrevVertex = true;
	return this;
}

/**
 * Establish connectivity to a vertex that follows the last vertex.
 * Don't call this for loops.
 * @export 
 * @return {box2d.b2ChainShape} 
 * @param {box2d.b2Vec2} nextVertex 
 */
box2d.b2ChainShape.prototype.SetNextVertex = function (nextVertex)
{
	this.m_nextVertex.Copy(nextVertex);
	this.m_hasNextVertex = true;
	return this;
}

/** 
 * Implement box2d.b2Shape. Vertices are cloned using b2Alloc. 
 * @export 
 * @return {box2d.b2Shape} 
 */
box2d.b2ChainShape.prototype.Clone = function ()
{
	return new box2d.b2ChainShape().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Shape} 
 * @param {box2d.b2Shape} other
 */
box2d.b2ChainShape.prototype.Copy = function (other)
{
	goog.base(this, 'Copy', other);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2ChainShape); }

	this.CreateChain(other.m_vertices, other.m_count);
	this.m_prevVertex.Copy(other.m_prevVertex);
	this.m_nextVertex.Copy(other.m_nextVertex);
	this.m_hasPrevVertex = other.m_hasPrevVertex;
	this.m_hasNextVertex = other.m_hasNextVertex;

	return this;
}

/** 
 * @see box2d.b2Shape::GetChildCount 
 * @export 
 * @return {number}
 */
box2d.b2ChainShape.prototype.GetChildCount = function ()
{
	// edge count = vertex count - 1
	return this.m_count - 1;
}

/** 
 * Get a child edge. 
 * @export 
 * @return {void} 
 * @param {box2d.b2EdgeShape} edge 
 * @param {number} index 
 */
box2d.b2ChainShape.prototype.GetChildEdge = function (edge, index)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count - 1); }
	edge.m_type = box2d.b2ShapeType.e_edgeShape;
	edge.m_radius = this.m_radius;

	edge.m_vertex1.Copy(this.m_vertices[index]);
	edge.m_vertex2.Copy(this.m_vertices[index + 1]);

	if (index > 0)
	{
		edge.m_vertex0.Copy(this.m_vertices[index - 1]);
		edge.m_hasVertex0 = true;
	}
	else
	{
		edge.m_vertex0.Copy(this.m_prevVertex);
		edge.m_hasVertex0 = this.m_hasPrevVertex;
	}

	if (index < this.m_count - 2)
	{
		edge.m_vertex3.Copy(this.m_vertices[index + 2]);
		edge.m_hasVertex3 = true;
	}
	else
	{
		edge.m_vertex3.Copy(this.m_nextVertex);
		edge.m_hasVertex3 = this.m_hasNextVertex;
	}
}


/**
 * This always return false.
 * @see box2d.b2Shape::TestPoint
 * @export 
 * @return {boolean}
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} p
 */
box2d.b2ChainShape.prototype.TestPoint = function (xf, p)
{
	return false;
}

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output 
 * @param {box2d.b2RayCastInput} input 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2ChainShape.prototype.RayCast = function (output, input, xf, childIndex)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(childIndex < this.m_count); }

	/** @type {box2d.b2EdgeShape} */ var edgeShape = box2d.b2ChainShape.s_edgeShape;

	edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);
	edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);

	return edgeShape.RayCast(output, input, xf, 0);
}
/**
 * @export 
 * @type {box2d.b2EdgeShape}
 */
box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape();

/** 
 * @see box2d.b2Shape::ComputeAABB 
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Transform} xf 
 * @param {number} childIndex 
 */
box2d.b2ChainShape.prototype.ComputeAABB = function (aabb, xf, childIndex)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(childIndex < this.m_count); }

	/** @type {box2d.b2Vec2} */ var vertexi1 = this.m_vertices[childIndex];
	/** @type {box2d.b2Vec2} */ var vertexi2 = this.m_vertices[(childIndex + 1) % this.m_count];

	/** @type {box2d.b2Vec2} */ var v1 = box2d.b2MulXV(xf, vertexi1, box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
	/** @type {box2d.b2Vec2} */ var v2 = box2d.b2MulXV(xf, vertexi2, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);

	box2d.b2MinV(v1, v2, aabb.lowerBound);
	box2d.b2MaxV(v1, v2, aabb.upperBound);
}
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2();
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeMass 
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData 
 * @param {number} density 
 */
box2d.b2ChainShape.prototype.ComputeMass = function (massData, density)
{
	massData.mass = 0;
	massData.center.SetZero();
	massData.I = 0;
}

/**
 * @return {void} 
 * @param {box2d.b2DistanceProxy} proxy 
 * @param {number} index 
 */
box2d.b2ChainShape.prototype.SetupDistanceProxy = function (proxy, index)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count); }

	proxy.m_buffer[0].Copy(this.m_vertices[index]);
	if (index + 1 < this.m_count)
	{
		proxy.m_buffer[1].Copy(this.m_vertices[index + 1]);
	}
	else
	{
		proxy.m_buffer[1].Copy(this.m_vertices[0]);
	}

	proxy.m_vertices = proxy.m_buffer;
	proxy.m_count = 2;
	proxy.m_radius = this.m_radius;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} normal
 * @param {number} offset
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} c
 */
box2d.b2ChainShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
{
	c.SetZero();
	return 0;
}

/** 
 * Dump this shape to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2ChainShape.prototype.Dump = function ()
{
	box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n");
	box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
	for (var i = 0; i < this.m_count; ++i)
	{
		box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
	}
	box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count);
	box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
	box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
	box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", (this.m_hasPrevVertex)?('true'):('false'));
	box2d.b2Log("    shape.m_hasNextVertex = %s;\n", (this.m_hasNextVertex)?('true'):('false'));
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ChainAndPolygonContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');
goog.require('box2d.b2CollideEdge');
goog.require('box2d.b2ChainShape');
goog.require('box2d.b2PolygonShape');

/** 
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2ChainAndPolygonContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact);

/** 
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2ChainAndPolygonContact.Create = function (allocator)
{
	return new box2d.b2ChainAndPolygonContact();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2ChainAndPolygonContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2ChainAndPolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_chainShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_polygonShape); }
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2ChainAndPolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2ChainShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }
	/*box2d.b2ChainShape*/ var chain = (shapeA instanceof box2d.b2ChainShape)? shapeA : null;
	/*box2d.b2EdgeShape*/ var edge = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
	chain.GetChildEdge(edge, this.m_indexA);
	box2d.b2CollideEdgeAndPolygon(
		manifold, 
		edge, xfA, 
		(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);
}
box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2CollidePolygon');

goog.require('box2d.b2Collision');

/**
 * Find the max separation between poly1 and poly2 using edge
 * normals from poly1.
 * @export
 * @return {number}
 * @param {Array.<number>} edgeIndex
 * @param {box2d.b2PolygonShape} poly1
 * @param {box2d.b2Transform} xf1
 * @param {box2d.b2PolygonShape} poly2
 * @param {box2d.b2Transform} xf2
 */
box2d.b2FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2)
{
	var /*int32*/ count1 = poly1.m_count;
	var /*int32*/ count2 = poly2.m_count;
	var /*const b2Vec2**/ n1s = poly1.m_normals;
	var /*const b2Vec2**/ v1s = poly1.m_vertices;
	var /*const b2Vec2**/ v2s = poly2.m_vertices;
	var /*b2Transform*/ xf = box2d.b2MulTXX(xf2, xf1, box2d.b2FindMaxSeparation.s_xf);

	var /*int32*/ bestIndex = 0;
	var /*float32*/ maxSeparation = -box2d.b2_maxFloat;
	for (var /*int32*/ i = 0; i < count1; ++i)
	{
		// Get poly1 normal in frame2.
		var /*b2Vec2*/ n = box2d.b2MulRV(xf.q, n1s[i], box2d.b2FindMaxSeparation.s_n);
		var /*b2Vec2*/ v1 = box2d.b2MulXV(xf, v1s[i], box2d.b2FindMaxSeparation.s_v1);

		// Find deepest point for normal i.
		var /*float32*/ si = box2d.b2_maxFloat;
		for (var /*int32*/ j = 0; j < count2; ++j)
		{
			var /*float32*/ sij = box2d.b2DotVV(n, box2d.b2SubVV(v2s[j], v1, box2d.b2Vec2.s_t0)); // b2Dot(n, v2s[j] - v1);
			if (sij < si)
			{
				si = sij;
			}
		}

		if (si > maxSeparation)
		{
			maxSeparation = si;
			bestIndex = i;
		}
	}

	edgeIndex[0] = bestIndex; // *edgeIndex = bestIndex;
	return maxSeparation;
}
box2d.b2FindMaxSeparation.s_xf = new box2d.b2Transform();
box2d.b2FindMaxSeparation.s_n = new box2d.b2Vec2();
box2d.b2FindMaxSeparation.s_v1 = new box2d.b2Vec2();

/**
 * @export
 * @return {void}
 * @param {Array.<box2d.b2ClipVertex>} c
 * @param {box2d.b2PolygonShape} poly1
 * @param {box2d.b2Transform} xf1
 * @param {number} edge1
 * @param {box2d.b2PolygonShape} poly2
 * @param {box2d.b2Transform} xf2
 */
box2d.b2FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2)
{
	var count1 = poly1.m_count;
	var normals1 = poly1.m_normals;

	var count2 = poly2.m_count;
	var vertices2 = poly2.m_vertices;
	var normals2 = poly2.m_normals;

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= edge1 && edge1 < count1); }

	// Get the normal of the reference edge in poly2's frame.
	var normal1 = box2d.b2MulTRV(xf2.q, box2d.b2MulRV(xf1.q, normals1[edge1], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1);

	// Find the incident edge on poly2.
	var index = 0;
	var minDot = box2d.b2_maxFloat;
	for (var i = 0; i < count2; ++i)
	{
		var dot = box2d.b2DotVV(normal1, normals2[i]);
		if (dot < minDot)
		{
			minDot = dot;
			index = i;
		}
	}

	// Build the clip vertices for the incident edge.
	var i1 = index;
	var i2 = (i1 + 1) % count2;

	var c0 = c[0];
	box2d.b2MulXV(xf2, vertices2[i1], c0.v);
	var cf0 = c0.id.cf;
	cf0.indexA = edge1;
	cf0.indexB = i1;
	cf0.typeA = box2d.b2ContactFeatureType.e_face;
	cf0.typeB = box2d.b2ContactFeatureType.e_vertex;

	var c1 = c[1];
	box2d.b2MulXV(xf2, vertices2[i2], c1.v);
	var cf1 = c1.id.cf;
	cf1.indexA = edge1;
	cf1.indexB = i2;
	cf1.typeA = box2d.b2ContactFeatureType.e_face;
	cf1.typeB = box2d.b2ContactFeatureType.e_vertex;
}
box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2();

/**
 * Find edge normal of max separation on A - return if separating axis is found
 * Find edge normal of max separation on B - return if separation axis is found
 * Choose reference edge as min(minA, minB)
 * Find incident edge
 * Clip
 * The normal points from 1 to 2
 * @export
 * @return {void}
 * @param {box2d.b2Manifold} manifold
 * @param {box2d.b2PolygonShape} polyA
 * @param {box2d.b2Transform} xfA
 * @param {box2d.b2PolygonShape} polyB
 * @param {box2d.b2Transform} xfB
 */
box2d.b2CollidePolygons = function (manifold, polyA, xfA, polyB, xfB)
{
	manifold.pointCount = 0;
	var totalRadius = polyA.m_radius + polyB.m_radius;

	var edgeA = box2d.b2CollidePolygons.s_edgeA; edgeA[0] = 0;
	var separationA = box2d.b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);
	if (separationA > totalRadius)
		return;

	var edgeB = box2d.b2CollidePolygons.s_edgeB; edgeB[0] = 0;
	var separationB = box2d.b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);
	if (separationB > totalRadius)
		return;

	var poly1; // reference polygon
	var poly2; // incident polygon
	var xf1, xf2;
	var edge1 = 0; // reference edge
	var flip = 0;
	var k_relativeTol = 0.98;
	var k_absoluteTol = 0.001;

	if (separationB > k_relativeTol * separationA + k_absoluteTol)
	{
		poly1 = polyB;
		poly2 = polyA;
		xf1 = xfB;
		xf2 = xfA;
		edge1 = edgeB[0];
		manifold.type = box2d.b2ManifoldType.e_faceB;
		flip = 1;
	}
	else
	{
		poly1 = polyA;
		poly2 = polyB;
		xf1 = xfA;
		xf2 = xfB;
		edge1 = edgeA[0];
		manifold.type = box2d.b2ManifoldType.e_faceA;
		flip = 0;
	}

	var incidentEdge = box2d.b2CollidePolygons.s_incidentEdge;
	box2d.b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

	var count1 = poly1.m_count;
	var vertices1 = poly1.m_vertices;

	var iv1 = edge1;
	var iv2 = (edge1 + 1) % count1;

	var local_v11 = vertices1[iv1];
	var local_v12 = vertices1[iv2];

	var localTangent = box2d.b2SubVV(local_v12, local_v11, box2d.b2CollidePolygons.s_localTangent);
	localTangent.Normalize();

	var localNormal = box2d.b2CrossVOne(localTangent, box2d.b2CollidePolygons.s_localNormal);
	var planePoint = box2d.b2MidVV(local_v11, local_v12, box2d.b2CollidePolygons.s_planePoint);

	var tangent = box2d.b2MulRV(xf1.q, localTangent, box2d.b2CollidePolygons.s_tangent);
	var normal = box2d.b2CrossVOne(tangent, box2d.b2CollidePolygons.s_normal);

	var v11 = box2d.b2MulXV(xf1, local_v11, box2d.b2CollidePolygons.s_v11);
	var v12 = box2d.b2MulXV(xf1, local_v12, box2d.b2CollidePolygons.s_v12);

	// Face offset.
	var frontOffset = box2d.b2DotVV(normal, v11);

	// Side offsets, extended by polytope skin thickness.
	var sideOffset1 = -box2d.b2DotVV(tangent, v11) + totalRadius;
	var sideOffset2 = box2d.b2DotVV(tangent, v12) + totalRadius;

	// Clip incident edge against extruded edge1 side edges.
	var clipPoints1 = box2d.b2CollidePolygons.s_clipPoints1;
	var clipPoints2 = box2d.b2CollidePolygons.s_clipPoints2;
	var np;

	// Clip to box side 1
	var ntangent = box2d.b2NegV(tangent, box2d.b2CollidePolygons.s_ntangent);
	np = box2d.b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);

	if (np < 2)
		return;

	// Clip to negative box side 1
	np = box2d.b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);

	if (np < 2)
	{
		return;
	}

	// Now clipPoints2 contains the clipped points.
	manifold.localNormal.Copy(localNormal);
	manifold.localPoint.Copy(planePoint);

	var pointCount = 0;
	for (var i = 0; i < box2d.b2_maxManifoldPoints; ++i)
	{
		var cv = clipPoints2[i];
		var separation = box2d.b2DotVV(normal, cv.v) - frontOffset;

		if (separation <= totalRadius)
		{
			var cp = manifold.points[pointCount];
			box2d.b2MulTXV(xf2, cv.v, cp.localPoint);
			cp.id.Copy(cv.id);
			if (flip)
			{
				// Swap features
				/** @type {box2d.b2ContactFeature} */ var cf = cp.id.cf;
				cp.id.cf.indexA = cf.indexB;
				cp.id.cf.indexB = cf.indexA;
				cp.id.cf.typeA = cf.typeB;
				cp.id.cf.typeB = cf.typeA;
			}
			++pointCount;
		}
	}

	manifold.pointCount = pointCount;
}
box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2();
box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2PolygonContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');
goog.require('box2d.b2CollidePolygon');

/**
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2PolygonContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2PolygonContact, box2d.b2Contact);

/**
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2PolygonContact.Create = function (allocator)
{
	return new box2d.b2PolygonContact();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2PolygonContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2PolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2PolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2PolygonShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }
	box2d.b2CollidePolygons(
		manifold, 
		(shapeA instanceof box2d.b2PolygonShape)? shapeA : null, xfA, 
		(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);
}

/*
* Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2CollideCircle');

goog.require('box2d.b2Collision');

/** 
 * Compute the collision manifold between two circles. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2CircleShape} circleA 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2CircleShape} circleB 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2CollideCircles = function (manifold, circleA, xfA, circleB, xfB)
{
	manifold.pointCount = 0;

	var pA = box2d.b2MulXV(xfA, circleA.m_p, box2d.b2CollideCircles.s_pA);
	var pB = box2d.b2MulXV(xfB, circleB.m_p, box2d.b2CollideCircles.s_pB);

	var distSqr = box2d.b2DistanceSquaredVV(pA, pB);
	var radius = circleA.m_radius + circleB.m_radius;
	if (distSqr > radius * radius)
	{
		return;
	}

	manifold.type = box2d.b2ManifoldType.e_circles;
	manifold.localPoint.Copy(circleA.m_p);
	manifold.localNormal.SetZero();
	manifold.pointCount = 1;

	manifold.points[0].localPoint.Copy(circleB.m_p);
	manifold.points[0].id.key = 0;
}
box2d.b2CollideCircles.s_pA = new box2d.b2Vec2();
box2d.b2CollideCircles.s_pB = new box2d.b2Vec2();

/** 
 * Compute the collision manifold between a polygon and a 
 * circle. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold
 * @param {box2d.b2PolygonShape} polygonA
 * @param {box2d.b2Transform} xfA
 * @param {box2d.b2CircleShape} circleB
 * @param {box2d.b2Transform} xfB
 */
box2d.b2CollidePolygonAndCircle = function (manifold, polygonA, xfA, circleB, xfB)
{
	manifold.pointCount = 0;

	// Compute circle position in the frame of the polygon.
	var c = box2d.b2MulXV(xfB, circleB.m_p, box2d.b2CollidePolygonAndCircle.s_c);
	var cLocal = box2d.b2MulTXV(xfA, c, box2d.b2CollidePolygonAndCircle.s_cLocal);

	// Find the min separating edge.
	var normalIndex = 0;
	var separation = (-box2d.b2_maxFloat);
	var radius = polygonA.m_radius + circleB.m_radius;
	var vertexCount = polygonA.m_count;
	var vertices = polygonA.m_vertices;
	var normals = polygonA.m_normals;

	for (var i = 0; i < vertexCount; ++i)
	{
		var s = box2d.b2DotVV(normals[i], box2d.b2SubVV(cLocal, vertices[i], box2d.b2Vec2.s_t0));

		if (s > radius)
		{
			// Early out.
			return;
		}

		if (s > separation)
		{
			separation = s;
			normalIndex = i;
		}
	}

	// Vertices that subtend the incident face.
	var vertIndex1 = normalIndex;
	var vertIndex2 = (vertIndex1 + 1) % vertexCount;
	var v1 = vertices[vertIndex1];
	var v2 = vertices[vertIndex2];

	// If the center is inside the polygon ...
	if (separation < box2d.b2_epsilon)
	{
		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_faceA;
		manifold.localNormal.Copy(normals[normalIndex]);
		box2d.b2MidVV(v1, v2, manifold.localPoint);
		manifold.points[0].localPoint.Copy(circleB.m_p);
		manifold.points[0].id.key = 0;
		return;
	}

	// Compute barycentric coordinates
	var u1 = box2d.b2DotVV(box2d.b2SubVV(cLocal, v1, box2d.b2Vec2.s_t0), box2d.b2SubVV(v2, v1, box2d.b2Vec2.s_t1));
	var u2 = box2d.b2DotVV(box2d.b2SubVV(cLocal, v2, box2d.b2Vec2.s_t0), box2d.b2SubVV(v1, v2, box2d.b2Vec2.s_t1));
	if (u1 <= 0)
	{
		if (box2d.b2DistanceSquaredVV(cLocal, v1) > radius * radius)
		{
			return;
		}

		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_faceA;
		box2d.b2SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();
		manifold.localPoint.Copy(v1);
		manifold.points[0].localPoint.Copy(circleB.m_p);
		manifold.points[0].id.key = 0;
	}
	else if (u2 <= 0)
	{
		if (box2d.b2DistanceSquaredVV(cLocal, v2) > radius * radius)
		{
			return;
		}

		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_faceA;
		box2d.b2SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();
		manifold.localPoint.Copy(v2);
		manifold.points[0].localPoint.Copy(circleB.m_p);
		manifold.points[0].id.key = 0;
	}
	else
	{
		var faceCenter = box2d.b2MidVV(v1, v2, box2d.b2CollidePolygonAndCircle.s_faceCenter);
		separation = box2d.b2DotVV(box2d.b2SubVV(cLocal, faceCenter, box2d.b2Vec2.s_t1), normals[vertIndex1]);
		if (separation > radius)
		{
			return;
		}

		manifold.pointCount = 1;
		manifold.type = box2d.b2ManifoldType.e_faceA;
		manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();
		manifold.localPoint.Copy(faceCenter);
		manifold.points[0].localPoint.Copy(circleB.m_p);
		manifold.points[0].id.key = 0;
	}
}
box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2();
box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2();
box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2CircleContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');
goog.require('box2d.b2CollideCircle');

/**
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2CircleContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2CircleContact, box2d.b2Contact);

/**
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2CircleContact.Create = function (allocator)
{
	return new box2d.b2CircleContact();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2CircleContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {number} indexA 
 * @param {box2d.b2Fixture} fixtureB
 * @param {number} indexB 
 */
box2d.b2CircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2CircleContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2CircleShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }
	box2d.b2CollideCircles(
		manifold, 
		(shapeA instanceof box2d.b2CircleShape)? shapeA : null, xfA, 
		(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ChainAndCircleContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');
goog.require('box2d.b2CollideEdge');

/** 
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2ChainAndCircleContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact);

/** 
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2ChainAndCircleContact.Create = function (allocator)
{
	return new box2d.b2ChainAndCircleContact();
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2ChainAndCircleContact.Destroy = function (contact, allocator)
{
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2ChainAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_chainShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2ChainAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2ChainShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }
	/*box2d.b2ChainShape*/ var chain = (shapeA instanceof box2d.b2ChainShape)? shapeA : null;
	/*box2d.b2EdgeShape*/ var edge = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
	chain.GetChildEdge(edge, this.m_indexA);
	box2d.b2CollideEdgeAndCircle(
		manifold, 
		edge, xfA, 
		(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);
}
box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2EdgeAndCircleContact');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');
goog.require('box2d.b2CollideEdge');

/**
 * @export 
 * @constructor 
 * @extends {box2d.b2Contact} 
 */
box2d.b2EdgeAndCircleContact = function ()
{
	goog.base(this); // base class constructor
};

goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact);

/**
 * @export 
 * @return {box2d.b2Contact} 
 * @param allocator 
 */
box2d.b2EdgeAndCircleContact.Create = function (allocator)
{
	return new box2d.b2EdgeAndCircleContact();
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param allocator 
 */
box2d.b2EdgeAndCircleContact.Destroy = function (contact, allocator)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixtureA
 * @param {box2d.b2Fixture} fixtureB
 */
box2d.b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)
{
	goog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_edgeShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Manifold} manifold 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB 
 */
box2d.b2EdgeAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)
{
	var shapeA = this.m_fixtureA.GetShape();
	var shapeB = this.m_fixtureB.GetShape();
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2EdgeShape); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }
	box2d.b2CollideEdgeAndCircle(
		manifold, 
		(shapeA instanceof box2d.b2EdgeShape)? shapeA : null, xfA, 
		(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);
}

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ContactSolver');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Collision');
goog.require('box2d.b2CircleContact');
goog.require('box2d.b2PolygonAndCircleContact');
goog.require('box2d.b2PolygonContact');
goog.require('box2d.b2EdgeAndCircleContact');
goog.require('box2d.b2EdgeAndPolygonContact');
goog.require('box2d.b2ChainAndCircleContact');
goog.require('box2d.b2ChainAndPolygonContact');

/**
 * @export 
 * @constructor
 */
box2d.b2VelocityConstraintPoint = function ()
{
	this.rA = new box2d.b2Vec2();
	this.rB = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2VelocityConstraintPoint.prototype.rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2VelocityConstraintPoint.prototype.rB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2VelocityConstraintPoint.prototype.normalMass = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0;

/**
 * @export 
 * @return {Array.<box2d.b2VelocityConstraintPoint>}
 * @param {number} length 
 */
box2d.b2VelocityConstraintPoint.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2VelocityConstraintPoint(); });
}

/**
 * @export 
 * @constructor
 */
box2d.b2ContactVelocityConstraint = function ()
{
	this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints);
	this.normal = new box2d.b2Vec2();
	this.tangent = new box2d.b2Vec2();
	this.normalMass = new box2d.b2Mat22();
	this.K = new box2d.b2Mat22();
}

/**
 * @export 
 * @type {Array.<box2d.b2VelocityConstraintPoint>}
 */
box2d.b2ContactVelocityConstraint.prototype.points = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactVelocityConstraint.prototype.normal = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactVelocityConstraint.prototype.tangent = null; // compute from normal
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2ContactVelocityConstraint.prototype.normalMass = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2ContactVelocityConstraint.prototype.K = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.indexB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.invIB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.friction = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.restitution = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.pointCount = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0;

/**
 * @export 
 * @return {Array.<box2d.b2ContactVelocityConstraint>}
 * @param {number} length 
 */
box2d.b2ContactVelocityConstraint.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2ContactVelocityConstraint(); } );
}

/**
 * @export 
 * @constructor
 */
box2d.b2ContactPositionConstraint = function ()
{
	this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);
	this.localNormal = new box2d.b2Vec2();
	this.localPoint = new box2d.b2Vec2();
	this.localCenterA = new box2d.b2Vec2();
	this.localCenterB = new box2d.b2Vec2();
};

/**
 * @export 
 * @type {Array.<box2d.b2Vec2>}
 */
box2d.b2ContactPositionConstraint.prototype.localPoints = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactPositionConstraint.prototype.localNormal = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactPositionConstraint.prototype.localPoint = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.indexB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.invMassB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactPositionConstraint.prototype.localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2ContactPositionConstraint.prototype.localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.invIB = 0;
/**
 * @export 
 * @type {box2d.b2ManifoldType}
 */
box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.radiusA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.radiusB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactPositionConstraint.prototype.pointCount = 0;

/**
 * @export 
 * @return {Array.<box2d.b2ContactPositionConstraint>}
 * @param {number} length 
 */
box2d.b2ContactPositionConstraint.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2ContactPositionConstraint(); } );
}

/**
 * @export 
 * @constructor
 */
box2d.b2ContactSolverDef = function ()
{
	this.step = new box2d.b2TimeStep();
};

/**
 * @export 
 * @type {box2d.b2TimeStep}
 */
box2d.b2ContactSolverDef.prototype.step = null;
/**
 * @export 
 * @type {Array.<box2d.b2Contact>}
 */
box2d.b2ContactSolverDef.prototype.contacts = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactSolverDef.prototype.count = 0;
/**
 * @export 
 * @type {Array.<box2d.b2Position>}
 */
box2d.b2ContactSolverDef.prototype.positions = null;
/**
 * @export 
 * @type {Array.<box2d.b2Velocity>}
 */
box2d.b2ContactSolverDef.prototype.velocities = null;
/**
 * @export 
 * @type {*}
 */
box2d.b2ContactSolverDef.prototype.allocator = null;

/**
 * @export 
 * @constructor
 */
box2d.b2ContactSolver = function ()
{
	this.m_step = new box2d.b2TimeStep();
	this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024); // TODO: b2Settings
	this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024); // TODO: b2Settings
}

/**
 * @export 
 * @type {box2d.b2TimeStep}
 */
box2d.b2ContactSolver.prototype.m_step = null;
/**
 * @export 
 * @type {Array.<box2d.b2Position>}
 */
box2d.b2ContactSolver.prototype.m_positions = null;
/**
 * @export 
 * @type {Array.<box2d.b2Velocity>}
 */
box2d.b2ContactSolver.prototype.m_velocities = null;
/**
 * @export 
 * @type {*}
 */
box2d.b2ContactSolver.prototype.m_allocator = null;
/**
 * @export 
 * @type {Array.<box2d.b2ContactPositionConstraint>}
 */
box2d.b2ContactSolver.prototype.m_positionConstraints = null;
/**
 * @export 
 * @type {Array.<box2d.b2ContactVelocityConstraint>}
 */
box2d.b2ContactSolver.prototype.m_velocityConstraints = null;
/**
 * @export 
 * @type {Array.<box2d.b2Contact>}
 */
box2d.b2ContactSolver.prototype.m_contacts = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactSolver.prototype.m_count = 0;

/** 
 * @export 
 * @return {box2d.b2ContactSolver} 
 * @param {box2d.b2ContactSolverDef} def 
 */
box2d.b2ContactSolver.prototype.Initialize = function (def)
{
	this.m_step.Copy(def.step);
	this.m_allocator = def.allocator;
	this.m_count = def.count;
	// TODO:
	if (this.m_positionConstraints.length < this.m_count)
	{
		var new_length = box2d.b2Max(this.m_positionConstraints.length * 2, this.m_count);

		if (box2d.DEBUG)
		{
			window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + new_length);
		}

		while (this.m_positionConstraints.length < new_length)
		{
			this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint();
		}
	}
	// TODO:
	if (this.m_velocityConstraints.length < this.m_count)
	{
		var new_length = box2d.b2Max(this.m_velocityConstraints.length * 2, this.m_count);

		if (box2d.DEBUG)
		{
			window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + new_length);
		}

		while (this.m_velocityConstraints.length < new_length)
		{
			this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint();
		}
	}
	this.m_positions = def.positions;
	this.m_velocities = def.velocities;
	this.m_contacts = def.contacts;

	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2Contact} */ var contact;

	/** @type {box2d.b2Fixture} */ var fixtureA;
	/** @type {box2d.b2Fixture} */ var fixtureB;
	/** @type {box2d.b2Shape} */ var shapeA;
	/** @type {box2d.b2Shape} */ var shapeB;
	/** @type {number} */ var radiusA;
	/** @type {number} */ var radiusB;
	/** @type {box2d.b2Body} */ var bodyA;
	/** @type {box2d.b2Body} */ var bodyB;
	/** @type {box2d.b2Manifold} */ var manifold;

	/** @type {number} */ var pointCount;

	/** @type {box2d.b2ContactVelocityConstraint} */ var vc;
	/** @type {box2d.b2ContactPositionConstraint} */ var pc;

	/** @type {box2d.b2ManifoldPoint} */ var cp;
	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;

	// Initialize position independent portions of the constraints.
	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		contact = this.m_contacts[i];

		fixtureA = contact.m_fixtureA;
		fixtureB = contact.m_fixtureB;
		shapeA = fixtureA.GetShape();
		shapeB = fixtureB.GetShape();
		radiusA = shapeA.m_radius;
		radiusB = shapeB.m_radius;
		bodyA = fixtureA.GetBody();
		bodyB = fixtureB.GetBody();
		manifold = contact.GetManifold();

		pointCount = manifold.pointCount;
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pointCount > 0); }

		vc = this.m_velocityConstraints[i];
		vc.friction = contact.m_friction;
		vc.restitution = contact.m_restitution;
		vc.tangentSpeed = contact.m_tangentSpeed;
		vc.indexA = bodyA.m_islandIndex;
		vc.indexB = bodyB.m_islandIndex;
		vc.invMassA = bodyA.m_invMass;
		vc.invMassB = bodyB.m_invMass;
		vc.invIA = bodyA.m_invI;
		vc.invIB = bodyB.m_invI;
		vc.contactIndex = i;
		vc.pointCount = pointCount;
		vc.K.SetZero();
		vc.normalMass.SetZero();

		pc = this.m_positionConstraints[i];
		pc.indexA = bodyA.m_islandIndex;
		pc.indexB = bodyB.m_islandIndex;
		pc.invMassA = bodyA.m_invMass;
		pc.invMassB = bodyB.m_invMass;
		pc.localCenterA.Copy(bodyA.m_sweep.localCenter);
		pc.localCenterB.Copy(bodyB.m_sweep.localCenter);
		pc.invIA = bodyA.m_invI;
		pc.invIB = bodyB.m_invI;
		pc.localNormal.Copy(manifold.localNormal);
		pc.localPoint.Copy(manifold.localPoint);
		pc.pointCount = pointCount;
		pc.radiusA = radiusA;
		pc.radiusB = radiusB;
		pc.type = manifold.type;

		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			cp = manifold.points[j];
			vcp = vc.points[j];
	
			if (this.m_step.warmStarting)
			{
				vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;
				vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;
			}
			else
			{
				vcp.normalImpulse = 0;
				vcp.tangentImpulse = 0;
			}

			vcp.rA.SetZero();
			vcp.rB.SetZero();
			vcp.normalMass = 0;
			vcp.tangentMass = 0;
			vcp.velocityBias = 0;

			pc.localPoints[j].Copy(cp.localPoint);
		}
	}

	return this;
}

/**
 * Initialize position dependent portions of the velocity 
 * constraints. 
 * @export 
 * @return {void} 
 */
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function ()
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactVelocityConstraint} */ var vc;
	/** @type {box2d.b2ContactPositionConstraint} */ var pc;

	/** @type {number} */ var radiusA;
	/** @type {number} */ var radiusB;
	/** @type {box2d.b2Manifold} */ var manifold;

	/** @type {number} */ var indexA;
	/** @type {number} */ var indexB;

	/** @type {number} */ var mA;
	/** @type {number} */ var mB;
	/** @type {number} */ var iA;
	/** @type {number} */ var iB;
	/** @type {box2d.b2Vec2} */ var localCenterA;
	/** @type {box2d.b2Vec2} */ var localCenterB;

	/** @type {box2d.b2Vec2} */ var cA;
	/** @type {number} */ var aA;
	/** @type {box2d.b2Vec2} */ var vA;
	/** @type {number} */ var wA;

	/** @type {box2d.b2Vec2} */ var cB;
	/** @type {number} */ var aB;
	/** @type {box2d.b2Vec2} */ var vB;
	/** @type {number} */ var wB;

	/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB;

	/** @type {box2d.b2WorldManifold} */ var worldManifold = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;

	/** @type {number} */ var pointCount;

	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;

	/** @type {number} */ var rnA;
	/** @type {number} */ var rnB;

	/** @type {number} */ var kNormal;

	/** @type {box2d.b2Vec2} */ var tangent;

	/** @type {number} */ var rtA;
	/** @type {number} */ var rtB;

	/** @type {number} */ var kTangent;

	/** @type {number} */ var vRel;

	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp1;
	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp2;

	/** @type {number} */ var rn1A;
	/** @type {number} */ var rn1B;
	/** @type {number} */ var rn2A;
	/** @type {number} */ var rn2B;

	/** @type {number} */ var k11;
	/** @type {number} */ var k22;
	/** @type {number} */ var k12;

	/** @type {number} */ var k_maxConditionNumber = 1000;

	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		vc = this.m_velocityConstraints[i];
		pc = this.m_positionConstraints[i];

		radiusA = pc.radiusA;
		radiusB = pc.radiusB;
		manifold = this.m_contacts[vc.contactIndex].GetManifold();

		indexA = vc.indexA;
		indexB = vc.indexB;

		mA = vc.invMassA;
		mB = vc.invMassB;
		iA = vc.invIA;
		iB = vc.invIB;
		localCenterA = pc.localCenterA;
		localCenterB = pc.localCenterB;

		cA = this.m_positions[indexA].c;
		aA = this.m_positions[indexA].a;
		vA = this.m_velocities[indexA].v;
		wA = this.m_velocities[indexA].w;

		cB = this.m_positions[indexB].c;
		aB = this.m_positions[indexB].a;
		vB = this.m_velocities[indexB].v;
		wB = this.m_velocities[indexB].w;

		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(manifold.pointCount > 0); }

		xfA.q.SetAngleRadians(aA);
		xfB.q.SetAngleRadians(aB);
		box2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);
		box2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);

		worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);

		vc.normal.Copy(worldManifold.normal);
		box2d.b2CrossVOne(vc.normal, vc.tangent); // compute from normal

		pointCount = vc.pointCount;
		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			vcp = vc.points[j];

//			vcp->rA = worldManifold.points[j] - cA;
			box2d.b2SubVV(worldManifold.points[j], cA, vcp.rA);
//			vcp->rB = worldManifold.points[j] - cB;
			box2d.b2SubVV(worldManifold.points[j], cB, vcp.rB);

			rnA = box2d.b2CrossVV(vcp.rA, vc.normal);
			rnB = box2d.b2CrossVV(vcp.rB, vc.normal);

			kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

			vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;

//			b2Vec2 tangent = b2Cross(vc->normal, 1.0f);
			tangent = vc.tangent; // precomputed from normal

			rtA = box2d.b2CrossVV(vcp.rA, tangent);
			rtB = box2d.b2CrossVV(vcp.rB, tangent);

			kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;

			vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;

			// Setup a velocity bias for restitution.
			vcp.velocityBias = 0;
//			float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));
			vRel = box2d.b2DotVV(
				vc.normal, 
				box2d.b2SubVV(
					box2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0),
					box2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), 
					box2d.b2Vec2.s_t0));
			if (vRel < (-box2d.b2_velocityThreshold))
			{
				vcp.velocityBias += (-vc.restitution * vRel);
			}
		}

		// If we have two points, then prepare the block solver.
		if (vc.pointCount === 2)
		{
			vcp1 = vc.points[0];
			vcp2 = vc.points[1];

			rn1A = box2d.b2CrossVV(vcp1.rA, vc.normal);
			rn1B = box2d.b2CrossVV(vcp1.rB, vc.normal);
			rn2A = box2d.b2CrossVV(vcp2.rA, vc.normal);
			rn2B = box2d.b2CrossVV(vcp2.rB, vc.normal);

			k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
			k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
			k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;

			// Ensure a reasonable condition number.
//			float32 k_maxConditionNumber = 1000.0f;
			if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
			{
				// K is safe to invert.
				vc.K.ex.SetXY(k11, k12);
				vc.K.ey.SetXY(k12, k22);
				vc.K.GetInverse(vc.normalMass);
			}
			else
			{
				// The constraints are redundant, just use one.
				// TODO_ERIN use deepest?
				vc.pointCount = 1;
			}
		}
	}
}
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold();

/** 
 * @export 
 * @return {void} 
 */
box2d.b2ContactSolver.prototype.WarmStart = function ()
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactVelocityConstraint} */ var vc;

	/** @type {number} */ var indexA;
	/** @type {number} */ var indexB;
	/** @type {number} */ var mA;
	/** @type {number} */ var iA;
	/** @type {number} */ var mB;
	/** @type {number} */ var iB;
	/** @type {number} */ var pointCount;

	/** @type {box2d.b2Vec2} */ var vA;
	/** @type {number} */ var wA;
	/** @type {box2d.b2Vec2} */ var vB;
	/** @type {number} */ var wB;

	/** @type {box2d.b2Vec2} */ var normal;
	/** @type {box2d.b2Vec2} */ var tangent;

	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;
	/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.WarmStart.s_P;

	// Warm start.
	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		vc = this.m_velocityConstraints[i];

		indexA = vc.indexA;
		indexB = vc.indexB;
		mA = vc.invMassA;
		iA = vc.invIA;
		mB = vc.invMassB;
		iB = vc.invIB;
		pointCount = vc.pointCount;

		vA = this.m_velocities[indexA].v;
		wA = this.m_velocities[indexA].w;
		vB = this.m_velocities[indexB].v;
		wB = this.m_velocities[indexB].w;

		normal = vc.normal;
//		b2Vec2 tangent = b2Cross(normal, 1.0f);
		tangent = vc.tangent; // precomputed from normal

		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			vcp = vc.points[j];
//			b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;
			box2d.b2AddVV(
				box2d.b2MulSV(vcp.normalImpulse, normal, box2d.b2Vec2.s_t0), 
				box2d.b2MulSV(vcp.tangentImpulse, tangent, box2d.b2Vec2.s_t1), 
				P);
//			wA -= iA * b2Cross(vcp->rA, P);
			wA -= iA * box2d.b2CrossVV(vcp.rA, P);
//			vA -= mA * P;
			vA.SelfMulSub(mA, P);
//			wB += iB * b2Cross(vcp->rB, P);
			wB += iB * box2d.b2CrossVV(vcp.rB, P);
//			vB += mB * P;
			vB.SelfMulAdd(mB, P);
		}

//		this.m_velocities[indexA].v = vA;
		this.m_velocities[indexA].w = wA;
//		this.m_velocities[indexB].v = vB;
		this.m_velocities[indexB].w = wB;
	}
}
box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {void} 
 */
box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function ()
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactVelocityConstraint} */ var vc;
	/** @type {number} */ var indexA;
	/** @type {number} */ var indexB;
	/** @type {number} */ var mA;
	/** @type {number} */ var iA;
	/** @type {number} */ var mB;
	/** @type {number} */ var iB;
	/** @type {number} */ var pointCount;
	/** @type {box2d.b2Vec2} */ var vA;
	/** @type {number} */ var wA;
	/** @type {box2d.b2Vec2} */ var vB;
	/** @type {number} */ var wB;
	/** @type {box2d.b2Vec2} */ var normal;
	/** @type {box2d.b2Vec2} */ var tangent;
	/** @type {number} */ var friction;

	/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;

	/** @type {box2d.b2Vec2} */ var dv = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv;
	/** @type {box2d.b2Vec2} */ var dv1 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1;
	/** @type {box2d.b2Vec2} */ var dv2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2;

	/** @type {number} */ var vt;
	/** @type {number} */ var vn;
	/** @type {number} */ var lambda;

	/** @type {number} */ var maxFriction;
	/** @type {number} */ var newImpulse;

	/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P;

	/** @type {box2d.b2VelocityConstraintPoint} */ var cp1;
	/** @type {box2d.b2VelocityConstraintPoint} */ var cp2;

	/** @type {box2d.b2Vec2} */ var a = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a;
	/** @type {box2d.b2Vec2} */ var b = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b;
	/** @type {number} */ var vn1;
	/** @type {number} */ var vn2;

	/** @type {box2d.b2Vec2} */ var x = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x;
	/** @type {box2d.b2Vec2} */ var d = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d;
	/** @type {box2d.b2Vec2} */ var P1 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1;
	/** @type {box2d.b2Vec2} */ var P2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2;
	/** @type {box2d.b2Vec2} */ var P1P2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;

	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		vc = this.m_velocityConstraints[i];

		indexA = vc.indexA;
		indexB = vc.indexB;
		mA = vc.invMassA;
		iA = vc.invIA;
		mB = vc.invMassB;
		iB = vc.invIB;
		pointCount = vc.pointCount;

		vA = this.m_velocities[indexA].v;
		wA = this.m_velocities[indexA].w;
		vB = this.m_velocities[indexB].v;
		wB = this.m_velocities[indexB].w;

//		b2Vec2 normal = vc->normal;
		normal = vc.normal;
//		b2Vec2 tangent = b2Cross(normal, 1.0f);
		tangent = vc.tangent; // precomputed from normal
		friction = vc.friction;

		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pointCount === 1 || pointCount === 2); }

		// Solve tangent constraints first because non-penetration is more important
		// than friction.
		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			vcp = vc.points[j];

			// Relative velocity at contact
//			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
			box2d.b2SubVV(
				box2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), 
				dv);

			// Compute tangent force
//			float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;
			vt = box2d.b2DotVV(dv, tangent) - vc.tangentSpeed;
			lambda = vcp.tangentMass * (-vt);

			// box2d.b2Clamp the accumulated force
			maxFriction = friction * vcp.normalImpulse;
			newImpulse = box2d.b2Clamp(vcp.tangentImpulse + lambda, (-maxFriction), maxFriction);
			lambda = newImpulse - vcp.tangentImpulse;
			vcp.tangentImpulse = newImpulse;

			// Apply contact impulse
//			b2Vec2 P = lambda * tangent;
			box2d.b2MulSV(lambda, tangent, P);

//			vA -= mA * P;
			vA.SelfMulSub(mA, P);
//			wA -= iA * b2Cross(vcp->rA, P);
			wA -= iA * box2d.b2CrossVV(vcp.rA, P);

//			vB += mB * P;
			vB.SelfMulAdd(mB, P);
//			wB += iB * b2Cross(vcp->rB, P);
			wB += iB * box2d.b2CrossVV(vcp.rB, P);
		}

		// Solve normal constraints
		if (vc.pointCount === 1)
		{
			vcp = vc.points[0];

			// Relative velocity at contact
//			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
			box2d.b2SubVV(
				box2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), 
				dv);

			// Compute normal impulse
//			float32 vn = b2Dot(dv, normal);
			vn = box2d.b2DotVV(dv, normal);
			lambda = (-vcp.normalMass * (vn - vcp.velocityBias));

			// box2d.b2Clamp the accumulated impulse
//			float32 newImpulse = box2d.b2Max(vcp->normalImpulse + lambda, 0.0f);
			newImpulse = box2d.b2Max(vcp.normalImpulse + lambda, 0);
			lambda = newImpulse - vcp.normalImpulse;
			vcp.normalImpulse = newImpulse;

			// Apply contact impulse
//			b2Vec2 P = lambda * normal;
			box2d.b2MulSV(lambda, normal, P);
//			vA -= mA * P;
			vA.SelfMulSub(mA, P);
//			wA -= iA * b2Cross(vcp->rA, P);
			wA -= iA * box2d.b2CrossVV(vcp.rA, P);

//			vB += mB * P;
			vB.SelfMulAdd(mB, P);
//			wB += iB * b2Cross(vcp->rB, P);
			wB += iB * box2d.b2CrossVV(vcp.rB, P);
		}
		else
		{
			// Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).
			// Build the mini LCP for this contact patch
			//
			// vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2
			//
			// A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
			// b = vn0 - velocityBias
			//
			// The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i
			// implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases
			// vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be tested. The first valid
			// solution that satisfies the problem is chosen.
			// 
			// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires
			// that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).
			//
			// Substitute:
			// 
			// x = a + d
			// 
			// a := old total impulse
			// x := new total impulse
			// d := incremental impulse 
			//
			// For the current iteration we extend the formula for the incremental impulse
			// to compute the new total impulse:
			//
			// vn = A * d + b
			//    = A * (x - a) + b
			//    = A * x + b - A * a
			//    = A * x + b'
			// b' = b - A * a;

			cp1 = vc.points[0];
			cp2 = vc.points[1];

//			b2Vec2 a(cp1->normalImpulse, cp2->normalImpulse);
			a.SetXY(cp1.normalImpulse, cp2.normalImpulse);
			if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(a.x >= 0 && a.y >= 0); }

			// Relative velocity at contact
//			b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
			box2d.b2SubVV(
				box2d.b2AddVCrossSV(vB, wB, cp1.rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVCrossSV(vA, wA, cp1.rA, box2d.b2Vec2.s_t1), 
				dv1);
//			b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
			box2d.b2SubVV(
				box2d.b2AddVCrossSV(vB, wB, cp2.rB, box2d.b2Vec2.s_t0), 
				box2d.b2AddVCrossSV(vA, wA, cp2.rA, box2d.b2Vec2.s_t1), 
				dv2);

			// Compute normal velocity
//			float32 vn1 = b2Dot(dv1, normal);
			vn1 = box2d.b2DotVV(dv1, normal);
//			float32 vn2 = b2Dot(dv2, normal);
			vn2 = box2d.b2DotVV(dv2, normal);

//			b2Vec2 b;
			b.x = vn1 - cp1.velocityBias;
			b.y = vn2 - cp2.velocityBias;

			// Compute b'
//			b -= b2Mul(vc->K, a);
			b.SelfSub(box2d.b2MulMV(vc.K, a, box2d.b2Vec2.s_t0));

/*
#if B2_DEBUG_SOLVER === 1
			var k_errorTol = 0.001;
#endif
*/

			for (;;)
			{
				//
				// Case 1: vn = 0
				//
				// 0 = A * x + b'
				//
				// Solve for x:
				//
				// x = - inv(A) * b'
				//
//				b2Vec2 x = - b2Mul(vc->normalMass, b);
				box2d.b2MulMV(vc.normalMass, b, x).SelfNeg();

				if (x.x >= 0 && x.y >= 0)
				{
					// Get the incremental impulse
//					b2Vec2 d = x - a;
					box2d.b2SubVV(x, a, d);

					// Apply incremental impulse
//					b2Vec2 P1 = d.x * normal;
					box2d.b2MulSV(d.x, normal, P1);
//					b2Vec2 P2 = d.y * normal;
					box2d.b2MulSV(d.y, normal, P2);
					box2d.b2AddVV(P1, P2, P1P2);
//					vA -= mA * (P1 + P2);
					vA.SelfMulSub(mA, P1P2);
//					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
					wA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));

//					vB += mB * (P1 + P2);
					vB.SelfMulAdd(mB, P1P2);
//					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
					wB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));

					// Accumulate
					cp1.normalImpulse = x.x;
					cp2.normalImpulse = x.y;

/*
#if B2_DEBUG_SOLVER === 1
					// Postconditions
					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);

					// Compute normal velocity
					vn1 = b2Dot(dv1, normal);
					vn2 = b2Dot(dv2, normal);

					if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn1 - cp1->velocityBias) < k_errorTol); }
					if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn2 - cp2->velocityBias) < k_errorTol); }
#endif
*/
					break;
				}

				//
				// Case 2: vn1 = 0 and x2 = 0
				//
				//   0 = a11 * x1 + a12 * 0 + b1' 
				// vn2 = a21 * x1 + a22 * 0 + b2'
				//
				x.x = (-cp1.normalMass * b.x);
				x.y = 0;
				vn1 = 0;
				vn2 = vc.K.ex.y * x.x + b.y;

				if (x.x >= 0 && vn2 >= 0)
				{
					// Get the incremental impulse
//					b2Vec2 d = x - a;
					box2d.b2SubVV(x, a, d);

					// Apply incremental impulse
//					b2Vec2 P1 = d.x * normal;
					box2d.b2MulSV(d.x, normal, P1);
//					b2Vec2 P2 = d.y * normal;
					box2d.b2MulSV(d.y, normal, P2);
					box2d.b2AddVV(P1, P2, P1P2);
//					vA -= mA * (P1 + P2);
					vA.SelfMulSub(mA, P1P2);
//					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
					wA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));

//					vB += mB * (P1 + P2);
					vB.SelfMulAdd(mB, P1P2);
//					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
					wB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));

					// Accumulate
					cp1.normalImpulse = x.x;
					cp2.normalImpulse = x.y;

/*
#if B2_DEBUG_SOLVER === 1
					// Postconditions
					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);

					// Compute normal velocity
					vn1 = b2Dot(dv1, normal);

					if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn1 - cp1->velocityBias) < k_errorTol); }
#endif
*/
					break;
				}


				//
				// Case 3: vn2 = 0 and x1 = 0
				//
				// vn1 = a11 * 0 + a12 * x2 + b1' 
				//   0 = a21 * 0 + a22 * x2 + b2'
				//
				x.x = 0;
				x.y = (-cp2.normalMass * b.y);
				vn1 = vc.K.ey.x * x.y + b.x;
				vn2 = 0;

				if (x.y >= 0 && vn1 >= 0)
				{
					// Resubstitute for the incremental impulse
//					b2Vec2 d = x - a;
					box2d.b2SubVV(x, a, d);

					// Apply incremental impulse
//					b2Vec2 P1 = d.x * normal;
					box2d.b2MulSV(d.x, normal, P1);
//					b2Vec2 P2 = d.y * normal;
					box2d.b2MulSV(d.y, normal, P2);
					box2d.b2AddVV(P1, P2, P1P2);
//					vA -= mA * (P1 + P2);
					vA.SelfMulSub(mA, P1P2);
//					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
					wA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));

//					vB += mB * (P1 + P2);
					vB.SelfMulAdd(mB, P1P2);
//					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
					wB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));

					// Accumulate
					cp1.normalImpulse = x.x;
					cp2.normalImpulse = x.y;

/*
#if B2_DEBUG_SOLVER === 1
					// Postconditions
					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);

					// Compute normal velocity
					vn2 = b2Dot(dv2, normal);

					if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn2 - cp2->velocityBias) < k_errorTol); }
#endif
*/
					break;
				}

				//
				// Case 4: x1 = 0 and x2 = 0
				// 
				// vn1 = b1
				// vn2 = b2;
				x.x = 0;
				x.y = 0;
				vn1 = b.x;
				vn2 = b.y;

				if (vn1 >= 0 && vn2 >= 0)
				{
					// Resubstitute for the incremental impulse
//					b2Vec2 d = x - a;
					box2d.b2SubVV(x, a, d);

					// Apply incremental impulse
//					b2Vec2 P1 = d.x * normal;
					box2d.b2MulSV(d.x, normal, P1);
//					b2Vec2 P2 = d.y * normal;
					box2d.b2MulSV(d.y, normal, P2);
					box2d.b2AddVV(P1, P2, P1P2);
//					vA -= mA * (P1 + P2);
					vA.SelfMulSub(mA, P1P2);
//					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
					wA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));

//					vB += mB * (P1 + P2);
					vB.SelfMulAdd(mB, P1P2);
//					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
					wB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));

					// Accumulate
					cp1.normalImpulse = x.x;
					cp2.normalImpulse = x.y;

					break;
				}

				// No solution, give up. This is hit sometimes, but it doesn't seem to matter.
				break;
			}
		}

//		this.m_velocities[indexA].v = vA;
		this.m_velocities[indexA].w = wA;
//		this.m_velocities[indexB].v = vB;
		this.m_velocities[indexB].w = wB;
	}
}
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2();

/**
 * @export 
 * @return {void} 
 */
box2d.b2ContactSolver.prototype.StoreImpulses = function ()
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactVelocityConstraint} */ var vc;
	/** @type {box2d.b2Manifold} */ var manifold;

	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		vc = this.m_velocityConstraints[i];
		manifold = this.m_contacts[vc.contactIndex].GetManifold();

		for (j = 0, jct = vc.pointCount; j < jct; ++j)
		{
			manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
			manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
		}
	}
}

/**
 * @export 
 * @constructor
 */
box2d.b2PositionSolverManifold = function ()
{
	this.normal = new box2d.b2Vec2();
	this.point = new box2d.b2Vec2();
}

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PositionSolverManifold.prototype.normal = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PositionSolverManifold.prototype.point = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PositionSolverManifold.prototype.separation = 0;

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2ContactPositionConstraint} pc 
 * @param {box2d.b2Transform} xfA 
 * @param {box2d.b2Transform} xfB
 * @param {number} index 
 */
box2d.b2PositionSolverManifold.prototype.Initialize = function (pc, xfA, xfB, index)
{
	/** @type {box2d.b2Vec2} */ var pointA = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA;
	/** @type {box2d.b2Vec2} */ var pointB = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB;
	/** @type {box2d.b2Vec2} */ var planePoint = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint;
	/** @type {box2d.b2Vec2} */ var clipPoint = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pc.pointCount > 0); }

	switch (pc.type)
	{
	case box2d.b2ManifoldType.e_circles:
		{
//			b2Vec2 pointA = b2Mul(xfA, pc->localPoint);
			box2d.b2MulXV(xfA, pc.localPoint, pointA);
//			b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);
			box2d.b2MulXV(xfB, pc.localPoints[0], pointB);
//			normal = pointB - pointA;
//			normal.Normalize();
			box2d.b2SubVV(pointB, pointA, this.normal).SelfNormalize();
//			point = 0.5f * (pointA + pointB);
			box2d.b2MidVV(pointA, pointB, this.point);
//			separation = b2Dot(pointB - pointA, normal) - pc->radius;
			this.separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
		}
		break;

	case box2d.b2ManifoldType.e_faceA:
		{
//			normal = b2Mul(xfA.q, pc->localNormal);
			box2d.b2MulRV(xfA.q, pc.localNormal, this.normal);
//			b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);
			box2d.b2MulXV(xfA, pc.localPoint, planePoint);

//			b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);
			box2d.b2MulXV(xfB, pc.localPoints[index], clipPoint);
//			separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;
			this.separation = box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
//			point = clipPoint;
			this.point.Copy(clipPoint);
		}
		break;

	case box2d.b2ManifoldType.e_faceB:
		{
//			normal = b2Mul(xfB.q, pc->localNormal);
			box2d.b2MulRV(xfB.q, pc.localNormal, this.normal);
//			b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);
			box2d.b2MulXV(xfB, pc.localPoint, planePoint);

//			b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);
			box2d.b2MulXV(xfA, pc.localPoints[index], clipPoint);
//			separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;
			this.separation = box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
//			point = clipPoint;
			this.point.Copy(clipPoint);

			// Ensure normal points from A to B
//			normal = -normal;
			this.normal.SelfNeg();
		}
		break;
	}
}
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2();
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2();
box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2();
box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2();

/** 
 * Sequential solver. 
 * @export 
 * @return {boolean}
 */
box2d.b2ContactSolver.prototype.SolvePositionConstraints = function ()
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactPositionConstraint} */ var pc;

	/** @type {number} */ var indexA;
	/** @type {number} */ var indexB;
	/** @type {box2d.b2Vec2} */ var localCenterA;
	/** @type {number} */ var mA;
	/** @type {number} */ var iA;
	/** @type {box2d.b2Vec2} */ var localCenterB;
	/** @type {number} */ var mB;
	/** @type {number} */ var iB;
	/** @type {number} */ var pointCount;

	/** @type {box2d.b2Vec2} */ var cA;
	/** @type {number} */ var aA;

	/** @type {box2d.b2Vec2} */ var cB;
	/** @type {number} */ var aB;

	/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB;

	/** @type {box2d.b2PositionSolverManifold} */ var psm = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm;

	/** @type {box2d.b2Vec2} */ var normal;
	/** @type {box2d.b2Vec2} */ var point;
	/** @type {number} */ var separation;

	/** @type {box2d.b2Vec2} */ var rA = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA;
	/** @type {box2d.b2Vec2} */ var rB = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB;

	/** @type {number} */ var C;
	/** @type {number} */ var rnA;
	/** @type {number} */ var rnB;
	/** @type {number} */ var K;
	/** @type {number} */ var impulse;
	/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P;

	/** @type {number} */ var minSeparation = 0;

	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		pc = this.m_positionConstraints[i];

		indexA = pc.indexA;
		indexB = pc.indexB;
		localCenterA = pc.localCenterA;
		mA = pc.invMassA;
		iA = pc.invIA;
		localCenterB = pc.localCenterB;
		mB = pc.invMassB;
		iB = pc.invIB;
		pointCount = pc.pointCount;

		cA = this.m_positions[indexA].c;
		aA = this.m_positions[indexA].a;

		cB = this.m_positions[indexB].c;
		aB = this.m_positions[indexB].a;

		// Solve normal constraints
		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			xfA.q.SetAngleRadians(aA);
			xfB.q.SetAngleRadians(aB);
			box2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);
			box2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);

			psm.Initialize(pc, xfA, xfB, j);
			normal = psm.normal;

			point = psm.point;
			separation = psm.separation;

//			b2Vec2 rA = point - cA;
			box2d.b2SubVV(point, cA, rA);
//			b2Vec2 rB = point - cB;
			box2d.b2SubVV(point, cB, rB);

			// Track max constraint error.
			minSeparation = box2d.b2Min(minSeparation, separation);

			// Prevent large corrections and allow slop.
			C = box2d.b2Clamp(box2d.b2_baumgarte * (separation + box2d.b2_linearSlop), (-box2d.b2_maxLinearCorrection), 0);

			// Compute the effective mass.
//			float32 rnA = b2Cross(rA, normal);
			rnA = box2d.b2CrossVV(rA, normal);
//			float32 rnB = b2Cross(rB, normal);
			rnB = box2d.b2CrossVV(rB, normal);
//			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
			K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

			// Compute normal impulse
			impulse = K > 0 ? - C / K : 0;

//			b2Vec2 P = impulse * normal;
			box2d.b2MulSV(impulse, normal, P);

//			cA -= mA * P;
			cA.SelfMulSub(mA, P);
//			aA -= iA * b2Cross(rA, P);
			aA -= iA * box2d.b2CrossVV(rA, P);

//			cB += mB * P;
			cB.SelfMulAdd(mB, P);
//			aB += iB * b2Cross(rB, P);
			aB += iB * box2d.b2CrossVV(rB, P);
		}

//		this.m_positions[indexA].c = cA;
		this.m_positions[indexA].a = aA;

//		this.m_positions[indexB].c = cB;
		this.m_positions[indexB].a = aB;
	}

	// We can't expect minSpeparation >= -box2d.b2_linearSlop because we don't
	// push the separation above -box2d.b2_linearSlop.
	return minSeparation > (-3 * box2d.b2_linearSlop);
}
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold();
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();

/** 
 * Sequential position solver for position constraints. 
 * @export 
 * @return {boolean} 
 * @param {number} toiIndexA 
 * @param {number} toiIndexB 
 */
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function (toiIndexA, toiIndexB)
{
	/** @type {number} */ var i;
	/** @type {number} */ var ict;
	/** @type {number} */ var j;
	/** @type {number} */ var jct;

	/** @type {box2d.b2ContactPositionConstraint} */ var pc;

	/** @type {number} */ var indexA;
	/** @type {number} */ var indexB;
	/** @type {box2d.b2Vec2} */ var localCenterA;
	/** @type {box2d.b2Vec2} */ var localCenterB;
	/** @type {number} */ var pointCount;

	/** @type {number} */ var mA;
	/** @type {number} */ var iA;

	/** @type {number} */ var mB;
	/** @type {number} */ var iB;

	/** @type {box2d.b2Vec2} */ var cA;
	/** @type {number} */ var aA;

	/** @type {box2d.b2Vec2} */ var cB;
	/** @type {number} */ var aB;

	/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA;
	/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB;

	/** @type {box2d.b2PositionSolverManifold} */ var psm = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm;
	/** @type {box2d.b2Vec2} */ var normal;
	/** @type {box2d.b2Vec2} */ var point;
	/** @type {number} */ var separation;
	/** @type {box2d.b2Vec2} */ var rA = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA;
	/** @type {box2d.b2Vec2} */ var rB = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB;
	/** @type {number} */ var C;
	/** @type {number} */ var rnA;
	/** @type {number} */ var rnB;
	/** @type {number} */ var K;
	/** @type {number} */ var impulse;
	/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P;

	/** @type {number} */ var minSeparation = 0;

	for (i = 0, ict = this.m_count; i < ict; ++i)
	{
		pc = this.m_positionConstraints[i];

		indexA = pc.indexA;
		indexB = pc.indexB;
		localCenterA = pc.localCenterA;
		localCenterB = pc.localCenterB;
		pointCount = pc.pointCount;

		mA = 0;
		iA = 0;
		if (indexA === toiIndexA || indexA === toiIndexB)
		{
			mA = pc.invMassA;
			iA = pc.invIA;
		}

		mB = 0;
		iB = 0;
		if (indexB === toiIndexA || indexB === toiIndexB)
		{
			mB = pc.invMassB;
			iB = pc.invIB;
		}

		cA = this.m_positions[indexA].c;
		aA = this.m_positions[indexA].a;

		cB = this.m_positions[indexB].c;
		aB = this.m_positions[indexB].a;

		// Solve normal constraints
		for (j = 0, jct = pointCount; j < jct; ++j)
		{
			xfA.q.SetAngleRadians(aA);
			xfB.q.SetAngleRadians(aB);
			box2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);
			box2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);

			psm.Initialize(pc, xfA, xfB, j);
			normal = psm.normal;

			point = psm.point;
			separation = psm.separation;

//			b2Vec2 rA = point - cA;
			box2d.b2SubVV(point, cA, rA);
//			b2Vec2 rB = point - cB;
			box2d.b2SubVV(point, cB, rB);

			// Track max constraint error.
			minSeparation = box2d.b2Min(minSeparation, separation);

			// Prevent large corrections and allow slop.
			C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (separation + box2d.b2_linearSlop), (-box2d.b2_maxLinearCorrection), 0);

			// Compute the effective mass.
//			float32 rnA = b2Cross(rA, normal);
			rnA = box2d.b2CrossVV(rA, normal);
//			float32 rnB = b2Cross(rB, normal);
			rnB = box2d.b2CrossVV(rB, normal);
//			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
			K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

			// Compute normal impulse
			impulse = K > 0 ? - C / K : 0;

//			b2Vec2 P = impulse * normal;
			box2d.b2MulSV(impulse, normal, P);

//			cA -= mA * P;
			cA.SelfMulSub(mA, P);
//			aA -= iA * b2Cross(rA, P);
			aA -= iA * box2d.b2CrossVV(rA, P);

//			cB += mB * P;
			cB.SelfMulAdd(mB, P);
//			aB += iB * b2Cross(rB, P);
			aB += iB * box2d.b2CrossVV(rB, P);
		}

//		this.m_positions[indexA].c = cA;
		this.m_positions[indexA].a = aA;

//		this.m_positions[indexB].c = cB;
		this.m_positions[indexB].a = aB;
	}

	// We can't expect minSpeparation >= -box2d.b2_linearSlop because we don't
	// push the separation above -box2d.b2_linearSlop.
	return minSeparation >= -1.5 * box2d.b2_linearSlop;
}
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform();
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold();
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2();
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2WorldCallbacks');

goog.require('box2d.b2Settings');

/** 
 * Joints and fixtures are destroyed when their associated body 
 * is destroyed. Implement this listener so that you may nullify 
 * references to these joints and shapes. 
 * @export 
 * @constructor
 */
box2d.b2DestructionListener = function ()
{
};

/** 
 * Called when any joint is about to be destroyed due to the 
 * destruction of one of its attached bodies. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Joint} joint 
 */
box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function (joint)
{
}

/** 
 * Called when any fixture is about to be destroyed due to the 
 * destruction of its parent body. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixture 
 */
box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture)
{
}

/** 
 * Implement this class to provide collision filtering. In other 
 * words, you can implement this class if you want finer control 
 * over contact creation. 
 * @export 
 * @constructor
 */
box2d.b2ContactFilter = function ()
{
};

/** 
 * Return true if contact calculations should be performed 
 * between these two shapes. 
 * warning for performance reasons this is only called when the 
 * AABBs begin to overlap. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Fixture} fixtureA 
 * @param {box2d.b2Fixture} fixtureB 
 */
box2d.b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB)
{
	var filter1 = fixtureA.GetFilterData();
	var filter2 = fixtureB.GetFilterData();

	if (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0)
	{
		return (filter1.groupIndex > 0);
	}

	var collide = (((filter1.maskBits & filter2.categoryBits) !== 0) && ((filter1.categoryBits & filter2.maskBits) !== 0));
	return collide;
}

box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter();

/** 
 * Contact impulses for reporting. Impulses are used instead of 
 * forces because sub-step forces may approach infinity for 
 * rigid body collisions. These match up one-to-one with the 
 * contact points in b2Manifold. 
 * @export 
 * @constructor
 */
box2d.b2ContactImpulse = function ()
{
	this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
	this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
};

box2d.b2ContactImpulse.prototype.normalImpulses = null;
box2d.b2ContactImpulse.prototype.tangentImpulses = null;
box2d.b2ContactImpulse.prototype.count = 0;

/** 
 * Implement this class to get contact information. You can use 
 * these results for things like sounds and game logic. You can 
 * also get contact results by traversing the contact lists 
 * after the time step. However, you might miss some contacts 
 * because continuous physics leads to sub-stepping. 
 * Additionally you may receive multiple callbacks for the same 
 * contact in a single time step. 
 * You should strive to make your callbacks efficient because 
 * there may be many callbacks per time step. 
 * warning You cannot create/destroy Box2D entities inside these 
 * callbacks. 
 * @export 
 * @constructor
 */
box2d.b2ContactListener = function ()
{
};

/** 
 * Called when two fixtures begin to touch. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 */
box2d.b2ContactListener.prototype.BeginContact = function (contact)
{
}

/** 
 * Called when two fixtures cease to touch. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 */
box2d.b2ContactListener.prototype.EndContact = function (contact)
{
}

/** 
 * This is called after a contact is updated. This allows you to 
 * inspect a contact before it goes to the solver. If you are 
 * careful, you can modify the contact manifold (e.g. disable 
 * contact). 
 * A copy of the old manifold is provided so that you can detect 
 * changes. 
 * Note: this is called only for awake bodies. 
 * Note: this is called even when the number of contact points 
 * is zero. 
 * Note: this is not called for sensors. 
 * Note: if you set the number of contact points to zero, you 
 * will not get an EndContact callback. However, you may get a 
 * BeginContact callback the next step. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 * @param {box2d.b2Manifold} oldManifold 
 */
box2d.b2ContactListener.prototype.PreSolve = function (contact, oldManifold)
{
}

/** 
 * This lets you inspect a contact after the solver is finished. 
 * This is useful for inspecting impulses. 
 * Note: the contact manifold does not include time of impact 
 * impulses, which can be arbitrarily large if the sub-step is 
 * small. Hence the impulse is provided explicitly in a separate 
 * data structure. 
 * Note: this is only called for contacts that are touching, 
 * solid, and awake. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact
 * @param {box2d.b2ContactImpulse} impulse
 */
box2d.b2ContactListener.prototype.PostSolve = function (contact, impulse)
{
}

/**
 * @export 
 * @type {box2d.b2ContactListener} 
 */
box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener();

/** 
 * Callback class for AABB queries. 
 * See b2World::Query 
 * @export 
 * @constructor
 */
box2d.b2QueryCallback = function ()
{
}

/** 
 * Called for each fixture found in the query AABB. 
 * @export 
 * @return {boolean} false to terminate the query.
 */
box2d.b2QueryCallback.prototype.ReportFixture = function (fixture)
{
	return true;
}

/** 
 * Callback class for ray casts. 
 * See b2World::RayCast 
 * @export 
 * @constructor
 */
box2d.b2RayCastCallback = function ()
{
}

/** 
 * Called for each fixture found in the query. You control how 
 * the ray cast proceeds by returning a float: 
 * return -1: ignore this fixture and continue 
 * return 0: terminate the ray cast 
 * return fraction: clip the ray to this point 
 * return 1: don't clip the ray and continue
 * @export 
 * @return {number}
 * @param {box2d.b2Fixture} fixture the fixture hit by the ray
 * @param {box2d.b2Vec2} point the point of initial intersection
 * @param {box2d.b2Vec2} normal the normal vector at the point 
 *  	  of intersection
 * @param {number} fraction 
 */
box2d.b2RayCastCallback.prototype.ReportFixture = function (fixture, point, normal, fraction)
{
	return fraction;
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Island');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Timer');
goog.require('box2d.b2TimeStep');
goog.require('box2d.b2WorldCallbacks');
goog.require('box2d.b2ContactSolver');

/*
Position Correction Notes
=========================
I tried the several algorithms for position correction of the 2D revolute joint.
I looked at these systems:
- simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.
- suspension bridge with 30 1m long planks of length 1m.
- multi-link chain with 30 1m long links.

Here are the algorithms:

Baumgarte - A fraction of the position error is added to the velocity error. There is no
separate position solver.

Pseudo Velocities - After the velocity solver and position integration,
the position error, Jacobian, and effective mass are recomputed. Then
the velocity constraints are solved with pseudo velocities and a fraction
of the position error is added to the pseudo velocity error. The pseudo
velocities are initialized to zero and there is no warm-starting. After
the position solver, the pseudo velocities are added to the positions.
This is also called the First Order World method or the Position LCP method.

Modified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the
position error is re-computed for each constraint and the positions are updated
after the constraint is solved. The radius vectors (aka Jacobians) are
re-computed too (otherwise the algorithm has horrible instability). The pseudo
velocity states are not needed because they are effectively zero at the beginning
of each iteration. Since we have the current position error, we allow the
iterations to terminate early if the error becomes smaller than box2d.b2_linearSlop.

Full NGS or just NGS - Like Modified NGS except the effective mass are re-computed
each time a constraint is solved.

Here are the results:
Baumgarte - this is the cheapest algorithm but it has some stability problems,
especially with the bridge. The chain links separate easily close to the root
and they jitter as they struggle to pull together. This is one of the most common
methods in the field. The big drawback is that the position correction artificially
affects the momentum, thus leading to instabilities and false bounce. I used a
bias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller
factor makes joints and contacts more spongy.

Pseudo Velocities - the is more stable than the Baumgarte method. The bridge is
stable. However, joints still separate with large angular velocities. Drag the
simple pendulum in a circle quickly and the joint will separate. The chain separates
easily and does not recover. I used a bias factor of 0.2. A larger value lead to
the bridge collapsing when a heavy cube drops on it.

Modified NGS - this algorithm is better in some ways than Baumgarte and Pseudo
Velocities, but in other ways it is worse. The bridge and chain are much more
stable, but the simple pendulum goes unstable at high angular velocities.

Full NGS - stable in all tests. The joints display good stiffness. The bridge
still sags, but this is better than infinite forces.

Recommendations
Pseudo Velocities are not really worthwhile because the bridge and chain cannot
recover from joint separation. In other cases the benefit over Baumgarte is small.

Modified NGS is not a robust method for the revolute joint due to the violent
instability seen in the simple pendulum. Perhaps it is viable with other constraint
types, especially scalar constraints where the effective mass is a scalar.

This leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities
and is very fast. I don't think we can escape Baumgarte, especially in highly
demanding cases where high constraint fidelity is not needed.

Full NGS is robust and easy on the eyes. I recommend this as an option for
higher fidelity simulation and certainly for suspension bridges and long chains.
Full NGS might be a good choice for ragdolls, especially motorized ragdolls where
joint separation can be problematic. The number of NGS iterations can be reduced
for better performance without harming robustness much.

Each joint in a can be handled differently in the position solver. So I recommend
a system where the user can select the algorithm on a per joint basis. I would
probably default to the slower Full NGS and let the user select the faster
Baumgarte method in performance critical scenarios.
*/

/*
Cache Performance

The Box2D solvers are dominated by cache misses. Data structures are designed
to increase the number of cache hits. Much of misses are due to random access
to body data. The constraint structures are iterated over linearly, which leads
to few cache misses.

The bodies are not accessed during iteration. Instead read only data, such as
the mass values are stored with the constraints. The mutable data are the constraint
impulses and the bodies velocities/positions. The impulses are held inside the
constraint structures. The body velocities/positions are held in compact, temporary
arrays to increase the number of cache hits. Linear and angular velocity are
stored in a single array since multiple arrays lead to multiple misses.
*/

/*
2D Rotation

R = [cos(theta) -sin(theta)]
    [sin(theta) cos(theta) ]

thetaDot = omega

Let q1 = cos(theta), q2 = sin(theta).
R = [q1 -q2]
    [q2  q1]

q1Dot = -thetaDot * q2
q2Dot = thetaDot * q1

q1_new = q1_old - dt * w * q2
q2_new = q2_old + dt * w * q1
then normalize.

This might be faster than computing sin+cos.
However, we can compute sin+cos of the same angle fast.
*/

/** 
 * This is an internal class. 
 * @export 
 * @constructor
 */
box2d.b2Island = function ()
{
	this.m_bodies = new Array(1024); // TODO: b2Settings
	this.m_contacts = new Array(1024); // TODO: b2Settings
	this.m_joints = new Array(1024); // TODO: b2Settings

	this.m_positions = box2d.b2Position.MakeArray(1024); // TODO: b2Settings
	this.m_velocities = box2d.b2Velocity.MakeArray(1024); // TODO: b2Settings
}

/**
 * @export 
 * @type {*}
 */
box2d.b2Island.prototype.m_allocator = null;
/**
 * @export 
 * @type {box2d.b2ContactListener}
 */
box2d.b2Island.prototype.m_listener = null;

/**
 * @export 
 * @type {Array.<box2d.b2Body>}
 */
box2d.b2Island.prototype.m_bodies = null;
/**
 * @export 
 * @type {Array.<box2d.b2Contact>}
 */
box2d.b2Island.prototype.m_contacts = null;
/**
 * @export 
 * @type {Array.<box2d.b2Joint>}
 */
box2d.b2Island.prototype.m_joints = null;

/**
 * @export 
 * @type {Array.<box2d.b2Position>}
 */
box2d.b2Island.prototype.m_positions = null;
/**
 * @export 
 * @type {Array.<box2d.b2Velocity>}
 */
box2d.b2Island.prototype.m_velocities = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_bodyCount = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_jointCount = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_contactCount = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_bodyCapacity = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_contactCapacity = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Island.prototype.m_jointCapacity = 0;

/** 
 * @export 
 * @return {void} 
 * @param {number} bodyCapacity
 * @param {number} contactCapacity
 * @param {number} jointCapacity 
 * @param allocator 
 * @param {box2d.b2ContactListener} listener 
 */
box2d.b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener)
{
	this.m_bodyCapacity = bodyCapacity;
	this.m_contactCapacity = contactCapacity;
	this.m_jointCapacity = jointCapacity;
	this.m_bodyCount = 0;
	this.m_contactCount = 0;
	this.m_jointCount = 0;

	this.m_allocator = allocator;
	this.m_listener = listener;

	// TODO:
	while (this.m_bodies.length < bodyCapacity)
	{
		this.m_bodies[this.m_bodies.length] = null;
	}
	// TODO:
	while (this.m_contacts.length < contactCapacity)
	{
		this.m_contacts[this.m_contacts.length] = null;
	}
	// TODO:
	while (this.m_joints.length < jointCapacity)
	{
		this.m_joints[this.m_joints.length] = null;
	}

	// TODO:
	if (this.m_positions.length < bodyCapacity)
	{
		var new_length = box2d.b2Max(this.m_positions.length * 2, bodyCapacity);

		if (box2d.DEBUG)
		{
			window.console.log("box2d.b2Island.m_positions: " + new_length);
		}

		while (this.m_positions.length < new_length)
		{
			this.m_positions[this.m_positions.length] = new box2d.b2Position();
		}
	}
	// TODO:
	if (this.m_velocities.length < bodyCapacity)
	{
		var new_length = box2d.b2Max(this.m_velocities.length * 2, bodyCapacity);

		if (box2d.DEBUG)
		{
			window.console.log("box2d.b2Island.m_velocities: " + new_length);
		}

		while (this.m_velocities.length < new_length)
		{
			this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity();
		}
	}
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Island.prototype.Clear = function ()
{
	this.m_bodyCount = 0;
	this.m_contactCount = 0;
	this.m_jointCount = 0;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} body
 */
box2d.b2Island.prototype.AddBody = function (body)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity); }
	body.m_islandIndex = this.m_bodyCount;
	this.m_bodies[this.m_bodyCount++] = body;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact
 */
box2d.b2Island.prototype.AddContact = function (contact)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_contactCount < this.m_contactCapacity); }
	this.m_contacts[this.m_contactCount++] = contact;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Joint} joint
 */
box2d.b2Island.prototype.AddJoint = function (joint)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_jointCount < this.m_jointCapacity); }
	this.m_joints[this.m_jointCount++] = joint;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Profile} profile 
 * @param {box2d.b2TimeStep} step 
 * @param {box2d.b2Vec2} gravity 
 * @param {boolean} allowSleep 
 */
box2d.b2Island.prototype.Solve = function (profile, step, gravity, allowSleep)
{
	/*box2d.b2Timer*/ var timer = box2d.b2Island.s_timer.Reset();

	/*float32*/ var h = step.dt;

	// Integrate velocities and apply damping. Initialize the body state.
	for (var i = 0; i < this.m_bodyCount; ++i)
	{
		/*box2d.b2Body*/ var b = this.m_bodies[i];

		/*box2d.b2Vec2&*/ var c = this.m_positions[i].c.Copy(b.m_sweep.c);
		/*float32*/ var a = b.m_sweep.a;
		/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v.Copy(b.m_linearVelocity);
		/*float32*/ var w = b.m_angularVelocity;

		// Store positions for continuous collision.
		b.m_sweep.c0.Copy(b.m_sweep.c);
		b.m_sweep.a0 = b.m_sweep.a;

		if (b.m_type === box2d.b2BodyType.b2_dynamicBody)
		{
			// Integrate velocities.
			v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);
			v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);
			w += h * b.m_invI * b.m_torque;
	
			// Apply damping.
			// ODE: dv/dt + c * v = 0
			// Solution: v(t) = v0 * exp(-c * t)
			// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
			// v2 = exp(-c * dt) * v1
			// Pade approximation:
			// v2 = v1 * 1 / (1 + c * dt)
			v.SelfMul(1.0 / (1.0 + h * b.m_linearDamping));
			w *= 1.0 / (1.0 + h * b.m_angularDamping);
		}

//		this.m_positions[i].c = c;
		this.m_positions[i].a = a;
//		this.m_velocities[i].v = v;
		this.m_velocities[i].w = w;
	}

	timer.Reset();

	// Solver data
	/*box2d.b2SolverData*/ var solverData = box2d.b2Island.s_solverData;
	solverData.step.Copy(step);
	solverData.positions = this.m_positions;
	solverData.velocities = this.m_velocities;

	// Initialize velocity constraints.
	/*box2d.b2ContactSolverDef*/ var contactSolverDef = box2d.b2Island.s_contactSolverDef;
	contactSolverDef.step.Copy(step);
	contactSolverDef.contacts = this.m_contacts;
	contactSolverDef.count = this.m_contactCount;
	contactSolverDef.positions = this.m_positions;
	contactSolverDef.velocities = this.m_velocities;
	contactSolverDef.allocator = this.m_allocator;

	/*box2d.b2ContactSolver*/ var contactSolver = box2d.b2Island.s_contactSolver.Initialize(contactSolverDef);
	contactSolver.InitializeVelocityConstraints();

	if (step.warmStarting)
	{
		contactSolver.WarmStart();
	}

	for (var i = 0; i < this.m_jointCount; ++i)
	{
		this.m_joints[i].InitVelocityConstraints(solverData);
	}

	profile.solveInit = timer.GetMilliseconds();

	// Solve velocity constraints.
	timer.Reset();
	for (var i = 0; i < step.velocityIterations; ++i)
	{
		for (var j = 0; j < this.m_jointCount; ++j)
		{
			this.m_joints[j].SolveVelocityConstraints(solverData);
		}

		contactSolver.SolveVelocityConstraints();
	}

	// Store impulses for warm starting
	contactSolver.StoreImpulses();
	profile.solveVelocity = timer.GetMilliseconds();

	// Integrate positions.
	for (var i = 0; i < this.m_bodyCount; ++i)
	{
		/*box2d.b2Vec2&*/ var c = this.m_positions[i].c;
		/*float32*/ var a = this.m_positions[i].a;
		/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v;
		/*float32*/ var w = this.m_velocities[i].w;

		// Check for large velocities
		/*box2d.b2Vec2*/ var translation = box2d.b2MulSV(h, v, box2d.b2Island.s_translation);
		if (box2d.b2DotVV(translation, translation) > box2d.b2_maxTranslationSquared)
		{
			/*float32*/ var ratio = box2d.b2_maxTranslation / translation.GetLength();
			v.SelfMul(ratio);
		}

		/*float32*/ var rotation = h * w;
		if (rotation * rotation > box2d.b2_maxRotationSquared)
		{
			/*float32*/ var ratio = box2d.b2_maxRotation / box2d.b2Abs(rotation);
			w *= ratio;
		}

		// Integrate
		c.x += h * v.x;
		c.y += h * v.y;
		a += h * w;

//		this.m_positions[i].c = c;
		this.m_positions[i].a = a;
//		this.m_velocities[i].v = v;
		this.m_velocities[i].w = w;
	}

	// Solve position constraints
	timer.Reset();
	/*bool*/ var positionSolved = false;
	for (var i = 0; i < step.positionIterations; ++i)
	{
		/*bool*/ var contactsOkay = contactSolver.SolvePositionConstraints();

		/*bool*/ var jointsOkay = true;
		for (var j = 0; j < this.m_jointCount; ++j)
		{
			/*bool*/ var jointOkay = this.m_joints[j].SolvePositionConstraints(solverData);
			jointsOkay = jointsOkay && jointOkay;
		}

		if (contactsOkay && jointsOkay)
		{
			// Exit early if the position errors are small.
			positionSolved = true;
			break;
		}
	}

	// Copy state buffers back to the bodies
	for (var i = 0; i < this.m_bodyCount; ++i)
	{
		/** @type {box2d.b2Body} */ var body = this.m_bodies[i];
		body.m_sweep.c.Copy(this.m_positions[i].c);
		body.m_sweep.a = this.m_positions[i].a;
		body.m_linearVelocity.Copy(this.m_velocities[i].v);
		body.m_angularVelocity = this.m_velocities[i].w;
		body.SynchronizeTransform();
	}

	profile.solvePosition = timer.GetMilliseconds();

	this.Report(contactSolver.m_velocityConstraints);

	if (allowSleep)
	{
		/*float32*/ var minSleepTime = box2d.b2_maxFloat;

		/*float32*/ var linTolSqr = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance;
		/*float32*/ var angTolSqr = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;

		for (var i = 0; i < this.m_bodyCount; ++i)
		{
			/*box2d.b2Body*/ var b = this.m_bodies[i];
			if (b.GetType() === box2d.b2BodyType.b2_staticBody)
			{
				continue;
			}

			if ((b.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === 0 || 
				b.m_angularVelocity * b.m_angularVelocity > angTolSqr || 
				box2d.b2DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr)
			{
				b.m_sleepTime = 0;
				minSleepTime = 0;
			}
			else
			{
				b.m_sleepTime += h;
				minSleepTime = box2d.b2Min(minSleepTime, b.m_sleepTime);
			}
		}

		if (minSleepTime >= box2d.b2_timeToSleep && positionSolved)
		{
			for (var i = 0; i < this.m_bodyCount; ++i)
			{
				/*box2d.b2Body*/ var b = this.m_bodies[i];
				b.SetAwake(false);
			}
		}
	}
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} subStep 
 * @param {number} toiIndexA 
 * @param {number} toiIndexB 
 */
box2d.b2Island.prototype.SolveTOI = function (subStep, toiIndexA, toiIndexB)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(toiIndexA < this.m_bodyCount); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(toiIndexB < this.m_bodyCount); }

	// Initialize the body state.
	for (var i = 0; i < this.m_bodyCount; ++i)
	{
		/*box2d.b2Body*/ var b = this.m_bodies[i];
		this.m_positions[i].c.Copy(b.m_sweep.c);
		this.m_positions[i].a = b.m_sweep.a;
		this.m_velocities[i].v.Copy(b.m_linearVelocity);
		this.m_velocities[i].w = b.m_angularVelocity;
	}

	/*box2d.b2ContactSolverDef*/ var contactSolverDef = box2d.b2Island.s_contactSolverDef;
	contactSolverDef.contacts = this.m_contacts;
	contactSolverDef.count = this.m_contactCount;
	contactSolverDef.allocator = this.m_allocator;
	contactSolverDef.step.Copy(subStep);
	contactSolverDef.positions = this.m_positions;
	contactSolverDef.velocities = this.m_velocities;
	/*box2d.b2ContactSolver*/ var contactSolver = box2d.b2Island.s_contactSolver.Initialize(contactSolverDef);

	// Solve position constraints.
	for (var i = 0; i < subStep.positionIterations; ++i)
	{
		/*bool*/ var contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
		if (contactsOkay)
		{
			break;
		}
	}

/*
#if 0
	// Is the new position really safe?
	for (int32 i = 0; i < this.m_contactCount; ++i)
	{
		box2d.b2Contact* c = this.m_contacts[i];
		box2d.b2Fixture* fA = c.GetFixtureA();
		box2d.b2Fixture* fB = c.GetFixtureB();

		box2d.b2Body* bA = fA.GetBody();
		box2d.b2Body* bB = fB.GetBody();

		int32 indexA = c.GetChildIndexA();
		int32 indexB = c.GetChildIndexB();

		box2d.b2DistanceInput input;
		input.proxyA.Set(fA.GetShape(), indexA);
		input.proxyB.Set(fB.GetShape(), indexB);
		input.transformA = bA.GetTransform();
		input.transformB = bB.GetTransform();
		input.useRadii = false;

		box2d.b2DistanceOutput output;
		box2d.b2SimplexCache cache;
		cache.count = 0;
		box2d.b2Distance(&output, &cache, &input);

		if (output.distance === 0 || cache.count === 3)
		{
			cache.count += 0;
		}
	}
#endif
*/

	// Leap of faith to new safe state.
	this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);
	this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
	this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);
	this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;

	// No warm starting is needed for TOI events because warm
	// starting impulses were applied in the discrete solver.
	contactSolver.InitializeVelocityConstraints();

	// Solve velocity constraints.
	for (var i = 0; i < subStep.velocityIterations; ++i)
	{
		contactSolver.SolveVelocityConstraints();
	}

	// Don't store the TOI contact forces for warm starting
	// because they can be quite large.

	/*float32*/ var h = subStep.dt;

	// Integrate positions
	for (var i = 0; i < this.m_bodyCount; ++i)
	{
		/*box2d.b2Vec2&*/ var c = this.m_positions[i].c;
		/*float32*/ var a = this.m_positions[i].a;
		/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v;
		/*float32*/ var w = this.m_velocities[i].w;

		// Check for large velocities
		/*box2d.b2Vec2*/ var translation = box2d.b2MulSV(h, v, box2d.b2Island.s_translation);
		if (box2d.b2DotVV(translation, translation) > box2d.b2_maxTranslationSquared)
		{
			/*float32*/ var ratio = box2d.b2_maxTranslation / translation.GetLength();
			v.SelfMul(ratio);
		}

		/*float32*/ var rotation = h * w;
		if (rotation * rotation > box2d.b2_maxRotationSquared)
		{
			/*float32*/ var ratio = box2d.b2_maxRotation / box2d.b2Abs(rotation);
			w *= ratio;
		}

		// Integrate
		c.SelfMulAdd(h, v);
		a += h * w;

//		this.m_positions[i].c = c;
		this.m_positions[i].a = a;
//		this.m_velocities[i].v = v;
		this.m_velocities[i].w = w;

		// Sync bodies
		/*box2d.b2Body*/ var body = this.m_bodies[i];
		body.m_sweep.c.Copy(c);
		body.m_sweep.a = a;
		body.m_linearVelocity.Copy(v);
		body.m_angularVelocity = w;
		body.SynchronizeTransform();
	}

	this.Report(contactSolver.m_velocityConstraints);
}

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2ContactVelocityConstraint>} constraints
 */
box2d.b2Island.prototype.Report = function (constraints)
{
	if (this.m_listener === null)
	{
		return;
	}

	for (var i = 0; i < this.m_contactCount; ++i)
	{
		/** @type {box2d.b2Contact} */ var c = this.m_contacts[i];

		if (!c) { continue; }

		/** @type {box2d.b2ContactVelocityConstraint} */ var vc = constraints[i];

		/*box2d.b2ContactImpulse*/ var impulse = box2d.b2Island.s_impulse;
		impulse.count = vc.pointCount;
		for (var j = 0; j < vc.pointCount; ++j)
		{
			impulse.normalImpulses[j] = vc.points[j].normalImpulse;
			impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
		}

		this.m_listener.PostSolve(c, impulse);
	}
}

box2d.b2Island.s_timer = new box2d.b2Timer();
box2d.b2Island.s_solverData = new box2d.b2SolverData();
box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef();
box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver();
box2d.b2Island.s_translation = new box2d.b2Vec2();
box2d.b2Island.s_impulse = new box2d.b2ContactImpulse();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ContactFactory');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Contact');

/**
 * @export
 * @constructor
 */
box2d.b2ContactRegister = function ()
{
};

box2d.b2ContactRegister.prototype.createFcn = null;
box2d.b2ContactRegister.prototype.destroyFcn = null;
box2d.b2ContactRegister.prototype.primary = false;

/**
 * @export
 * @constructor
 * @param allocator
 */
box2d.b2ContactFactory = function (allocator)
{
	this.m_allocator = allocator;
	this.InitializeRegisters();
}

box2d.b2ContactFactory.prototype.m_allocator = null;

/**
 * @export
 * @return {void}
 * @param createFcn
 * @param destroyFcn
 * @param {box2d.b2ShapeType} type1
 * @param {box2d.b2ShapeType} type2
 */
box2d.b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2)
{
	if (true)
	{
		var pool = box2d.b2MakeArray(256, function (i) { return createFcn(); } ); // TODO: b2Settings

		var poolCreateFcn = function (allocator)
		{
			if (pool.length > 0)
			{
				return pool.pop();
			}

			return createFcn(allocator);
		}

		var poolDestroyFcn = function (contact, allocator)
		{
			pool.push(contact);
		}

		this.m_registers[type1][type2].pool = pool;
		this.m_registers[type1][type2].createFcn = poolCreateFcn;
		this.m_registers[type1][type2].destroyFcn = poolDestroyFcn;
		this.m_registers[type1][type2].primary = true;

		if (type1 !== type2)
		{
			this.m_registers[type2][type1].pool = pool;
			this.m_registers[type2][type1].createFcn = poolCreateFcn;
			this.m_registers[type2][type1].destroyFcn = poolDestroyFcn;
			this.m_registers[type2][type1].primary = false;
		}
	}

	/*
	this.m_registers[type1][type2].createFcn = createFcn;
	this.m_registers[type1][type2].destroyFcn = destroyFcn;
	this.m_registers[type1][type2].primary = true;

	if (type1 !== type2)
	{
		this.m_registers[type2][type1].createFcn = createFcn;
		this.m_registers[type2][type1].destroyFcn = destroyFcn;
		this.m_registers[type2][type1].primary = false;
	}
	*/
}

/**
 * @export
 * @return {void}
 */
box2d.b2ContactFactory.prototype.InitializeRegisters = function ()
{
	this.m_registers = new Array(box2d.b2ShapeType.e_shapeTypeCount);

	for (var i = 0; i < box2d.b2ShapeType.e_shapeTypeCount; i++)
	{
		this.m_registers[i] = new Array(box2d.b2ShapeType.e_shapeTypeCount);

		for (var j = 0; j < box2d.b2ShapeType.e_shapeTypeCount; j++)
		{
			this.m_registers[i][j] = new box2d.b2ContactRegister();
		}
	}

	this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape);
	this.AddType(box2d.b2PolygonAndCircleContact.Create, box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape);
	this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape);
	this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape);
	this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_polygonShape);
	this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape);
	this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape);
}

/**
 * @export
 * @return {box2d.b2Contact}
 * @param {box2d.b2Fixture} fixtureA
 * @param {number} indexA
 * @param {box2d.b2Fixture} fixtureB
 * @param {number} indexB
 */
box2d.b2ContactFactory.prototype.Create = function (fixtureA, indexA, fixtureB, indexB)
{
	var type1 = fixtureA.GetType();
	var type2 = fixtureB.GetType();

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= type1 && type1 < box2d.b2ShapeType.e_shapeTypeCount); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= type2 && type2 < box2d.b2ShapeType.e_shapeTypeCount); }

	var reg = this.m_registers[type1][type2];

	var createFcn = reg.createFcn;
	if (createFcn !== null)
	{
		if (reg.primary)
		{
			var c = createFcn(this.m_allocator);
			c.Reset(fixtureA, indexA, fixtureB, indexB);
			return c;
		}
		else
		{
			var c = createFcn(this.m_allocator);
			c.Reset(fixtureB, indexB, fixtureA, indexA);
			return c;
		}
	}
	else
	{
		return null;
	}
}

/**
 * @export
 * @return {void}
 * @param {box2d.b2Contact} contact
 */
box2d.b2ContactFactory.prototype.Destroy = function (contact)
{
	var fixtureA = contact.m_fixtureA;
	var fixtureB = contact.m_fixtureB;

	if (contact.m_manifold.pointCount > 0 &&
		fixtureA.IsSensor() === false &&
		fixtureB.IsSensor() === false)
	{
		fixtureA.GetBody().SetAwake(true);
		fixtureB.GetBody().SetAwake(true);
	}

	var typeA = fixtureA.GetType();
	var typeB = fixtureB.GetType();

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= typeA && typeB < box2d.b2ShapeType.e_shapeTypeCount); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= typeA && typeB < box2d.b2ShapeType.e_shapeTypeCount); }

	var reg = this.m_registers[typeA][typeB];

	var destroyFcn = reg.destroyFcn;
	destroyFcn(contact, this.m_allocator);
}

/*
* Copyright (c) 2010 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2GrowableStack');

goog.require('box2d.b2Settings');

/** 
 * This is a growable LIFO stack with an initial capacity of N. 
 * If the stack size exceeds the initial capacity, the heap is 
 * used to increase the size of the stack. 
 * @export 
 * @constructor 
 * @param {number} N 
 */
box2d.b2GrowableStack = function (N)
{
	this.m_stack = new Array(N);
}

/**
 * @export 
 * @type {Array.<*>}
 */
box2d.b2GrowableStack.prototype.m_stack = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2GrowableStack.prototype.m_count = 0;

/**
 * @export 
 * @return {box2d.b2GrowableStack}
 */
box2d.b2GrowableStack.prototype.Reset = function ()
{
	this.m_count = 0;
	return this;
}

/**
 * @export 
 * @return {void} 
 * @param {*} element 
 */
box2d.b2GrowableStack.prototype.Push = function (element)
{
	this.m_stack[this.m_count] = element;
	++this.m_count;
}

/**
 * @export 
 * @return {*}
 */
box2d.b2GrowableStack.prototype.Pop = function ()
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_count > 0); }
	--this.m_count;
	var element = this.m_stack[this.m_count];
	this.m_stack[this.m_count] = null;
	return element;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2GrowableStack.prototype.GetCount = function ()
{
	return this.m_count;
}

/*
* Copyright (c) 2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2DynamicTree')

goog.require('box2d.b2Settings');
goog.require('box2d.b2Collision');
goog.require('box2d.b2GrowableStack');

/** 
 * A node in the dynamic tree. The client does not interact with 
 * this directly. 
 * @export 
 * @constructor 
 * @param {number=} id 
 */
box2d.b2TreeNode = function (id)
{
	this.m_id = id || 0;

	this.aabb = new box2d.b2AABB();
};

/**
 * @export 
 * @type {number}
 */
box2d.b2TreeNode.prototype.m_id = 0;

/** 
 * Enlarged AABB 
 * @export 
 * @type {box2d.b2AABB}
 */
box2d.b2TreeNode.prototype.aabb = null;

/**
 * @export 
 * @type {*}
 */
box2d.b2TreeNode.prototype.userData = null;

/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2TreeNode.prototype.parent = null; // or box2d.b2TreeNode.prototype.next

/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2TreeNode.prototype.child1 = null;
/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2TreeNode.prototype.child2 = null;

/** 
 * leaf = 0, free node = -1 
 * @export 
 * @type {number}
 */
box2d.b2TreeNode.prototype.height = 0;

/**
 * @export 
 * @return {boolean} 
 */
box2d.b2TreeNode.prototype.IsLeaf = function ()
{
	return this.child1 === null;
}

/** 
 * A dynamic tree arranges data in a binary tree to accelerate
 * queries such as volume queries and ray casts. Leafs are proxies
 * with an AABB. In the tree we expand the proxy AABB by b2_fatAABBFactor
 * so that the proxy AABB is bigger than the client object. This allows the client
 * object to move by small amounts without triggering a tree update.
 *
 * Nodes are pooled and relocatable, so we use node indices rather than pointers.
 * @export 
 * @constructor
 */
box2d.b2DynamicTree = function ()
{
}

/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2DynamicTree.prototype.m_root = null;

//b2TreeNode* box2d.b2DynamicTree.prototype.m_nodes;
//int32 box2d.b2DynamicTree.prototype.m_nodeCount;
//int32 box2d.b2DynamicTree.prototype.m_nodeCapacity;

/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2DynamicTree.prototype.m_freeList = null;

/** 
 * This is used to incrementally traverse the tree for 
 * re-balancing. 
 * @export 
 * @type {number}
 */
box2d.b2DynamicTree.prototype.m_path = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2DynamicTree.prototype.m_insertionCount = 0;

box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256);
box2d.b2DynamicTree.s_r = new box2d.b2Vec2();
box2d.b2DynamicTree.s_v = new box2d.b2Vec2();
box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2();
box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB();
box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput();
box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB();
box2d.b2DynamicTree.s_aabb = new box2d.b2AABB();

/** 
 * Get proxy user data. 
 * @export 
 * @return {*} the proxy user data or 0 if the id is invalid.
 * @param {box2d.b2TreeNode} proxy
 */
box2d.b2DynamicTree.prototype.GetUserData = function (proxy)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy !== null); }
	return proxy.userData;
}

/** 
 * Get the fat AABB for a proxy. 
 * @export 
 * @return {box2d.b2AABB} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2DynamicTree.prototype.GetFatAABB = function (proxy)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy !== null); }
	return proxy.aabb;
}

/** 
 * Query an AABB for overlapping proxies. The callback class is 
 * called for each proxy that overlaps the supplied AABB. 
 * @export 
 * @return {void} 
 * @param {function(!box2d.b2TreeNode): boolean} callback
 * @param {box2d.b2AABB} aabb 
 */
box2d.b2DynamicTree.prototype.Query = function (callback, aabb)
{
	if (this.m_root === null) return;

	/** @type {box2d.b2GrowableStack} */ var stack = box2d.b2DynamicTree.s_stack.Reset();
	stack.Push(this.m_root);

	while (stack.GetCount() > 0)
	{
		/** @type {box2d.b2TreeNode} */ var node = /** @type {box2d.b2TreeNode} */ (stack.Pop());
		if (node === null)
		{
			continue;
		}

		if (node.aabb.TestOverlap(aabb))
		{
			if (node.IsLeaf())
			{
				/** @type {boolean} */ var proceed = callback(node);
				if (proceed === false)
				{
					return;
				}
			}
			else
			{
				stack.Push(node.child1);
				stack.Push(node.child2);
			}
		}
	}
}

/**
 * Ray-cast against the proxies in the tree. This relies on the callback
 * to perform a exact ray-cast in the case were the proxy contains a shape.
 * The callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * @export 
 * @return {void} 
 * @param {function(!box2d.b2RayCastInput, !box2d.b2TreeNode): number} callback a callback class that is called for each proxy that is hit by the ray.
 * @param {box2d.b2RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
 */
box2d.b2DynamicTree.prototype.RayCast = function (callback, input)
{
	if (this.m_root === null) return;

	/** @type {box2d.b2Vec2} */ var p1 = input.p1;
	/** @type {box2d.b2Vec2} */ var p2 = input.p2;
	/** @type {box2d.b2Vec2} */ var r = box2d.b2SubVV(p2, p1, box2d.b2DynamicTree.s_r);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(r.GetLengthSquared() > 0); }
	r.Normalize();

	// v is perpendicular to the segment.
	/** @type {box2d.b2Vec2} */ var v = box2d.b2CrossOneV(r, box2d.b2DynamicTree.s_v);
	/** @type {box2d.b2Vec2} */ var abs_v = box2d.b2AbsV(v, box2d.b2DynamicTree.s_abs_v);

	// Separating axis for segment (Gino, p80).
	// |dot(v, p1 - c)| > dot(|v|, h)

	/** @type {number} */ var maxFraction = input.maxFraction;

	// Build a bounding box for the segment.
	/** @type {box2d.b2AABB} */ var segmentAABB = box2d.b2DynamicTree.s_segmentAABB;
	/** @type {number} */ var t_x = p1.x + maxFraction * (p2.x - p1.x);
	/** @type {number} */ var t_y = p1.y + maxFraction * (p2.y - p1.y);
	segmentAABB.lowerBound.x = box2d.b2Min(p1.x, t_x);
	segmentAABB.lowerBound.y = box2d.b2Min(p1.y, t_y);
	segmentAABB.upperBound.x = box2d.b2Max(p1.x, t_x);
	segmentAABB.upperBound.y = box2d.b2Max(p1.y, t_y);

	/** @type {box2d.b2GrowableStack} */ var stack = box2d.b2DynamicTree.s_stack.Reset();
	stack.Push(this.m_root);

	while (stack.GetCount() > 0)
	{
		/** @type {box2d.b2TreeNode} */ var node = /** @type {box2d.b2TreeNode} */ (stack.Pop());
		if (node === null)
		{
			continue;
		}

		if (box2d.b2TestOverlapAABB(node.aabb, segmentAABB) === false)
		{
			continue;
		}

		// Separating axis for segment (Gino, p80).
		// |dot(v, p1 - c)| > dot(|v|, h)
		/** @type {box2d.b2Vec2} */ var c = node.aabb.GetCenter();
		/** @type {box2d.b2Vec2} */ var h = node.aabb.GetExtents();
		/** @type {number} */ var separation = box2d.b2Abs(box2d.b2DotVV(v, box2d.b2SubVV(p1, c, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(abs_v, h);
		if (separation > 0)
		{
			continue;
		}

		if (node.IsLeaf())
		{
			/** @type {box2d.b2RayCastInput} */ var subInput = box2d.b2DynamicTree.s_subInput;
			subInput.p1.Copy(input.p1);
			subInput.p2.Copy(input.p2);
			subInput.maxFraction = maxFraction;

			/** @type {number} */ var value = callback(subInput, node);

			if (value === 0)
			{
				// The client has terminated the ray cast.
				return;
			}

			if (value > 0)
			{
				// Update segment bounding box.
				maxFraction = value;
				t_x = p1.x + maxFraction * (p2.x - p1.x);
				t_y = p1.y + maxFraction * (p2.y - p1.y);
				segmentAABB.lowerBound.x = box2d.b2Min(p1.x, t_x);
				segmentAABB.lowerBound.y = box2d.b2Min(p1.y, t_y);
				segmentAABB.upperBound.x = box2d.b2Max(p1.x, t_x);
				segmentAABB.upperBound.y = box2d.b2Max(p1.y, t_y);
			}
		}
		else
		{
			stack.Push(node.child1);
			stack.Push(node.child2);
		}
	}
}

/**
 * @export 
 * @return {box2d.b2TreeNode}
 */
box2d.b2DynamicTree.prototype.AllocateNode = function ()
{
	// Expand the node pool as needed.
	if (this.m_freeList)
	{
		/** @type {box2d.b2TreeNode} */ var node = this.m_freeList;
		this.m_freeList = node.parent; // this.m_freeList = node.next;
		node.parent = null;
		node.child1 = null;
		node.child2 = null;
		node.height = 0;
		node.userData = null;
		return node;
	}

	return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++);
}
box2d.b2DynamicTree.prototype.s_node_id = 0;

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} node
 */
box2d.b2DynamicTree.prototype.FreeNode = function (node)
{
	node.parent = this.m_freeList; // node.next = this.m_freeList;
	node.height = -1;
	this.m_freeList = node;
}

/** 
 * Create a proxy. Provide a tight fitting AABB and a userData 
 * pointer. 
 * @export 
 * @return {box2d.b2TreeNode}
 * @param {box2d.b2AABB} aabb 
 * @param {*} userData 
 */
box2d.b2DynamicTree.prototype.CreateProxy = function (aabb, userData)
{
	/** @type {box2d.b2TreeNode} */ var node = this.AllocateNode();

	// Fatten the aabb.
	/** @type {number} */ var r_x = box2d.b2_aabbExtension;
	/** @type {number} */ var r_y = box2d.b2_aabbExtension;
	node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;
	node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;
	node.aabb.upperBound.x = aabb.upperBound.x + r_x;
	node.aabb.upperBound.y = aabb.upperBound.y + r_y;
	node.userData = userData;
	node.height = 0;

	this.InsertLeaf(node);

	return node;
}

/** 
 * Destroy a proxy. This asserts if the id is invalid. 
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy
 */
box2d.b2DynamicTree.prototype.DestroyProxy = function (proxy)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy.IsLeaf()); }

	this.RemoveLeaf(proxy);
	this.FreeNode(proxy);
}

/** 
 * Move a proxy with a swepted AABB. If the proxy has moved 
 * outside of its fattened AABB, then the proxy is removed from 
 * the tree and re-inserted. Otherwise the function returns 
 * immediately. 
 * @export 
 * @return {boolean} true if the proxy was re-inserted.
 * @param {box2d.b2TreeNode} proxy
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Vec2} displacement 
 */
box2d.b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy.IsLeaf()); }

	if (proxy.aabb.Contains(aabb))
	{
		return false;
	}

	this.RemoveLeaf(proxy);

	// Extend AABB.
	// Predict AABB displacement.
	/** @type {number} */ var r_x = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
	/** @type {number} */ var r_y = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
	proxy.aabb.lowerBound.x = aabb.lowerBound.x - r_x;
	proxy.aabb.lowerBound.y = aabb.lowerBound.y - r_y;
	proxy.aabb.upperBound.x = aabb.upperBound.x + r_x;
	proxy.aabb.upperBound.y = aabb.upperBound.y + r_y;

	this.InsertLeaf(proxy);
	return true;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} leaf
 */
box2d.b2DynamicTree.prototype.InsertLeaf = function (leaf)
{
	++this.m_insertionCount;

	if (this.m_root === null)
	{
		this.m_root = leaf;
		this.m_root.parent = null;
		return;
	}

	// Find the best sibling for this node
	/** @type {box2d.b2AABB} */ var leafAABB = leaf.aabb;
	/** @type {box2d.b2Vec2} */ var center = leafAABB.GetCenter();
	/** @type {box2d.b2TreeNode} */ var index = this.m_root;
	/** @type {box2d.b2TreeNode} */ var child1;
	/** @type {box2d.b2TreeNode} */ var child2;
	while (index.IsLeaf() === false)
	{
		child1 = index.child1;
		child2 = index.child2;

		/** @type {number} */ var area = index.aabb.GetPerimeter();

		/** @type {box2d.b2AABB} */ var combinedAABB = box2d.b2DynamicTree.s_combinedAABB;
		combinedAABB.Combine2(index.aabb, leafAABB);
		/** @type {number} */ var combinedArea = combinedAABB.GetPerimeter();

		// Cost of creating a new parent for this node and the new leaf
		/** @type {number} */ var cost = 2 * combinedArea;

		// Minimum cost of pushing the leaf further down the tree
		/** @type {number} */ var inheritanceCost = 2 * (combinedArea - area);

		// Cost of descending into child1
		/** @type {number} */ var cost1;
		/** @type {box2d.b2AABB} */ var aabb = box2d.b2DynamicTree.s_aabb;
		/** @type {number} */ var oldArea;
		/** @type {number} */ var newArea;
		if (child1.IsLeaf())
		{
			aabb.Combine2(leafAABB, child1.aabb);
			cost1 = aabb.GetPerimeter() + inheritanceCost;
		}
		else
		{
			aabb.Combine2(leafAABB, child1.aabb);
			oldArea = child1.aabb.GetPerimeter();
			newArea = aabb.GetPerimeter();
			cost1 = (newArea - oldArea) + inheritanceCost;
		}

		// Cost of descending into child2
		/** @type {number} */ var cost2;
		if (child2.IsLeaf())
		{
			aabb.Combine2(leafAABB, child2.aabb);
			cost2 = aabb.GetPerimeter() + inheritanceCost;
		}
		else
		{
			aabb.Combine2(leafAABB, child2.aabb);
			oldArea = child2.aabb.GetPerimeter();
			newArea = aabb.GetPerimeter();
			cost2 = newArea - oldArea + inheritanceCost;
		}

		// Descend according to the minimum cost.
		if (cost < cost1 && cost < cost2)
		{
			break;
		}

		// Descend
		if (cost1 < cost2)
		{
			index = child1;
		}
		else
		{
			index = child2;
		}
	}

	/** @type {box2d.b2TreeNode} */ var sibling = index;

	// Create a parent for the siblings.
	/** @type {box2d.b2TreeNode} */ var oldParent = sibling.parent;
	/** @type {box2d.b2TreeNode} */ var newParent = this.AllocateNode();
	newParent.parent = oldParent;
	newParent.userData = null;
	newParent.aabb.Combine2(leafAABB, sibling.aabb);
	newParent.height = sibling.height + 1;

	if (oldParent)
	{
		// The sibling was not the root.
		if (oldParent.child1 === sibling)
		{
			oldParent.child1 = newParent;
		}
		else
		{
			oldParent.child2 = newParent;
		}

		newParent.child1 = sibling;
		newParent.child2 = leaf;
		sibling.parent = newParent;
		leaf.parent = newParent;
	}
	else
	{
		// The sibling was the root.
		newParent.child1 = sibling;
		newParent.child2 = leaf;
		sibling.parent = newParent;
		leaf.parent = newParent;
		this.m_root = newParent;
	}

	// Walk back up the tree fixing heights and AABBs
	index = leaf.parent;
	while (index !== null)
	{
		index = this.Balance(index);

		child1 = index.child1;
		child2 = index.child2;

		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 !== null); }
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 !== null); }

		index.height = 1 + box2d.b2Max(child1.height, child2.height);
		index.aabb.Combine2(child1.aabb, child2.aabb);

		index = index.parent;
	}

	//this.Validate();
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} leaf
 */
box2d.b2DynamicTree.prototype.RemoveLeaf = function (leaf)
{
	if (leaf === this.m_root)
	{
		this.m_root = null;
		return;
	}

	/** @type {box2d.b2TreeNode} */ var parent = leaf.parent;
	/** @type {box2d.b2TreeNode} */ var grandParent = parent.parent;
	/** @type {box2d.b2TreeNode} */ var sibling;
	if (parent.child1 === leaf)
	{
		sibling = parent.child2;
	}
	else
	{
		sibling = parent.child1;
	}

	if (grandParent)
	{
		// Destroy parent and connect sibling to grandParent.
		if (grandParent.child1 === parent)
		{
			grandParent.child1 = sibling;
		}
		else
		{
			grandParent.child2 = sibling;
		}
		sibling.parent = grandParent;
		this.FreeNode(parent);

		// Adjust ancestor bounds.
		/** @type {box2d.b2TreeNode} */ var index = grandParent;
		while (index)
		{
			index = this.Balance(index);

			/** @type {box2d.b2TreeNode} */ var child1 = index.child1;
			/** @type {box2d.b2TreeNode} */ var child2 = index.child2;

			index.aabb.Combine2(child1.aabb, child2.aabb);
			index.height = 1 + box2d.b2Max(child1.height, child2.height);

			index = index.parent;
		}
	}
	else
	{
		this.m_root = sibling;
		sibling.parent = null;
		this.FreeNode(parent);
	}

	//this.Validate();
}

/**
 * Perform a left or right rotation if node A is imbalanced.
 * Returns the new root index.
 * @export 
 * @param {box2d.b2TreeNode} A 
 * @return {box2d.b2TreeNode} 
 */
box2d.b2DynamicTree.prototype.Balance = function (A)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(A !== null); }

	if (A.IsLeaf() || A.height < 2)
	{
		return A;
	}

	/** @type {box2d.b2TreeNode} */ var B = A.child1;
	/** @type {box2d.b2TreeNode} */ var C = A.child2;

	/** @type {number} */ var balance = C.height - B.height;

	// Rotate C up
	if (balance > 1)
	{
		/** @type {box2d.b2TreeNode} */ var F = C.child1;
		/** @type {box2d.b2TreeNode} */ var G = C.child2;

		// Swap A and C
		C.child1 = A;
		C.parent = A.parent;
		A.parent = C;

		// A's old parent should point to C
		if (C.parent !== null)
		{
			if (C.parent.child1 === A)
			{
				C.parent.child1 = C;
			}
			else
			{
				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(C.parent.child2 === A); }
				C.parent.child2 = C;
			}
		}
		else
		{
			this.m_root = C;
		}

		// Rotate
		if (F.height > G.height)
		{
			C.child2 = F;
			A.child2 = G;
			G.parent = A;
			A.aabb.Combine2(B.aabb, G.aabb);
			C.aabb.Combine2(A.aabb, F.aabb);

			A.height = 1 + box2d.b2Max(B.height, G.height);
			C.height = 1 + box2d.b2Max(A.height, F.height);
		}
		else
		{
			C.child2 = G;
			A.child2 = F;
			F.parent = A;
			A.aabb.Combine2(B.aabb, F.aabb);
			C.aabb.Combine2(A.aabb, G.aabb);

			A.height = 1 + box2d.b2Max(B.height, F.height);
			C.height = 1 + box2d.b2Max(A.height, G.height);
		}

		return C;
	}
	
	// Rotate B up
	if (balance < -1)
	{
		/** @type {box2d.b2TreeNode} */ var D = B.child1;
		/** @type {box2d.b2TreeNode} */ var E = B.child2;

		// Swap A and B
		B.child1 = A;
		B.parent = A.parent;
		A.parent = B;

		// A's old parent should point to B
		if (B.parent !== null)
		{
			if (B.parent.child1 === A)
			{
				B.parent.child1 = B;
			}
			else
			{
				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(B.parent.child2 === A); }
				B.parent.child2 = B;
			}
		}
		else
		{
			this.m_root = B;
		}

		// Rotate
		if (D.height > E.height)
		{
			B.child2 = D;
			A.child1 = E;
			E.parent = A;
			A.aabb.Combine2(C.aabb, E.aabb);
			B.aabb.Combine2(A.aabb, D.aabb);

			A.height = 1 + box2d.b2Max(C.height, E.height);
			B.height = 1 + box2d.b2Max(A.height, D.height);
		}
		else
		{
			B.child2 = E;
			A.child1 = D;
			D.parent = A;
			A.aabb.Combine2(C.aabb, D.aabb);
			B.aabb.Combine2(A.aabb, E.aabb);

			A.height = 1 + box2d.b2Max(C.height, D.height);
			B.height = 1 + box2d.b2Max(A.height, E.height);
		}

		return B;
	}

	return A;
}

/** 
 * Compute the height of the binary tree in O(N) time. Should 
 * not be called often. 
 * @export 
 * @return {number} 
 */
box2d.b2DynamicTree.prototype.GetHeight = function ()
{
	if (this.m_root === null)
	{
		return 0;
	}

	return this.m_root.height;
}

/** 
 * Get the ratio of the sum of the node areas to the root area. 
 * @export 
 * @return {number} 
 */
box2d.b2DynamicTree.prototype.GetAreaRatio = function ()
{
	if (this.m_root === null)
	{
		return 0;
	}

	/** @type {box2d.b2TreeNode} */ var root = this.m_root;
	/** @type {number} */ var rootArea = root.aabb.GetPerimeter();

	var GetAreaNode = function (node)
	{
		if (node === null)
		{
			return 0;
		}

		if (node.IsLeaf())
		{
			return 0;
		}

		/** @type {number} */ var area = node.aabb.GetPerimeter();
		area += GetAreaNode(node.child1);
		area += GetAreaNode(node.child2);
		return area;
	}
	/** @type {number} */ var totalArea = GetAreaNode(this.m_root);

	/*
	float32 totalArea = 0.0;
	for (int32 i = 0; i < m_nodeCapacity; ++i)
	{
		const b2TreeNode* node = m_nodes + i;
		if (node.height < 0)
		{
			// Free node in pool
			continue;
		}

		totalArea += node.aabb.GetPerimeter();
	}
	*/

	return totalArea / rootArea;
}

/** 
 * Compute the height of a sub-tree. 
 * @export 
 * @return {number} 
 * @param {box2d.b2TreeNode} node 
 */
box2d.b2DynamicTree.prototype.ComputeHeightNode = function (node)
{
	if (node.IsLeaf())
	{
		return 0;
	}

	/** @type {number} */ var height1 = this.ComputeHeightNode(node.child1);
	/** @type {number} */ var height2 = this.ComputeHeightNode(node.child2);
	return 1 + box2d.b2Max(height1, height2);
}

/**
 * @export 
 * @return {number} 
 */
box2d.b2DynamicTree.prototype.ComputeHeight = function ()
{
	/** @type {number} */ var height = this.ComputeHeightNode(this.m_root);
	return height;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} index 
 */
box2d.b2DynamicTree.prototype.ValidateStructure = function (index)
{
	if (index === null)
	{
		return;
	}

	if (index === this.m_root)
	{
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(index.parent === null); }
	}

	/** @type {box2d.b2TreeNode} */ var node = index;

	/** @type {box2d.b2TreeNode} */ var child1 = node.child1;
	/** @type {box2d.b2TreeNode} */ var child2 = node.child2;

	if (node.IsLeaf())
	{
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 === null); }
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 === null); }
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === 0); }
		return;
	}

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1.parent === index); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2.parent === index); }

	this.ValidateStructure(child1);
	this.ValidateStructure(child2);
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} index
 */
box2d.b2DynamicTree.prototype.ValidateMetrics = function (index)
{
	if (index === null)
	{
		return;
	}

	/** @type {box2d.b2TreeNode} */ var node = index;

	/** @type {box2d.b2TreeNode} */ var child1 = node.child1;
	/** @type {box2d.b2TreeNode} */ var child2 = node.child2;

	if (node.IsLeaf())
	{
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 === null); }
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 === null); }
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === 0); }
		return;
	}

	/** @type {number} */ var height1 = child1.height;
	/** @type {number} */ var height2 = child2.height;
	/** @type {number} */ var height;
	height = 1 + box2d.b2Max(height1, height2);
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === height); }

	/** @type {box2d.b2AABB} */ var aabb = box2d.b2DynamicTree.s_aabb;
	aabb.Combine2(child1.aabb, child2.aabb);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(aabb.lowerBound === node.aabb.lowerBound); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(aabb.upperBound === node.aabb.upperBound); }

	this.ValidateMetrics(child1);
	this.ValidateMetrics(child2);
}

/** 
 * Validate this tree. For testing. 
 * @export 
 * @return {void} 
 */
box2d.b2DynamicTree.prototype.Validate = function ()
{
	this.ValidateStructure(this.m_root);
	this.ValidateMetrics(this.m_root);

	/** @type {number} */ var freeCount = 0;
	/** @type {box2d.b2TreeNode} */ var freeIndex = this.m_freeList;
	while (freeIndex !== null)
	{
		freeIndex = freeIndex.parent; //freeIndex = freeIndex.next;
		++freeCount;
	}

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.GetHeight() === this.ComputeHeight()); }
}

/** 
 * Get the maximum balance of an node in the tree. The balance 
 * is the difference in height of the two children of a node. 
 * @export 
 * @return {number} 
 */
box2d.b2DynamicTree.prototype.GetMaxBalance = function ()
{
	var GetMaxBalanceNode = function (node, maxBalance)
	{
		if (node === null)
		{
			return maxBalance;
		}

		if (node.height <= 1)
		{
			return maxBalance;
		}

		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.IsLeaf() === false); }

		/** @type {box2d.b2TreeNode} */ var child1 = node.child1;
		/** @type {box2d.b2TreeNode} */ var child2 = node.child2;
		/** @type {number} */ var balance = box2d.b2Abs(child2.height - child1.height);
		return box2d.b2Max(maxBalance, balance);
	}

	/** @type {number} */ var maxBalance = GetMaxBalanceNode(this.m_root, 0);

	/*
	int32 maxBalance = 0;
	for (int32 i = 0; i < m_nodeCapacity; ++i)
	{
		const b2TreeNode* node = m_nodes + i;
		if (node.height <= 1)
		{
			continue;
		}

		b2Assert(node.IsLeaf() === false);

		int32 child1 = node.child1;
		int32 child2 = node.child2;
		int32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].height);
		maxBalance = b2Max(maxBalance, balance);
	}
	*/

	return maxBalance;
}

/** 
 * Build an optimal tree. Very expensive. For testing. 
 * @export 
 * @return {void} 
 */
box2d.b2DynamicTree.prototype.RebuildBottomUp = function ()
{
	/* 
	int32* nodes = (int32*)b2Alloc(m_nodeCount * sizeof(int32));
	int32 count = 0;

	// Build array of leaves. Free the rest.
	for (int32 i = 0; i < m_nodeCapacity; ++i)
	{
		if (m_nodes[i].height < 0)
		{
			// free node in pool
			continue;
		}

		if (m_nodes[i].IsLeaf())
		{
			m_nodes[i].parent = b2_nullNode;
			nodes[count] = i;
			++count;
		}
		else
		{
			FreeNode(i);
		}
	}

	while (count > 1)
	{
		float32 minCost = b2_maxFloat;
		int32 iMin = -1, jMin = -1;
		for (int32 i = 0; i < count; ++i)
		{
			b2AABB aabbi = m_nodes[nodes[i]].aabb;

			for (int32 j = i + 1; j < count; ++j)
			{
				b2AABB aabbj = m_nodes[nodes[j]].aabb;
				b2AABB b;
				b.Combine(aabbi, aabbj);
				float32 cost = b.GetPerimeter();
				if (cost < minCost)
				{
					iMin = i;
					jMin = j;
					minCost = cost;
				}
			}
		}

		int32 index1 = nodes[iMin];
		int32 index2 = nodes[jMin];
		b2TreeNode* child1 = m_nodes + index1;
		b2TreeNode* child2 = m_nodes + index2;

		int32 parentIndex = AllocateNode();
		b2TreeNode* parent = m_nodes + parentIndex;
		parent.child1 = index1;
		parent.child2 = index2;
		parent.height = 1 + b2Max(child1.height, child2.height);
		parent.aabb.Combine(child1.aabb, child2.aabb);
		parent.parent = b2_nullNode;

		child1.parent = parentIndex;
		child2.parent = parentIndex;

		nodes[jMin] = nodes[count-1];
		nodes[iMin] = parentIndex;
		--count;
	}

	m_root = nodes[0];
	b2Free(nodes);
	*/

	this.Validate();
}

/**
 * Shift the world origin. Useful for large worlds.
 * The shift formula is: position -= newOrigin
 * @export 
 * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin
 * @return {void} 
 */
box2d.b2DynamicTree.prototype.ShiftOrigin = function (newOrigin)
{
	var ShiftOriginNode = function (node, newOrigin)
	{
		if (node === null)
		{
			return;
		}

		if (node.height <= 1)
		{
			return;
		}

		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.IsLeaf() === false); }

		/** @type {box2d.b2TreeNode} */ var child1 = node.child1;
		/** @type {box2d.b2TreeNode} */ var child2 = node.child2;
		ShiftOriginNode(child1, newOrigin);
		ShiftOriginNode(child2, newOrigin);

		node.aabb.lowerBound.SelfSub(newOrigin);
		node.aabb.upperBound.SelfSub(newOrigin);
	}

	ShiftOriginNode(this.m_root, newOrigin);

	/*
	// Build array of leaves. Free the rest.
	for (int32 i = 0; i < m_nodeCapacity; ++i)
	{
		m_nodes[i].aabb.lowerBound -= newOrigin;
		m_nodes[i].aabb.upperBound -= newOrigin;
	}
	*/
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2BroadPhase')

goog.require('box2d.b2Settings');
goog.require('box2d.b2DynamicTree')

/** 
 * @export 
 * @constructor
 */
box2d.b2Pair = function ()
{
};

/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2Pair.prototype.proxyA = null;
/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2Pair.prototype.proxyB = null;

/** 
 * The broad-phase is used for computing pairs and performing 
 * volume queries and ray casts. This broad-phase does not 
 * persist pairs. Instead, this reports potentially new pairs. 
 * It is up to the client to consume the new pairs and to track 
 * subsequent overlap. 
 * @export 
 * @constructor
 */
box2d.b2BroadPhase = function ()
{
	this.m_tree = new box2d.b2DynamicTree();
	this.m_moveBuffer = new Array();
	this.m_pairBuffer = new Array();
};

/**
 * @export 
 * @type {box2d.b2DynamicTree}
 */
box2d.b2BroadPhase.prototype.m_tree = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2BroadPhase.prototype.m_proxyCount = 0;

//box2d.b2BroadPhase.prototype.m_moveCapacity = 16;
/**
 * @export 
 * @type {number}
 */
box2d.b2BroadPhase.prototype.m_moveCount = 0;
/**
 * @export 
 * @type {Array.<box2d.b2TreeNode>}
 */
box2d.b2BroadPhase.prototype.m_moveBuffer = null;

//box2d.b2BroadPhase.prototype.m_pairCapacity = 16;
/**
 * @export 
 * @type {number}
 */
box2d.b2BroadPhase.prototype.m_pairCount = 0;
/**
 * @export 
 * @type {Array.<box2d.b2Pair>}
 */
box2d.b2BroadPhase.prototype.m_pairBuffer = null;

//box2d.b2BroadPhase.prototype.m_queryProxyId = 0;

/** 
 * Create a proxy with an initial AABB. Pairs are not reported 
 * until UpdatePairs is called. 
 * @export 
 * @return {box2d.b2TreeNode} 
 * @param {box2d.b2AABB} aabb 
 * @param {*} userData 
 */
box2d.b2BroadPhase.prototype.CreateProxy = function (aabb, userData)
{
	var proxy = this.m_tree.CreateProxy(aabb, userData);
	++this.m_proxyCount;
	this.BufferMove(proxy);
	return proxy;
}

/** 
 * Destroy a proxy. It is up to the client to remove any pairs. 
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.DestroyProxy = function (proxy)
{
	this.UnBufferMove(proxy);
	--this.m_proxyCount;
	this.m_tree.DestroyProxy(proxy);
}

/** 
 * Call MoveProxy as many times as you like, then when you are 
 * done call UpdatePairs to finalized the proxy pairs (for your 
 * time step). 
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Vec2} displacement 
 */
box2d.b2BroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement)
{
	var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
	if (buffer)
	{
		this.BufferMove(proxy);
	}
}

/** 
 * Call to trigger a re-processing of it's pairs on the next 
 * call to UpdatePairs. 
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.TouchProxy = function (proxy)
{
	this.BufferMove(proxy);
}

/** 
 * Get the fat AABB for a proxy. 
 * @export 
 * @return {box2d.b2AABB}
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.GetFatAABB = function (proxy)
{
	return this.m_tree.GetFatAABB(proxy);
}

/** 
 * Get user data from a proxy. Returns NULL if the id is 
 * invalid. 
 * @export 
 * @return {*} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.GetUserData = function (proxy)
{
	return this.m_tree.GetUserData(proxy);
}

/** 
 * Test overlap of fat AABBs. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2TreeNode} proxyA
 * @param {box2d.b2TreeNode} proxyB 
 */
box2d.b2BroadPhase.prototype.TestOverlap = function (proxyA, proxyB)
{
	var aabbA = this.m_tree.GetFatAABB(proxyA);
	var aabbB = this.m_tree.GetFatAABB(proxyB);
	return box2d.b2TestOverlapAABB(aabbA, aabbB);
}

/** 
 * Get the number of proxies. 
 * @export 
 * @return {number} 
 */
box2d.b2BroadPhase.prototype.GetProxyCount = function ()
{
	return this.m_proxyCount;
}

/** 
 * Get the height of the embedded tree. 
 * @export 
 * @return {number} 
 */
box2d.b2BroadPhase.prototype.GetTreeHeight = function ()
{
	return this.m_tree.GetHeight();
}

/** 
 * Get the balance of the embedded tree. 
 * @export 
 * @return {number} 
 */
box2d.b2BroadPhase.prototype.GetTreeBalance = function ()
{
	return this.m_tree.GetMaxBalance();
}

/** 
 * Get the quality metric of the embedded tree. 
 * @export 
 * @return {number} 
 */
box2d.b2BroadPhase.prototype.GetTreeQuality = function ()
{
	return this.m_tree.GetAreaRatio();
}

/** 
 * Shift the world origin. Useful for large worlds. The shift 
 * formula is: position -= newOrigin 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin
 */
box2d.b2BroadPhase.prototype.ShiftOrigin = function (newOrigin)
{
	this.m_tree.ShiftOrigin(newOrigin);
}

/** 
 * Update the pairs. This results in pair callbacks. This can 
 * only add pairs. 
 * @export 
 * @return {void} 
 * @param contactManager 
 */
box2d.b2BroadPhase.prototype.UpdatePairs = function (contactManager)
{
	// Reset pair buffer
	this.m_pairCount = 0;

	// Perform tree queries for all moving proxies.
	for (var i = 0; i < this.m_moveCount; ++i)
	{
		var queryProxy = this.m_moveBuffer[i];
		if (queryProxy === null)
		{
			continue;
		}

		var that = this;

		// This is called from box2d.b2DynamicTree::Query when we are gathering pairs.
		// bool b2BroadPhase::QueryCallback(int32 proxyId);
		var QueryCallback = function (proxy)
		{
			// A proxy cannot form a pair with itself.
			if (proxy.m_id === queryProxy.m_id)
			{
				return true;
			}

			// Grow the pair buffer as needed.
			if (that.m_pairCount === that.m_pairBuffer.length)
			{
				that.m_pairBuffer[that.m_pairCount] = new box2d.b2Pair();
			}

			var pair = that.m_pairBuffer[that.m_pairCount];
			//pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
			//pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
			if (proxy.m_id < queryProxy.m_id)
			{
				pair.proxyA = proxy;
				pair.proxyB = queryProxy;
			}
			else
			{
				pair.proxyA = queryProxy;
				pair.proxyB = proxy;
			}
			++that.m_pairCount;

			return true;
		};

		// We have to query the tree with the fat AABB so that
		// we don't fail to create a pair that may touch later.
		var fatAABB = this.m_tree.GetFatAABB(queryProxy);

		// Query tree, create pairs and add them pair buffer.
		this.m_tree.Query(QueryCallback, fatAABB);
	}

	// Reset move buffer
	this.m_moveCount = 0;

	// Sort the pair buffer to expose duplicates.
	this.m_pairBuffer.length = this.m_pairCount;
	this.m_pairBuffer.sort(box2d.b2PairLessThan);

	// Send the pairs back to the client.
	var i = 0;
	while (i < this.m_pairCount)
	{
		var primaryPair = this.m_pairBuffer[i];
		var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
		var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);

		contactManager.AddPair(userDataA, userDataB);
		++i;

		// Skip any duplicate pairs.
		while (i < this.m_pairCount)
		{
			var pair = this.m_pairBuffer[i];
			if (pair.proxyA.m_id !== primaryPair.proxyA.m_id || pair.proxyB.m_id !== primaryPair.proxyB.m_id)
			{
				break;
			}
			++i;
		}
	}

	// Try to keep the tree balanced.
	//this.m_tree.Rebalance(4);
}

/** 
 * Query an AABB for overlapping proxies. The callback class is 
 * called for each proxy that overlaps the supplied AABB. 
 * @export 
 * @return {void} 
 * @param callback 
 * @param {box2d.b2AABB} aabb 
 */
box2d.b2BroadPhase.prototype.Query = function (callback, aabb)
{
	this.m_tree.Query(callback, aabb);
}

/** 
 * Ray-cast against the proxies in the tree. This relies on the 
 * callback to perform a exact ray-cast in the case were the 
 * proxy contains a shape. The callback also performs the any 
 * collision filtering. This has performance roughly equal to k 
 * * log(n), where k is the number of collisions and n is the 
 * number of proxies in the tree.
 * @export 
 * @return {void} 
 * @param callback a callback class that is called for each proxy that is hit by the ray.
 * @param {box2d.b2RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
 */
box2d.b2BroadPhase.prototype.RayCast = function (callback, input)
{
	this.m_tree.RayCast(callback, input);
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.BufferMove = function (proxy)
{
	this.m_moveBuffer[this.m_moveCount] = proxy;
	++this.m_moveCount;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2TreeNode} proxy 
 */
box2d.b2BroadPhase.prototype.UnBufferMove = function (proxy)
{
	var i = this.m_moveBuffer.indexOf(proxy);
	this.m_moveBuffer[i] = null;
}

/** 
 * This is used to sort pairs. 
 * @return {number} 
 * @param {box2d.b2Pair} pair1 
 * @param {box2d.b2Pair} pair2 
 */
box2d.b2PairLessThan = function (pair1, pair2)
{
	if (pair1.proxyA.m_id === pair2.proxyA.m_id)
	{
		return pair1.proxyB.m_id - pair2.proxyB.m_id;
	}

	return pair1.proxyA.m_id - pair2.proxyA.m_id;
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ContactManager');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Collision');
goog.require('box2d.b2BroadPhase');
goog.require('box2d.b2ContactFactory');

/** 
 * Delegate of box2d.b2World. 
 * @constructor
 */
box2d.b2ContactManager = function ()
{
	this.m_broadPhase = new box2d.b2BroadPhase();

	this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator);
}

/**
 * @export 
 * @type {box2d.b2BroadPhase}
 */
box2d.b2ContactManager.prototype.m_broadPhase = null;
/**
 * @export 
 * @type {box2d.b2Contact} 
 */
box2d.b2ContactManager.prototype.m_contactList = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2ContactManager.prototype.m_contactCount = 0;
/**
 * @export 
 * @type {box2d.b2ContactFilter}
 */
box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter;
/**
 * @export 
 * @type {box2d.b2ContactListener}
 */
box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener;
/**
 * @export 
 * @type {*}
 */
box2d.b2ContactManager.prototype.m_allocator = null; 

/**
 * @export 
 * @type {box2d.b2ContactFactory}
 */
box2d.b2ContactManager.prototype.m_contactFactory = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} c
 */
box2d.b2ContactManager.prototype.Destroy = function (c)
{
	var fixtureA = c.GetFixtureA();
	var fixtureB = c.GetFixtureB();
	var bodyA = fixtureA.GetBody();
	var bodyB = fixtureB.GetBody();

	if (this.m_contactListener && c.IsTouching())
	{
		this.m_contactListener.EndContact(c);
	}

	// Remove from the world.
	if (c.m_prev)
	{
		c.m_prev.m_next = c.m_next;
	}

	if (c.m_next)
	{
		c.m_next.m_prev = c.m_prev;
	}

	if (c === this.m_contactList)
	{
		this.m_contactList = c.m_next;
	}

	// Remove from body 1
	if (c.m_nodeA.prev)
	{
		c.m_nodeA.prev.next = c.m_nodeA.next;
	}

	if (c.m_nodeA.next)
	{
		c.m_nodeA.next.prev = c.m_nodeA.prev;
	}

	if (c.m_nodeA === bodyA.m_contactList)
	{
		bodyA.m_contactList = c.m_nodeA.next;
	}

	// Remove from body 2
	if (c.m_nodeB.prev)
	{
		c.m_nodeB.prev.next = c.m_nodeB.next;
	}

	if (c.m_nodeB.next)
	{
		c.m_nodeB.next.prev = c.m_nodeB.prev;
	}

	if (c.m_nodeB === bodyB.m_contactList)
	{
		bodyB.m_contactList = c.m_nodeB.next;
	}

	// Call the factory.
	this.m_contactFactory.Destroy(c);
	--this.m_contactCount;
}

/** 
 * This is the top level collision call for the time step. Here 
 * all the narrow phase collision is processed for the world 
 * contact list. 
 * @export 
 * @return {void}
 */
box2d.b2ContactManager.prototype.Collide = function ()
{
	// Update awake contacts.
	var c = this.m_contactList;
	while (c)
	{
		var fixtureA = c.GetFixtureA();
		var fixtureB = c.GetFixtureB();
		var indexA = c.GetChildIndexA();
		var indexB = c.GetChildIndexB();
		var bodyA = fixtureA.GetBody();
		var bodyB = fixtureB.GetBody();

		// Is this contact flagged for filtering?
		if (c.m_flags & box2d.b2ContactFlag.e_filterFlag)
		{
			// Should these bodies collide?
			if (bodyB.ShouldCollide(bodyA) === false)
			{
				var cNuke = c;
				c = cNuke.m_next;
				this.Destroy(cNuke);
				continue;
			}

			// Check user filtering.
			if (this.m_contactFilter && this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) === false)
			{
				cNuke = c;
				c = cNuke.m_next;
				this.Destroy(cNuke);
				continue;
			}

			// Clear the filtering flag.
			c.m_flags &= ~box2d.b2ContactFlag.e_filterFlag;
		}

		var activeA = bodyA.IsAwake() && bodyA.m_type !== box2d.b2BodyType.b2_staticBody;
		var activeB = bodyB.IsAwake() && bodyB.m_type !== box2d.b2BodyType.b2_staticBody;

		// At least one body must be awake and it must be dynamic or kinematic.
		if (activeA === false && activeB === false)
		{
			c = c.m_next;
			continue;
		}

		var proxyA = fixtureA.m_proxies[indexA].proxy;
		var proxyB = fixtureB.m_proxies[indexB].proxy;
		var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);

		// Here we destroy contacts that cease to overlap in the broad-phase.
		if (overlap === false)
		{
			cNuke = c;
			c = cNuke.m_next;
			this.Destroy(cNuke);
			continue;
		}

		// The contact persists.
		c.Update(this.m_contactListener);
		c = c.m_next;
	}
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2ContactManager.prototype.FindNewContacts = function ()
{
	this.m_broadPhase.UpdatePairs(this);
}

/** 
 * Broad-phase callback. 
 * @export 
 * @return {void} 
 * @param {box2d.b2FixtureProxy} proxyUserDataA
 * @param {box2d.b2FixtureProxy} proxyUserDataB
 */
box2d.b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxyUserDataA instanceof box2d.b2FixtureProxy); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxyUserDataB instanceof box2d.b2FixtureProxy); }
	var proxyA = proxyUserDataA;//(proxyUserDataA instanceof box2d.b2FixtureProxy ? proxyUserDataA : null);
	var proxyB = proxyUserDataB;//(proxyUserDataB instanceof box2d.b2FixtureProxy ? proxyUserDataB : null);

	var fixtureA = proxyA.fixture;
	var fixtureB = proxyB.fixture;

	var indexA = proxyA.childIndex;
	var indexB = proxyB.childIndex;

	var bodyA = fixtureA.GetBody();
	var bodyB = fixtureB.GetBody();

	// Are the fixtures on the same body?
	if (bodyA === bodyB)
	{
		return;
	}

	// TODO_ERIN use a hash table to remove a potential bottleneck when both
	// bodies have a lot of contacts.
	// Does a contact already exist?
	var edge = bodyB.GetContactList();
	while (edge)
	{
		if (edge.other === bodyA)
		{
			var fA = edge.contact.GetFixtureA();
			var fB = edge.contact.GetFixtureB();
			var iA = edge.contact.GetChildIndexA();
			var iB = edge.contact.GetChildIndexB();

			if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB)
			{
				// A contact already exists.
				return;
			}

			if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA)
			{
				// A contact already exists.
				return;
			}
		}

		edge = edge.next;
	}

	// Does a joint override collision? Is at least one body dynamic?
	if (bodyB.ShouldCollide(bodyA) === false)
	{
		return;
	}

	// Check user filtering.
	if (this.m_contactFilter && this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) === false)
	{
		return;
	}

	// Call the factory.
	var c = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);
	if (c === null)
	{
		return;
	}

	// Contact creation may swap fixtures.
	fixtureA = c.GetFixtureA();
	fixtureB = c.GetFixtureB();
	indexA = c.GetChildIndexA();
	indexB = c.GetChildIndexB();
	bodyA = fixtureA.m_body;
	bodyB = fixtureB.m_body;

	// Insert into the world.
	c.m_prev = null;
	c.m_next = this.m_contactList;
	if (this.m_contactList !== null)
	{
		this.m_contactList.m_prev = c;
	}
	this.m_contactList = c;

	// Connect to island graph.

	// Connect to body A
	c.m_nodeA.contact = c;
	c.m_nodeA.other = bodyB;

	c.m_nodeA.prev = null;
	c.m_nodeA.next = bodyA.m_contactList;
	if (bodyA.m_contactList !== null)
	{
		bodyA.m_contactList.prev = c.m_nodeA;
	}
	bodyA.m_contactList = c.m_nodeA;

	// Connect to body B
	c.m_nodeB.contact = c;
	c.m_nodeB.other = bodyA;

	c.m_nodeB.prev = null;
	c.m_nodeB.next = bodyB.m_contactList;
	if (bodyB.m_contactList !== null)
	{
		bodyB.m_contactList.prev = c.m_nodeB;
	}
	bodyB.m_contactList = c.m_nodeB;

	// Wake up the bodies
	if (fixtureA.IsSensor() === false && fixtureB.IsSensor() === false)
	{
		bodyA.SetAwake(true);
		bodyB.SetAwake(true);
	}

	++this.m_contactCount;
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2JointFactory');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Joint');

/** 
 * @export 
 * @return {box2d.b2Joint}
 * @param {box2d.b2JointDef} def 
 * @param allocator 
 */
box2d.b2JointFactory.Create = function (def, allocator)
{
	var joint = null;

	switch (def.type)
	{
	case box2d.b2JointType.e_distanceJoint:
		{
			joint = new box2d.b2DistanceJoint((def instanceof box2d.b2DistanceJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_mouseJoint:
		{
			joint = new box2d.b2MouseJoint((def instanceof box2d.b2MouseJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_prismaticJoint:
		{
			joint = new box2d.b2PrismaticJoint((def instanceof box2d.b2PrismaticJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_revoluteJoint:
		{
			joint = new box2d.b2RevoluteJoint((def instanceof box2d.b2RevoluteJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_pulleyJoint:
		{
			joint = new box2d.b2PulleyJoint((def instanceof box2d.b2PulleyJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_gearJoint:
		{
			joint = new box2d.b2GearJoint((def instanceof box2d.b2GearJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_wheelJoint:
		{
			joint = new box2d.b2WheelJoint((def instanceof box2d.b2WheelJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_weldJoint:
		{
			joint = new box2d.b2WeldJoint((def instanceof box2d.b2WeldJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_frictionJoint:
		{
			joint = new box2d.b2FrictionJoint((def instanceof box2d.b2FrictionJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_ropeJoint:
		{
			joint = new box2d.b2RopeJoint((def instanceof box2d.b2RopeJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_motorJoint:
		{
			joint = new box2d.b2MotorJoint((def instanceof box2d.b2MotorJointDef ? def : null));
		}
		break;

	case box2d.b2JointType.e_areaJoint:
		{
			joint = new box2d.b2AreaJoint((def instanceof box2d.b2AreaJointDef ? def : null));
		}
		break;

	default:
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
		break;
	}

	return joint;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Joint} joint 
 * @param allocator 
 */
box2d.b2JointFactory.Destroy = function (joint, allocator)
{
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Draw');

goog.require('box2d.b2Settings');

/** 
 * Color for debug drawing. Each value has the range [0,1]. 
 * @export
 * @constructor
 * @param {number} rr
 * @param {number} gg
 * @param {number} bb
 */
box2d.b2Color = function (rr, gg, bb)
{
	this.r = rr;
	this.g = gg;
	this.b = bb;
}

/**
 * @export 
 * @type {number}
 */
box2d.b2Color.prototype.r = 0.5;
/**
 * @export 
 * @type {number}
 */
box2d.b2Color.prototype.g = 0.5;
/**
 * @export 
 * @type {number}
 */
box2d.b2Color.prototype.b = 0.5;

/**
 * @export
 * @return {box2d.b2Color}
 * @param {number} rr
 * @param {number} gg
 * @param {number} bb
 */
box2d.b2Color.prototype.SetRGB = function (rr, gg, bb)
{
	this.r = rr;
	this.g = gg;
	this.b = bb;
	return this;
}

/**
 * @export
 * @return {string}
 * @param {number=} alpha
 */
box2d.b2Color.prototype.MakeStyleString = function (alpha)
{
	var r = Math.round(Math.max(0, Math.min(255, this.r * 255)));
	var g = Math.round(Math.max(0, Math.min(255, this.g * 255)));
	var b = Math.round(Math.max(0, Math.min(255, this.b * 255)));
	var a = (typeof(alpha) === 'undefined')?(1.0):(Math.max(0, Math.min(1, alpha)));
	return box2d.b2Color.MakeStyleString(r, g, b, a);
}

/**
 * @export
 * @return {string}
 */
box2d.b2Color.MakeStyleString = function (r, g, b, a)
{
	if (a < 1)
	{
		return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	}
	else
	{
		return 'rgb(' + r + ',' + g + ',' + b + ')';
	}
}

/**
 * @export 
 * @const 
 * @type {box2d.b2Color}
 */
box2d.b2Color.RED = new box2d.b2Color(1,0,0);
/**
 * @export 
 * @const 
 * @type {box2d.b2Color}
 */
box2d.b2Color.GREEN	= new box2d.b2Color(0,1,0);
/**
 * @export 
 * @const 
 * @type {box2d.b2Color}
 */
box2d.b2Color.BLUE = new box2d.b2Color(0,0,1);

/** 
 * @export 
 * @enum
 */
box2d.b2DrawFlags = 
{
	e_none				: 0,
	e_shapeBit			: 0x0001, ///< draw shapes
	e_jointBit			: 0x0002, ///< draw joint connections
	e_aabbBit			: 0x0004, ///< draw axis aligned bounding boxes
	e_pairBit			: 0x0008, ///< draw broad-phase pairs
	e_centerOfMassBit	: 0x0010, ///< draw center of mass frame
	e_controllerBit		: 0x0020, /// @see box2d.b2Controller list
	e_all				: 0x003f
};
goog.exportProperty(box2d.b2DrawFlags, 'e_none'           , box2d.b2DrawFlags.e_none           );
goog.exportProperty(box2d.b2DrawFlags, 'e_shapeBit'       , box2d.b2DrawFlags.e_shapeBit       );
goog.exportProperty(box2d.b2DrawFlags, 'e_jointBit'       , box2d.b2DrawFlags.e_jointBit       );
goog.exportProperty(box2d.b2DrawFlags, 'e_aabbBit'        , box2d.b2DrawFlags.e_aabbBit        );
goog.exportProperty(box2d.b2DrawFlags, 'e_pairBit'        , box2d.b2DrawFlags.e_pairBit        );
goog.exportProperty(box2d.b2DrawFlags, 'e_centerOfMassBit', box2d.b2DrawFlags.e_centerOfMassBit);
goog.exportProperty(box2d.b2DrawFlags, 'e_controllerBit'  , box2d.b2DrawFlags.e_controllerBit  );
goog.exportProperty(box2d.b2DrawFlags, 'e_all'            , box2d.b2DrawFlags.e_all            );

/** 
 * Implement and register this class with a b2World to provide 
 * debug drawing of physics entities in your game. 
 * @export 
 * @constructor
 */
box2d.b2Draw = function ()
{
}

/**
 * @export 
 * @type {box2d.b2DrawFlags} 
 */
box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none;

/** 
 * Set the drawing flags. 
 * @export 
 * @return {void} 
 * @param {box2d.b2DrawFlags} flags 
 */
box2d.b2Draw.prototype.SetFlags = function (flags)
{
	this.m_drawFlags = flags;
}

/** 
 * Get the drawing flags. 
 * @export 
 * @return {box2d.b2DrawFlags}
 */
box2d.b2Draw.prototype.GetFlags = function ()
{
	return this.m_drawFlags;
}

/** 
 * Append flags to the current flags. 
 * @export 
 * @return {void} 
 * @param {box2d.b2DrawFlags} flags 
 */
box2d.b2Draw.prototype.AppendFlags = function (flags)
{
	this.m_drawFlags |= flags;
}

/** 
 * Clear flags from the current flags. 
 * @export 
 * @return {void} 
 * @param {box2d.b2DrawFlags} flags 
 */
box2d.b2Draw.prototype.ClearFlags = function (flags)
{
	this.m_drawFlags &= ~flags;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2Draw.prototype.PushTransform = function (xf)
{
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2Draw.prototype.PopTransform = function (xf)
{
}

/** 
 * Draw a closed polygon provided in CCW order. 
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number} vertexCount
 * @param {box2d.b2Color} color 
 */
box2d.b2Draw.prototype.DrawPolygon = function (vertices, vertexCount, color)
{
}

/** 
 * Draw a solid closed polygon provided in CCW order. 
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number} vertexCount
 * @param {box2d.b2Color} color 
 */
box2d.b2Draw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
{
}

/** 
 * Draw a circle. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center
 * @param {number} radius
 * @param {box2d.b2Color} color 
 */
box2d.b2Draw.prototype.DrawCircle = function (center, radius, color)
{
}

/** 
 * Draw a solid circle. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center
 * @param {number} radius
 * @param {box2d.b2Vec2} axis
 * @param {box2d.b2Color} color 
 */
box2d.b2Draw.prototype.DrawSolidCircle = function (center, radius, axis, color)
{
}

/** 
 * Draw a line segment. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p1
 * @param {box2d.b2Vec2} p2
 * @param {box2d.b2Color} color 
 */
box2d.b2Draw.prototype.DrawSegment = function (p1, p2, color)
{
}

/** 
 * Draw a transform. Choose your own length scale. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf a transform.
 */
box2d.b2Draw.prototype.DrawTransform = function (xf)
{
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Fixture');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Collision');
goog.require('box2d.b2Shape');

/** 
 * This holds contact filtering data. 
 * @export 
 * @constructor 
 */
box2d.b2Filter = function ()
{
};

/** 
 * The collision category bits. Normally you would just set one 
 * bit. 
 * @export 
 * @type {number}
 */
box2d.b2Filter.prototype.categoryBits = 0x0001;

/** 
 * The collision mask bits. This states the categories that this 
 * shape would accept for collision. 
 * @export 
 * @type {number}
 */
box2d.b2Filter.prototype.maskBits = 0xFFFF;

/** 
 * Collision groups allow a certain group of objects to never 
 * collide (negative) or always collide (positive). Zero means 
 * no collision group. Non-zero group filtering always wins 
 * against the mask bits. 
 * @export 
 * @type {number}
 */
box2d.b2Filter.prototype.groupIndex = 0;

/** 
 * @export 
 * @return {box2d.b2Filter}
 */
box2d.b2Filter.prototype.Clone = function ()
{
	return new box2d.b2Filter().Copy(this);
}

/** 
 * @export 
 * @return {box2d.b2Filter} 
 * @param {box2d.b2Filter} other 
 */
box2d.b2Filter.prototype.Copy = function (other)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }
	this.categoryBits = other.categoryBits;
	this.maskBits = other.maskBits;
	this.groupIndex = other.groupIndex;
	return this;
}

/** 
 * A fixture definition is used to create a fixture. This class 
 * defines an abstract fixture definition. You can reuse fixture 
 * definitions safely. 
 * @export 
 * @constructor 
 */
box2d.b2FixtureDef = function ()
{
	this.filter = new box2d.b2Filter();
}

/** 
 * The shape, this must be set. The shape will be cloned, so you 
 * can create the shape on the stack. 
 * @export 
 * @type {box2d.b2Shape}
 */
box2d.b2FixtureDef.prototype.shape = null;

/** 
 * Use this to store application specific fixture data. 
 * @export 
 * @type {*}
 */
box2d.b2FixtureDef.prototype.userData = null;

/** 
 * The friction coefficient, usually in the range [0,1]. 
 * @export 
 * @type {number}
 */
box2d.b2FixtureDef.prototype.friction = 0.2;

/** 
 * The restitution (elasticity) usually in the range [0,1]. 
 * @export 
 * @type {number}
 */
box2d.b2FixtureDef.prototype.restitution = 0;

/** 
 * The density, usually in kg/m^2. 
 * @export 
 * @type {number}
 */
box2d.b2FixtureDef.prototype.density = 0;

/** 
 * A sensor shape collects contact information but never 
 * generates a collision response. 
 * @export 
 * @type {boolean}
 */
box2d.b2FixtureDef.prototype.isSensor = false;

/** 
 * Contact filtering data. 
 * @export 
 * @type {box2d.b2Filter}
 */
box2d.b2FixtureDef.prototype.filter = null;

/** 
 * This proxy is used internally to connect fixtures to the 
 * broad-phase. 
 * @export 
 * @constructor
 */
box2d.b2FixtureProxy = function ()
{
	this.aabb = new box2d.b2AABB();
};

/**
 * @export 
 * @type {box2d.b2AABB}
 */
box2d.b2FixtureProxy.prototype.aabb = null;
/**
 * @export 
 * @type {box2d.b2Fixture}
 */
box2d.b2FixtureProxy.prototype.fixture = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2FixtureProxy.prototype.childIndex = 0;
/**
 * @export 
 * @type {box2d.b2TreeNode}
 */
box2d.b2FixtureProxy.prototype.proxy = null;

/** 
 * @export 
 * @return {Array.<box2d.b2FixtureProxy>} 
 * @param {number} length 
 */
box2d.b2FixtureProxy.MakeArray = function (length)
{
	return box2d.b2MakeArray(length, function (i) { return new box2d.b2FixtureProxy(); });
}

/** 
 * A fixture is used to attach a shape to a body for collision 
 * detection. A fixture inherits its transform from its parent. 
 * Fixtures hold additional non-geometric data such as friction, 
 * collision filters, etc. 
 * Fixtures are created via box2d.b2Body::CreateFixture. 
 * warning you cannot reuse fixtures.
 * @export 
 * @constructor 
 */
box2d.b2Fixture = function ()
{
//	this.m_proxies = new Array();
	this.m_proxyCount = 0;

	this.m_filter = new box2d.b2Filter();
}

/**
 * @export 
 * @type {number}
 */
box2d.b2Fixture.prototype.m_density = 0;

/**
 * @export 
 * @type {box2d.b2Fixture}
 */
box2d.b2Fixture.prototype.m_next = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2Fixture.prototype.m_body = null;

/**
 * @export 
 * @type {box2d.b2Shape}
 */
box2d.b2Fixture.prototype.m_shape = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2Fixture.prototype.m_friction = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Fixture.prototype.m_restitution = 0;

/**
 * @export 
 * @type {Array.<box2d.b2FixtureProxy>}
 */
box2d.b2Fixture.prototype.m_proxies = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Fixture.prototype.m_proxyCount = 0;

/**
 * @export 
 * @type {box2d.b2Filter}
 */
box2d.b2Fixture.prototype.m_filter = null;

/**
 * @export 
 * @type {boolean}
 */
box2d.b2Fixture.prototype.m_isSensor = false;

/**
 * @export 
 * @type {*}
 */
box2d.b2Fixture.prototype.m_userData = null;

/** 
 * Get the type of the child shape. You can use this to down 
 * cast to the concrete shape. 
 * @export 
 * @return {box2d.b2ShapeType} the shape type.
 */
box2d.b2Fixture.prototype.GetType = function ()
{
	return this.m_shape.GetType();
}

/** 
 * Get the child shape. You can modify the child shape, however 
 * you should not change the number of vertices because this 
 * will crash some collision caching mechanisms. 
 * Manipulating the shape may lead to non-physical behavior.
 * @export 
 * @return {box2d.b2Shape}
 */
box2d.b2Fixture.prototype.GetShape = function ()
{
	return this.m_shape;
}

/** 
 * Is this fixture a sensor (non-solid)? 
 * @export 
 * @return {boolean} true if the shape is a sensor.
 */
box2d.b2Fixture.prototype.IsSensor = function ()
{
	return this.m_isSensor;
}

/** 
 * Get the contact filtering data. 
 * @export 
 * @return {box2d.b2Filter} 
 */
box2d.b2Fixture.prototype.GetFilterData = function ()
{
	return this.m_filter;
}

/** 
 * Get the user data that was assigned in the fixture 
 * definition. Use this to store your application specific data.
 * @export 
 * @return {*} 
 */
box2d.b2Fixture.prototype.GetUserData = function ()
{
	return this.m_userData;
}

/** 
 * Set the user data. Use this to store your application 
 * specific data. 
 * @export 
 * @param {*} data 
 */
box2d.b2Fixture.prototype.SetUserData = function (data)
{
	this.m_userData = data;
}

/** 
 * Get the parent body of this fixture. This is NULL if the 
 * fixture is not attached. 
 * @export 
 * @return {box2d.b2Body} the parent body.
 */
box2d.b2Fixture.prototype.GetBody = function ()
{
	return this.m_body;
}

/** 
 * Get the next fixture in the parent body's fixture list. 
 * @export 
 * @return {box2d.b2Fixture} the next shape.
 */
box2d.b2Fixture.prototype.GetNext = function ()
{
	return this.m_next;
}

/** 
 * Set the density of this fixture. This will _not_ 
 * automatically adjust the mass of the body. You must call 
 * box2d.b2Body::ResetMassData to update the body's mass. 
 * @export 
 * @return {void} 
 * @param {number} density 
 */
box2d.b2Fixture.prototype.SetDensity = function (density)
{
	this.m_density = density;
}

/** 
 * Get the density of this fixture. 
 * @export 
 * @return {number} 
 */
box2d.b2Fixture.prototype.GetDensity = function ()
{
	return this.m_density;
}

/** 
 * Get the coefficient of friction. 
 * @export 
 * @return {number} 
 */
box2d.b2Fixture.prototype.GetFriction = function ()
{
	return this.m_friction;
}

/** 
 * Set the coefficient of friction. This will _not_ change the 
 * friction of existing contacts. 
 * @export 
 * @return {void} 
 * @param {number} friction 
 */
box2d.b2Fixture.prototype.SetFriction = function (friction)
{
	this.m_friction = friction;
}

/** 
 * Get the coefficient of restitution. 
 * @export 
 * @return {number} 
 */
box2d.b2Fixture.prototype.GetRestitution = function ()
{
	return this.m_restitution;
}

/** 
 * Set the coefficient of restitution. This will _not_ change 
 * the restitution of existing contacts. 
 * @export 
 * @return {void} 
 * @param {number} restitution 
 */
box2d.b2Fixture.prototype.SetRestitution = function (restitution)
{
	this.m_restitution = restitution;
}

/** 
 * Test a point for containment in this fixture. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Vec2} p a point in world coordinates.
 */
box2d.b2Fixture.prototype.TestPoint = function (p)
{
	return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
}

/** 
 * Cast a ray against this shape. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output ray-cast results.
 * @param {box2d.b2RayCastInput} input the ray-cast input parameters.
 * @param {number} childIndex 
 */
box2d.b2Fixture.prototype.RayCast = function (output, input, childIndex)
{
	return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);
}

/** 
 * Get the mass data for this fixture. The mass data is based on 
 * the density and the shape. The rotational inertia is about 
 * the shape's origin. This operation may be expensive. 
 * @export 
 * @return {box2d.b2MassData} 
 * @param {box2d.b2MassData=} massData 
 */
box2d.b2Fixture.prototype.GetMassData = function (massData)
{
	massData = massData || new box2d.b2MassData();

	this.m_shape.ComputeMass(massData, this.m_density);

	return massData;
}

/** 
 * Get the fixture's AABB. This AABB may be enlarge and/or 
 * stale. If you need a more accurate AABB, compute it using the 
 * shape and the body transform. 
 * @export 
 * @return {box2d.b2AABB} 
 * @param {number} childIndex 
 */
box2d.b2Fixture.prototype.GetAABB = function (childIndex)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= childIndex && childIndex < this.m_proxyCount); }
	return this.m_proxies[childIndex].aabb;
}

/** 
 * We need separation create/destroy functions from the 
 * constructor/destructor because the destructor cannot access 
 * the allocator (no destructor arguments allowed by C++). 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} body 
 * @param {box2d.b2FixtureDef} def
 */
box2d.b2Fixture.prototype.Create = function (body, def)
{
	this.m_userData = def.userData;
	this.m_friction = def.friction;
	this.m_restitution = def.restitution;

	this.m_body = body;
	this.m_next = null;

	this.m_filter.Copy(def.filter);

	this.m_isSensor = def.isSensor;

	this.m_shape = def.shape.Clone();

	// Reserve proxy space
//	var childCount = m_shape->GetChildCount();
//	m_proxies = (box2d.b2FixtureProxy*)allocator->Allocate(childCount * sizeof(box2d.b2FixtureProxy));
//	for (int32 i = 0; i < childCount; ++i)
//	{
//		m_proxies[i].fixture = NULL;
//		m_proxies[i].proxyId = box2d.b2BroadPhase::e_nullProxy;
//	}
	this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount());
	this.m_proxyCount = 0;

	this.m_density = def.density;
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Fixture.prototype.Destroy = function ()
{
	// The proxies must be destroyed before calling this.
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_proxyCount === 0); }

	// Free the proxy array.
//	int32 childCount = m_shape->GetChildCount();
//	allocator->Free(m_proxies, childCount * sizeof(box2d.b2FixtureProxy));
//	m_proxies = NULL;

	this.m_shape = null;
}

/** 
 * These support body activation/deactivation. 
 * @export 
 * @return {void} 
 * @param {box2d.b2BroadPhase} broadPhase 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2Fixture.prototype.CreateProxies = function (broadPhase, xf)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_proxyCount === 0); }

	// Create proxies in the broad-phase.
	this.m_proxyCount = this.m_shape.GetChildCount();

	for (var i = 0; i < this.m_proxyCount; ++i)
	{
		var proxy = this.m_proxies[i];
		this.m_shape.ComputeAABB(proxy.aabb, xf, i);
		proxy.proxy = broadPhase.CreateProxy(proxy.aabb, proxy);
		proxy.fixture = this;
		proxy.childIndex = i;
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2BroadPhase} broadPhase 
 */
box2d.b2Fixture.prototype.DestroyProxies = function (broadPhase)
{
	// Destroy proxies in the broad-phase.
	for (var i = 0; i < this.m_proxyCount; ++i)
	{
		var proxy = this.m_proxies[i];
		broadPhase.DestroyProxy(proxy.proxy);
		proxy.proxy = null;
	}
	
	this.m_proxyCount = 0;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2BroadPhase} broadPhase 
 * @param {box2d.b2Transform} transform1
 * @param {box2d.b2Transform} transform2
 */
box2d.b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2)
{
	if (this.m_proxyCount === 0)
	{	
		return;
	}

	for (var i = 0; i < this.m_proxyCount; ++i)
	{
		var proxy = this.m_proxies[i];

		// Compute an AABB that covers the swept shape (may miss some rotation effect).
		var aabb1 = box2d.b2Fixture.prototype.Synchronize.s_aabb1;
		var aabb2 = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
		this.m_shape.ComputeAABB(aabb1, transform1, i);
		this.m_shape.ComputeAABB(aabb2, transform2, i);
	
		proxy.aabb.Combine2(aabb1, aabb2);
	
		var displacement = box2d.b2SubVV(transform2.p, transform1.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
	
		broadPhase.MoveProxy(proxy.proxy, proxy.aabb, displacement);
	}
}
box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB();
box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB();
box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2();

/** 
 * Set the contact filtering data. This will not update contacts 
 * until the next time step when either parent body is active 
 * and awake. 
 * This automatically calls Refilter. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Filter} filter 
 */
box2d.b2Fixture.prototype.SetFilterData = function (filter)
{
	this.m_filter.Copy(filter);

	this.Refilter();
}

/**
 * Call this if you want to establish collision that was 
 * previously disabled by box2d.b2ContactFilter::ShouldCollide. 
 * @export 
 * @return {void} 
 */
box2d.b2Fixture.prototype.Refilter = function ()
{
	if (this.m_body)
	{
		return;
	}

	// Flag associated contacts for filtering.
	var edge = this.m_body.GetContactList();

	while (edge)
	{
		var contact = edge.contact;
		var fixtureA = contact.GetFixtureA();
		var fixtureB = contact.GetFixtureB();
		if (fixtureA === this || fixtureB === this)
		{
			contact.FlagForFiltering();
		}

		edge = edge.next;
	}

	var world = this.m_body.GetWorld();

	if (world === null)
	{
		return;
	}

	// Touch each proxy so that new pairs may be created
	var broadPhase = world.m_contactManager.m_broadPhase;
	for (var i = 0; i < this.m_proxyCount; ++i)
	{
		broadPhase.TouchProxy(this.m_proxies[i].proxy);
	}
}

/** 
 * Set if this fixture is a sensor. 
 * @export 
 * @return {void} 
 * @param {boolean} sensor
 */
box2d.b2Fixture.prototype.SetSensor = function (sensor)
{
	if (sensor !== this.m_isSensor)
	{
		this.m_body.SetAwake(true);
		this.m_isSensor = sensor;
	}
}

/** 
 * Dump this fixture to the log file. 
 * @export 
 * @return {void}
 * @param {number} bodyIndex 
 */
box2d.b2Fixture.prototype.Dump = function (bodyIndex)
{
	if (box2d.DEBUG)
	{
		box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n");
		box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction);
		box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution);
		box2d.b2Log("    fd.density = %.15f;\n", this.m_density);
		box2d.b2Log("    fd.isSensor = %s;\n", (this.m_isSensor)?('true'):('false'));
		box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits);
		box2d.b2Log("    fd.filter.maskBits = %d;\n", this.m_filter.maskBits);
		box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex);
	
		this.m_shape.Dump();
	
		box2d.b2Log("\n");
		box2d.b2Log("    fd.shape = shape;\n");
		box2d.b2Log("\n");
		box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", bodyIndex);
	}
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Body');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');
goog.require('box2d.b2Fixture');

/**
 * The body type.
 * static: zero mass, zero velocity, may be manually moved
 * kinematic: zero mass, non-zero velocity set by user, moved by solver
 * dynamic: positive mass, non-zero velocity determined by forces, moved by solver
 * @export 
 * @enum
 */
box2d.b2BodyType = 
{
	b2_unknown			: -1,
	b2_staticBody		: 0,
	b2_kinematicBody	: 1,
	b2_dynamicBody		: 2,
	b2_bulletBody		: 3 // TODO_ERIN
};
goog.exportProperty(box2d.b2BodyType, 'b2_unknown'      , box2d.b2BodyType.b2_unknown      );
goog.exportProperty(box2d.b2BodyType, 'b2_staticBody'   , box2d.b2BodyType.b2_staticBody   );
goog.exportProperty(box2d.b2BodyType, 'b2_kinematicBody', box2d.b2BodyType.b2_kinematicBody);
goog.exportProperty(box2d.b2BodyType, 'b2_dynamicBody'  , box2d.b2BodyType.b2_dynamicBody  );
goog.exportProperty(box2d.b2BodyType, 'b2_bulletBody'   , box2d.b2BodyType.b2_bulletBody   );

/** 
 * A body definition holds all the data needed to construct a 
 * rigid body. 
 * You can safely re-use body definitions. Shapes are added to a 
 * body after construction. 
 * @export 
 * @constructor
 */
box2d.b2BodyDef = function ()
{
	this.position = new box2d.b2Vec2(0, 0);
	this.linearVelocity = new box2d.b2Vec2(0, 0);
}

/** 
 * The body type: static, kinematic, or dynamic. 
 * Note: if a dynamic body would have zero mass, the mass is set 
 * to one. 
 * @export
 * @type {box2d.b2BodyType} 
 */ 
box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody;

/** 
 * The world position of the body. Avoid creating bodies at the 
 * origin since this can lead to many overlapping shapes. 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2BodyDef.prototype.position = null;

/** 
 * The world angle of the body in radians. 
 * @export 
 * @type {number} 
 */
box2d.b2BodyDef.prototype.angle = 0;

/** 
 * The linear velocity of the body's origin in world 
 * co-ordinates. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2BodyDef.prototype.linearVelocity = null;

/** 
 * The angular velocity of the body. 
 * @export 
 * @type {number}
 */
box2d.b2BodyDef.prototype.angularVelocity = 0;

/** 
 * Linear damping is use to reduce the linear velocity. The 
 * damping parameter can be larger than 1.0f but the damping 
 * effect becomes sensitive to the time step when the damping 
 * parameter is large. 
 * @export 
 * @type {number}
 */
box2d.b2BodyDef.prototype.linearDamping = 0;

/** 
 * Angular damping is use to reduce the angular velocity. The 
 * damping parameter can be larger than 1.0f but the damping 
 * effect becomes sensitive to the time step when the damping 
 * parameter is large. 
 * @export 
 * @type {number}
 */
box2d.b2BodyDef.prototype.angularDamping = 0;

/** 
 * Set this flag to false if this body should never fall asleep. 
 * Note that this increases CPU usage. 
 * @export 
 * @type {boolean}
 */
box2d.b2BodyDef.prototype.allowSleep = true;

/** 
 * Is this body initially awake or sleeping? 
 * @export 
 * @type {boolean}
 */
box2d.b2BodyDef.prototype.awake = true;

/** 
 * Should this body be prevented from rotating? Useful for 
 * characters. 
 * @export 
 * @type {boolean}
 */
box2d.b2BodyDef.prototype.fixedRotation = false;

/** 
 * Is this a fast moving body that should be prevented from 
 * tunneling through other moving bodies? Note that all bodies 
 * are prevented from tunneling through kinematic and static 
 * bodies. This setting is only considered on dynamic bodies. 
 * warning You should use this flag sparingly since it increases 
 * processing time. 
 * @export 
 * @type {boolean}
 */
box2d.b2BodyDef.prototype.bullet = false;

/** 
 * Does this body start out active? 
 * @export 
 * @type {boolean}
 */
box2d.b2BodyDef.prototype.active = true;

/** 
 * Use this to store application specific body data. 
 * @export 
 * @type {*}
 */
box2d.b2BodyDef.prototype.userData = null;

/** 
 * Scale the gravity applied to this body. 
 * @export 
 * @type {number}
 */
box2d.b2BodyDef.prototype.gravityScale = 1;

/** 
 * @enum
 */
box2d.b2BodyFlag = 
{
	e_none				: 0,
	e_islandFlag		: 0x0001,
	e_awakeFlag			: 0x0002,
	e_autoSleepFlag		: 0x0004,
	e_bulletFlag		: 0x0008,
	e_fixedRotationFlag	: 0x0010,
	e_activeFlag		: 0x0020,
	e_toiFlag			: 0x0040
};
goog.exportProperty(box2d.b2BodyFlag, 'e_none'             , box2d.b2BodyFlag.e_none             );
goog.exportProperty(box2d.b2BodyFlag, 'e_islandFlag'       , box2d.b2BodyFlag.e_islandFlag       );
goog.exportProperty(box2d.b2BodyFlag, 'e_awakeFlag'        , box2d.b2BodyFlag.e_awakeFlag        );
goog.exportProperty(box2d.b2BodyFlag, 'e_autoSleepFlag'    , box2d.b2BodyFlag.e_autoSleepFlag    );
goog.exportProperty(box2d.b2BodyFlag, 'e_bulletFlag'       , box2d.b2BodyFlag.e_bulletFlag       );
goog.exportProperty(box2d.b2BodyFlag, 'e_fixedRotationFlag', box2d.b2BodyFlag.e_fixedRotationFlag);
goog.exportProperty(box2d.b2BodyFlag, 'e_activeFlag'       , box2d.b2BodyFlag.e_activeFlag       );
goog.exportProperty(box2d.b2BodyFlag, 'e_toiFlag'          , box2d.b2BodyFlag.e_toiFlag          );

/** 
 * A rigid body. These are created via 
 * box2d.b2World::CreateBody. 
 * @export 
 * @constructor
 * @param {box2d.b2BodyDef} bd
 * @param {box2d.b2World} world
 */
box2d.b2Body = function (bd, world)
{
	this.m_xf = new box2d.b2Transform();
	this.m_out_xf = new box2d.b2Transform();
	this.m_sweep = new box2d.b2Sweep();
	this.m_out_sweep = new box2d.b2Sweep();
	this.m_linearVelocity = new box2d.b2Vec2();
	this.m_out_linearVelocity = new box2d.b2Vec2();
	this.m_force = new box2d.b2Vec2();

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(bd.position.IsValid()); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(bd.linearVelocity.IsValid()); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angle)); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angularVelocity)); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.gravityScale) && bd.gravityScale >= 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angularDamping) && bd.angularDamping >= 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.linearDamping) && bd.linearDamping >= 0); }

	this.m_flags = box2d.b2BodyFlag.e_none;

	if (bd.bullet)
	{
		this.m_flags |= box2d.b2BodyFlag.e_bulletFlag;
	}
	if (bd.fixedRotation)
	{
		this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag;
	}
	if (bd.allowSleep)
	{
		this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag;
	}
	if (bd.awake)
	{
		this.m_flags |= box2d.b2BodyFlag.e_awakeFlag;
	}
	if (bd.active)
	{
		this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
	}

	this.m_world = world;

	this.m_xf.p.Copy(bd.position);
	this.m_xf.q.SetAngleRadians(bd.angle);

	this.m_sweep.localCenter.SetZero();
	this.m_sweep.c0.Copy(this.m_xf.p);
	this.m_sweep.c.Copy(this.m_xf.p);
	this.m_sweep.a0 = bd.angle;
	this.m_sweep.a = bd.angle;
	this.m_sweep.alpha0 = 0;

	this.m_linearVelocity.Copy(bd.linearVelocity);
	this.m_angularVelocity = bd.angularVelocity;

	this.m_linearDamping = bd.linearDamping;
	this.m_angularDamping = bd.angularDamping;
	this.m_gravityScale = bd.gravityScale;

	this.m_force.SetZero();
	this.m_torque = 0;

	this.m_sleepTime = 0;

	this.m_type = bd.type;

	if (bd.type === box2d.b2BodyType.b2_dynamicBody)
	{
		this.m_mass = 1;
		this.m_invMass = 1;
	}
	else
	{
		this.m_mass = 0;
		this.m_invMass = 0;
	}

	this.m_I = 0;
	this.m_invI = 0;

	this.m_userData = bd.userData;

	this.m_fixtureList = null;
	this.m_fixtureCount = 0;

	this.m_controllerList = null;
	this.m_controllerCount = 0;
}

/**
 * @export 
 * @type {box2d.b2BodyFlag}
 */
box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_islandIndex = 0;
/**
 * @export 
 * @type {box2d.b2World}
 */
box2d.b2Body.prototype.m_world = null;
/**
 * @export 
 * @type {box2d.b2Transform}
 */
box2d.b2Body.prototype.m_xf = null; // the body origin transform
/**
 * @export 
 * @type {box2d.b2Transform}
 */
box2d.b2Body.prototype.m_out_xf = null;
/**
 * @export 
 * @type {box2d.b2Sweep}
 */
box2d.b2Body.prototype.m_sweep = null; // the swept motion for CCD
/**
 * @export 
 * @type {box2d.b2Sweep}
 */
box2d.b2Body.prototype.m_out_sweep = null;
/**
 * @export 
 * @type {box2d.b2JointEdge}
 */
box2d.b2Body.prototype.m_jointList = null;
/**
 * @export 
 * @type {box2d.b2ContactEdge}
 */
box2d.b2Body.prototype.m_contactList = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2Body.prototype.m_prev = null;
/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2Body.prototype.m_next = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Body.prototype.m_linearVelocity = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Body.prototype.m_out_linearVelocity = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_angularVelocity = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_linearDamping = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_angularDamping = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_gravityScale = 1;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2Body.prototype.m_force = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_torque = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_sleepTime = 0;
/**
 * @export 
 * @type {box2d.b2BodyType} 
 */
box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_mass = 1;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_invMass = 1;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_I = 0; // Rotational inertia about the center of mass.
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_invI = 0;
/**
 * @export 
 * @type {*}
 */
box2d.b2Body.prototype.m_userData = null;
/**
 * @export 
 * @type {box2d.b2Fixture}
 */
box2d.b2Body.prototype.m_fixtureList = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_fixtureCount = 0;
/** 
 * @see box2d.b2Controller list 
 * @export 
 * @type {box2d.b2ControllerEdge}
 */
box2d.b2Body.prototype.m_controllerList = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2Body.prototype.m_controllerCount = 0;

/** 
 * Creates a fixture and attach it to this body. Use this 
 * function if you need to set some fixture parameters, like 
 * friction. Otherwise you can create the fixture directly from 
 * a shape. 
 * If the density is non-zero, this function automatically 
 * updates the mass of the body. Contacts are not created until 
 * the next time step. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {box2d.b2Fixture}
 * @param {box2d.b2FixtureDef} def the fixture definition.
 */
box2d.b2Body.prototype.CreateFixture = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }
	if (this.m_world.IsLocked() === true)
	{
		return null;
	}

	var fixture = new box2d.b2Fixture();
	fixture.Create(this, def);

	if (this.m_flags & box2d.b2BodyFlag.e_activeFlag)
	{
		var broadPhase = this.m_world.m_contactManager.m_broadPhase;
		fixture.CreateProxies(broadPhase, this.m_xf);
	}

	fixture.m_next = this.m_fixtureList;
	this.m_fixtureList = fixture;
	++this.m_fixtureCount;

	fixture.m_body = this;

	// Adjust mass properties if needed.
	if (fixture.m_density > 0)
	{
		this.ResetMassData();
	}

	// Let the world know we have a new fixture. This will cause new contacts
	// to be created at the beginning of the next time step.
	this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture;

	return fixture;
}

/** 
 * Creates a fixture from a shape and attach it to this body. 
 * This is a convenience function. Use b2FixtureDef if you need 
 * to set parameters like friction, restitution, user data, or 
 * filtering. 
 * If the density is non-zero, this function automatically 
 * updates the mass of the body. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {box2d.b2Fixture}
 * @param {box2d.b2Shape} shape the shape to be cloned.
 * @param {number} density the shape density (set to zero for static bodies).
 */
box2d.b2Body.prototype.CreateFixture2 = function (shape, density)
{
	if (density === undefined) density = 0;

	var def = box2d.b2Body.prototype.CreateFixture2.s_def;
	def.shape = shape;
	def.density = density;
	return this.CreateFixture(def);
}
box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef();

/** 
 * Destroy a fixture. This removes the fixture from the 
 * broad-phase and destroys all contacts associated with this 
 * fixture. This will automatically adjust the mass of the body 
 * if the body is dynamic and the fixture has positive density. 
 * All fixtures attached to a body are implicitly destroyed when 
 * the body is destroyed. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixture the fixture to be removed.
 */
box2d.b2Body.prototype.DestroyFixture = function (fixture)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }
	if (this.m_world.IsLocked() === true)
	{
		return;
	}

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture.m_body === this); }

	// Remove the fixture from this body's singly linked list.
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_fixtureCount > 0); }
	var node = this.m_fixtureList;
	var ppF = null;
	var found = false;
	while (node !== null)
	{
		if (node === fixture)
		{
			if (ppF)
				ppF.m_next = fixture.m_next;
			else
				this.m_fixtureList = fixture.m_next;
			found = true;
			break;
		}

		ppF = node;
		node = node.m_next;
	}

	// You tried to remove a shape that is not attached to this body.
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(found); }

	// Destroy any contacts associated with the fixture.
	var edge = this.m_contactList;
	while (edge)
	{
		var c = edge.contact;
		edge = edge.next;

		var fixtureA = c.GetFixtureA();
		var fixtureB = c.GetFixtureB();

		if (fixture === fixtureA || fixture === fixtureB)
		{
			// This destroys the contact and removes it from
			// this body's contact list.
			this.m_world.m_contactManager.Destroy(c);
		}
	}

	if (this.m_flags & box2d.b2BodyFlag.e_activeFlag)
	{
		var broadPhase = this.m_world.m_contactManager.m_broadPhase;
		fixture.DestroyProxies(broadPhase);
	}

	fixture.Destroy();
	fixture.m_body = null;
	fixture.m_next = null;

	--this.m_fixtureCount;

	// Reset the mass data.
	this.ResetMassData();
}

/** 
 * Set the position of the body's origin and rotation. 
 * Manipulating a body's transform may cause non-physical 
 * behavior. 
 * Note: contacts are updated on the next call to b2World::Step.
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} position the world position of the body's local origin.
 * @param {number} angle the world rotation in radians.
 */
box2d.b2Body.prototype.SetTransformVecRadians = function (position, angle)
{
	this.SetTransformXYRadians(position.x, position.y, angle);
}

/**
 * @export 
 * @return {void} 
 * @param {number} x 
 * @param {number} y 
 * @param {number} angle 
 */
box2d.b2Body.prototype.SetTransformXYRadians = function (x, y, angle)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }
	if (this.m_world.IsLocked() === true)
	{
		return;
	}

	if ((this.m_xf.p.x === x) && 
		(this.m_xf.p.y === y) && 
		(this.m_xf.q.GetAngleRadians()) === angle)
	{
		return;
	}

	this.m_xf.q.SetAngleRadians(angle);
	this.m_xf.p.SetXY(x, y);

	box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
	this.m_sweep.a = angle;

	this.m_sweep.c0.Copy(this.m_sweep.c);
	this.m_sweep.a0 = angle;

	var broadPhase = this.m_world.m_contactManager.m_broadPhase;
	for (var f = this.m_fixtureList; f; f = f.m_next)
	{
		f.Synchronize(broadPhase, this.m_xf, this.m_xf);
	}
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2Body.prototype.SetTransform = function (xf)
{
	this.SetTransformVecRadians(xf.p, xf.GetAngleRadians());
}

/** 
 * Get the body transform for the body's origin. 
 * @export 
 * @return {box2d.b2Transform} the world transform of the body's origin.
 * @param {box2d.b2Transform=} out 
 */
box2d.b2Body.prototype.GetTransform = function (out)
{
	out = out || this.m_out_xf;
	return out.Copy(this.m_xf);
}

/** 
 * Get the world body origin position. 
 * @export 
 * @return {box2d.b2Vec2} the world position of the body's origin.
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2Body.prototype.GetPosition = function (out)
{
	out = out || this.m_out_xf.p;
	return out.Copy(this.m_xf.p);
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} position 
 */
box2d.b2Body.prototype.SetPosition = function (position)
{
	this.SetTransformVecRadians(position, this.GetAngleRadians());
}

/**
 * @export 
 * @return {void} 
 * @param {number} x
 * @param {number} y 
 */
box2d.b2Body.prototype.SetPositionXY = function (x, y)
{
	this.SetTransformXYRadians(x, y, this.GetAngleRadians());
}

/** 
 * Get the angle in radians. 
 * @export 
 * @return {number} the current world rotation angle in radians.
 */
box2d.b2Body.prototype.GetAngle = function ()
{
	return this.m_sweep.a;
}

box2d.b2Body.prototype.GetAngleRadians = box2d.b2Body.prototype.GetAngle;

box2d.b2Body.prototype.GetAngleDegrees = function () { return box2d.b2RadToDeg(this.GetAngle()); }

/**
 * @export 
 * @return {void} 
 * @param {number} angle 
 */
box2d.b2Body.prototype.SetAngle = function (angle)
{
	this.SetTransformVecRadians(this.GetPosition(), angle);
}

box2d.b2Body.prototype.SetAngleRadians = box2d.b2Body.prototype.SetAngle;

box2d.b2Body.prototype.SetAngleDegrees = function (angle) { this.SetAngle(box2d.b2DegToRad(angle)); }

/** 
 * Get the world position of the center of mass. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2Body.prototype.GetWorldCenter = function (out)
{
	out = out || this.m_out_sweep.c;
	return out.Copy(this.m_sweep.c);
}

/** 
 * Get the local position of the center of mass. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2Body.prototype.GetLocalCenter = function (out)
{
	out = out || this.m_out_sweep.localCenter;
	return out.Copy(this.m_sweep.localCenter);
}

/** 
 * Set the linear velocity of the center of mass. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} v the new linear velocity of the center of mass.
 */
box2d.b2Body.prototype.SetLinearVelocity = function (v)
{
	if (this.m_type === box2d.b2BodyType.b2_staticBody)
	{
		return;
	}

	if (box2d.b2DotVV(v,v) > 0)
	{
		this.SetAwake(true);
	}

	this.m_linearVelocity.Copy(v);
}

/** 
 * Get the linear velocity of the center of mass. 
 * @export 
 * @return {box2d.b2Vec2} the linear velocity of the center of mass.
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2Body.prototype.GetLinearVelocity = function (out)
{
	out = out || this.m_out_linearVelocity;
	return out.Copy(this.m_linearVelocity);
}

/** 
 * Set the angular velocity. 
 * @export 
 * @return {void} 
 * @param {number} w the new angular velocity in radians/second.
 */
box2d.b2Body.prototype.SetAngularVelocity = function (w)
{
	if (this.m_type === box2d.b2BodyType.b2_staticBody)
	{
		return;
	}

	if (w * w > 0)
	{
		this.SetAwake(true);
	}

	this.m_angularVelocity = w;
}

/** 
 * Get the angular velocity. 
 * @export 
 * @return {number} the angular velocity in radians/second.
 */
box2d.b2Body.prototype.GetAngularVelocity = function ()
{
	return this.m_angularVelocity;
}

/**
 * @export 
 * @return {box2d.b2BodyDef} 
 * @param {box2d.b2BodyDef} bd
 */
box2d.b2Body.prototype.GetDefinition = function (bd)
{
	bd.type = this.GetType();
	bd.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag;
	bd.angle = this.GetAngleRadians();
	bd.angularDamping = this.m_angularDamping;
	bd.gravityScale = this.m_gravityScale;
	bd.angularVelocity = this.m_angularVelocity;
	bd.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;
	bd.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag;
	bd.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag;
	bd.linearDamping = this.m_linearDamping;
	bd.linearVelocity.Copy(this.GetLinearVelocity());
	bd.position.Copy(this.GetPosition());
	bd.userData = this.GetUserData();
	return bd;
}

/** 
 * Apply a force at a world point. If the force is not applied 
 * at the center of mass, it will generate a torque and affect 
 * the angular velocity. This wakes up the body. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} force the world force vector, usually in Newtons (N).
 * @param {box2d.b2Vec2} point the world position of the point of application. 
 * @param {boolean=} wake also wake up the body 
 */
box2d.b2Body.prototype.ApplyForce = function (force, point, wake)
{
	wake = wake || true;

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	if (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
	{
		this.SetAwake(true);
	}

	// Don't accumulate a force if the body is sleeping.
	if (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)
	{
		this.m_force.x += force.x;
		this.m_force.y += force.y;
		this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
	}
}

/** 
 * Apply a force to the center of mass. This wakes up the body. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} force the world force vector, usually in Newtons (N).
 * @param {boolean=} wake also wake up the body 
 */
box2d.b2Body.prototype.ApplyForceToCenter = function (force, wake)
{
	wake = wake || true;

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	if (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
	{
		this.SetAwake(true);
	}

	// Don't accumulate a force if the body is sleeping.
	if (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)
	{
		this.m_force.x += force.x;
		this.m_force.y += force.y;
	}
}

/** 
 * Apply a torque. This affects the angular velocity without 
 * affecting the linear velocity of the center of mass. This 
 * wakes up the body. 
 * @export 
 * @return {void} 
 * @param {number} torque about the z-axis (out of the screen), usually in N-m.
 * @param {boolean=} wake also wake up the body 
 */
box2d.b2Body.prototype.ApplyTorque = function (torque, wake)
{
	wake = wake || true;

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	if (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
	{
		this.SetAwake(true);
	}

	// Don't accumulate a force if the body is sleeping.
	if (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)
	{
		this.m_torque += torque;
	}
}

/** 
 * Apply an impulse at a point. This immediately modifies the 
 * velocity. It also modifies the angular velocity if the point 
 * of application is not at the center of mass. This wakes up 
 * the body. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} impulse the world impulse vector, usually in N-seconds or kg-m/s.
 * @param {box2d.b2Vec2} point the world position of the point of application.
 * @param {boolean=} wake also wake up the body 
 */
box2d.b2Body.prototype.ApplyLinearImpulse = function (impulse, point, wake)
{
	wake = wake || true;

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	if (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
	{
		this.SetAwake(true);
	}

	// Don't accumulate a force if the body is sleeping.
	if (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)
	{
		this.m_linearVelocity.x += this.m_invMass * impulse.x;
		this.m_linearVelocity.y += this.m_invMass * impulse.y;
		this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
	}
}

/** 
 * Apply an angular impulse. 
 * @export 
 * @return {void} 
 * @param {number} impulse the angular impulse in units of kg*m*m/s
 * @param {boolean=} wake also wake up the body 
 */
box2d.b2Body.prototype.ApplyAngularImpulse = function (impulse, wake)
{
	wake = wake || true;

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	if (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
	{
		this.SetAwake(true);
	}

	// Don't accumulate a force if the body is sleeping.
	if (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)
	{
		this.m_angularVelocity += this.m_invI * impulse;
	}
}

/** 
 * Get the total mass of the body. 
 * @export 
 * @return {number} the mass, usually in kilograms (kg).
 */
box2d.b2Body.prototype.GetMass = function ()
{
	return this.m_mass;
}

/** 
 * Get the rotational inertia of the body about the local 
 * origin. 
 * @export 
 * @return {number} the rotational inertia, usually in kg-m^2.
 */
box2d.b2Body.prototype.GetInertia = function ()
{
	return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
}

/** 
 * Get the mass data of the body. 
 * @export 
 * @return {box2d.b2MassData} a struct containing the mass, inertia and center of the body.
 * @param {box2d.b2MassData} data
 */
box2d.b2Body.prototype.GetMassData = function (data)
{
	data.mass = this.m_mass;
	data.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
	data.center.Copy(this.m_sweep.localCenter);
	return data;
}

/** 
 * Set the mass properties to override the mass properties of 
 * the fixtures. 
 * Note that this changes the center of mass position. 
 * Note that creating or destroying fixtures can also alter the 
 * mass. 
 * This function has no effect if the body isn't dynamic. 
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData the mass properties.
 */
box2d.b2Body.prototype.SetMassData = function (massData)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }
	if (this.m_world.IsLocked() === true)
	{
		return;
	}

	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return;
	}

	this.m_invMass = 0;
	this.m_I = 0;
	this.m_invI = 0;

	this.m_mass = massData.mass;
	if (this.m_mass <= 0)
	{
		this.m_mass = 1;
	}

	this.m_invMass = 1 / this.m_mass;

	if (massData.I > 0 && (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === 0)
	{
		this.m_I = massData.I - this.m_mass * box2d.b2DotVV(massData.center, massData.center);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_I > 0); }
		this.m_invI = 1 / this.m_I;
	}

	// Move center of mass.
	var oldCenter = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
	this.m_sweep.localCenter.Copy(massData.center);
	box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
	this.m_sweep.c0.Copy(this.m_sweep.c);

	// Update center of mass velocity.
	box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, oldCenter, box2d.b2Vec2.s_t0), this.m_linearVelocity);
}
box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2();

/** 
 * This resets the mass properties to the sum of the mass 
 * properties of the fixtures. This normally does not need to be 
 * called unless you called SetMassData to override the mass and 
 * you later want to reset the mass. 
 * @export 
 * @return {void} 
 */
box2d.b2Body.prototype.ResetMassData = function ()
{
	// Compute mass data from shapes. Each shape has its own density.
	this.m_mass = 0;
	this.m_invMass = 0;
	this.m_I = 0;
	this.m_invI = 0;
	this.m_sweep.localCenter.SetZero();

	// Static and kinematic bodies have zero mass.
	if (this.m_type === box2d.b2BodyType.b2_staticBody || this.m_type === box2d.b2BodyType.b2_kinematicBody)
	{
		this.m_sweep.c0.Copy(this.m_xf.p);
		this.m_sweep.c.Copy(this.m_xf.p);
		this.m_sweep.a0 = this.m_sweep.a;
		return;
	}

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_type === box2d.b2BodyType.b2_dynamicBody); }

	// Accumulate mass over all fixtures.
	var localCenter = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero();
	for (var f = this.m_fixtureList; f; f = f.m_next)
	{
		if (f.m_density === 0)
		{
			continue;
		}

		var massData = f.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
		this.m_mass += massData.mass;
		localCenter.x += massData.center.x * massData.mass;
		localCenter.y += massData.center.y * massData.mass;
		this.m_I += massData.I;
	}

	// Compute center of mass.
	if (this.m_mass > 0)
	{
		this.m_invMass = 1 / this.m_mass;
		localCenter.x *= this.m_invMass;
		localCenter.y *= this.m_invMass;
	}
	else
	{
		// Force all dynamic bodies to have a positive mass.
		this.m_mass = 1;
		this.m_invMass = 1;
	}

	if (this.m_I > 0 && (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === 0)
	{
		// Center the inertia about the center of mass.
		this.m_I -= this.m_mass * box2d.b2DotVV(localCenter, localCenter);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_I > 0); }
		this.m_invI = 1 / this.m_I;
	}
	else
	{
		this.m_I = 0;
		this.m_invI = 0;
	}

	// Move center of mass.
	var oldCenter = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
	this.m_sweep.localCenter.Copy(localCenter);
	box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
	this.m_sweep.c0.Copy(this.m_sweep.c);

	// Update center of mass velocity.
	box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, oldCenter, box2d.b2Vec2.s_t0), this.m_linearVelocity);
}
box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2();
box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2();
box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData();

/** 
 * Get the world coordinates of a point given the local 
 * coordinates. 
 * @export 
 * @return {box2d.b2Vec2} the same point expressed in world coordinates.
 * @param {box2d.b2Vec2} localPoint a point on the body measured relative the the body's origin.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetWorldPoint = function (localPoint, out)
{
	return box2d.b2MulXV(this.m_xf, localPoint, out);
}

/** 
 * Get the world coordinates of a vector given the local 
 * coordinates. 
 * @export 
 * @return {box2d.b2Vec2} the same vector expressed in world coordinates.
 * @param {box2d.b2Vec2} localVector a vector fixed in the body.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetWorldVector = function (localVector, out)
{
	return box2d.b2MulRV(this.m_xf.q, localVector, out);
}

/** 
 * Gets a local point relative to the body's origin given a 
 * world point. 
 * @export 
 * @return {box2d.b2Vec2} the corresponding local point relative to the body's origin.
 * @param {box2d.b2Vec2} worldPoint a point in world coordinates.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetLocalPoint = function (worldPoint, out)
{
	return box2d.b2MulTXV(this.m_xf, worldPoint, out);
}

/** 
 * Gets a local vector given a world vector. 
 * @export 
 * @return {box2d.b2Vec2} the corresponding local vector.
 * @param {box2d.b2Vec2} worldVector a vector in world coordinates.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetLocalVector = function (worldVector, out)
{
	return box2d.b2MulTRV(this.m_xf.q, worldVector, out);
}

/** 
 * Get the world linear velocity of a world point attached to 
 * this body. 
 * @export 
 * @return {box2d.b2Vec2} the world velocity of a point.
 * @param {box2d.b2Vec2} worldPoint a point in world coordinates.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint, out)
{
	return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(worldPoint, this.m_sweep.c, box2d.b2Vec2.s_t0), out);
}

/** 
 * Get the world velocity of a local point. 
 * @export 
 * @return {box2d.b2Vec2} the world velocity of a point.
 * @param {box2d.b2Vec2} localPoint a point in local coordinates.
 * @param {box2d.b2Vec2} out 
 */
box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint, out)
{
	return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint, out), out);
}

/** 
 * Get the linear damping of the body. 
 * @export 
 * @return {number}
 */
box2d.b2Body.prototype.GetLinearDamping = function ()
{
	return this.m_linearDamping;
}

/** 
 * Set the linear damping of the body. 
 * @export 
 * @param {number} linearDamping
 */
box2d.b2Body.prototype.SetLinearDamping = function (linearDamping)
{
	this.m_linearDamping = linearDamping;
}

/** 
 * Get the angular damping of the body. 
 * @export 
 * @return {number}
 */
box2d.b2Body.prototype.GetAngularDamping = function ()
{
	return this.m_angularDamping;
}

/** 
 * Set the angular damping of the body. 
 * @export 
 * @return {void} 
 * @param {number} angularDamping 
 */
box2d.b2Body.prototype.SetAngularDamping = function (angularDamping)
{
	this.m_angularDamping = angularDamping;
}

/** 
 * Get the gravity scale of the body. 
 * @export 
 * @return {number}
 */
box2d.b2Body.prototype.GetGravityScale = function ()
{
	return this.m_gravityScale;
}

/** 
 * Set the gravity scale of the body. 
 * @export 
 * @return {void} 
 * @param {number} scale 
 */
box2d.b2Body.prototype.SetGravityScale = function (scale)
{
	this.m_gravityScale = scale;
}

/** 
 * Set the type of this body. This may alter the mass and 
 * velocity. 
 * @export 
 * @return {void} 
 * @param {box2d.b2BodyType} type 
 */
box2d.b2Body.prototype.SetType = function (type)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }
	if (this.m_world.IsLocked() === true)
	{
		return;
	}

	if (this.m_type === type)
	{
		return;
	}

	this.m_type = type;

	this.ResetMassData();

	if (this.m_type === box2d.b2BodyType.b2_staticBody)
	{
		this.m_linearVelocity.SetZero();
		this.m_angularVelocity = 0;
		this.m_sweep.a0 = this.m_sweep.a;
		this.m_sweep.c0.Copy(this.m_sweep.c);
		this.SynchronizeFixtures();
	}

	this.SetAwake(true);

	this.m_force.SetZero();
	this.m_torque = 0;

	// Delete the attached contacts.
	/** @type {box2d.b2ContactEdge} */ var ce = this.m_contactList;
	while (ce)
	{
		/** @type {box2d.b2ContactEdge} */ var ce0 = ce;
		ce = ce.next;
		this.m_world.m_contactManager.Destroy(ce0.contact);
	}
	this.m_contactList = null;

	// Touch the proxies so that new contacts will be created (when appropriate)
	/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_world.m_contactManager.m_broadPhase;
	for (/** @type {box2d.b2Fixture} */ var f = this.m_fixtureList; f; f = f.m_next)
	{
		var proxyCount = f.m_proxyCount;
		for (var i = 0; i < proxyCount; ++i)
		{
			broadPhase.TouchProxy(f.m_proxies[i].proxy);
		}
	}
}

/** 
 * Get the type of this body. 
 * @export 
 * @return {box2d.b2BodyType}
 */
box2d.b2Body.prototype.GetType = function ()
{
	return this.m_type;
}

/** 
 * Should this body be treated like a bullet for continuous 
 * collision detection? 
 * @export 
 * @return {void} 
 * @param {boolean} flag 
 */
box2d.b2Body.prototype.SetBullet = function (flag)
{
	if (flag)
	{
		this.m_flags |= box2d.b2BodyFlag.e_bulletFlag;
	}
	else
	{
		this.m_flags &= ~box2d.b2BodyFlag.e_bulletFlag;
	}
}

/** 
 * Is this body treated like a bullet for continuous collision 
 * detection? 
 * @export 
 * @return {boolean}
 */
box2d.b2Body.prototype.IsBullet = function ()
{
	return (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag;
}

/** 
 * You can disable sleeping on this body. If you disable 
 * sleeping, the body will be woken. 
 * @export 
 * @return {void} 
 * @param {boolean} flag 
 */
box2d.b2Body.prototype.SetSleepingAllowed = function (flag)
{
	if (flag)
	{
		this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag;
	}
	else
	{
		this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag;
		this.SetAwake(true);
	}
}

/** 
 * Is this body allowed to sleep 
 * @export 
 * @return {boolean}
 */
box2d.b2Body.prototype.IsSleepingAllowed = function ()
{
	return (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag;
}

/** 
 * Set the sleep state of the body. A sleeping body has very low CPU cost. 
 * @export 
 * @return {void} 
 * @param {boolean} flag set to true to wake the body, false to 
 *  	  put it to sleep.
 */
box2d.b2Body.prototype.SetAwake = function (flag)
{
	if (flag)
	{
		if ((this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)
		{
			this.m_flags |= box2d.b2BodyFlag.e_awakeFlag;
			this.m_sleepTime = 0;
		}
	}
	else
	{
		this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag;
		this.m_sleepTime = 0;
		this.m_linearVelocity.SetZero();
		this.m_angularVelocity = 0;
		this.m_force.SetZero();
		this.m_torque = 0;
	}
}

/** 
 * Get the sleeping state of this body. 
 * @export 
 * @return {boolean} true if the body is awake.
 */
box2d.b2Body.prototype.IsAwake = function ()
{
	return (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag;
}

/**
 * Set the active state of the body. An inactive body is not
 * simulated and cannot be collided with or woken up.
 * If you pass a flag of true, all fixtures will be added to the
 * broad-phase.
 * If you pass a flag of false, all fixtures will be removed from
 * the broad-phase and all contacts will be destroyed.
 * Fixtures and joints are otherwise unaffected. You may continue
 * to create/destroy fixtures and joints on inactive bodies.
 * Fixtures on an inactive body are implicitly inactive and will
 * not participate in collisions, ray-casts, or queries.
 * Joints connected to an inactive body are implicitly inactive.
 * An inactive body is still owned by a b2World object and remains
 * in the body list.
 * @export 
 * @return {void} 
 * @param {boolean} flag 
 */
box2d.b2Body.prototype.SetActive = function (flag)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }

	if (flag === this.IsActive())
	{
		return;
	}

	if (flag)
	{
		this.m_flags |= box2d.b2BodyFlag.e_activeFlag;

		// Create all proxies.
		var broadPhase = this.m_world.m_contactManager.m_broadPhase;
		for (var f = this.m_fixtureList; f; f = f.m_next)
		{
			f.CreateProxies(broadPhase, this.m_xf);
		}

		// Contacts are created the next time step.
	}
	else
	{
		this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;

		// Destroy all proxies.
		var broadPhase = this.m_world.m_contactManager.m_broadPhase;
		for (var f = this.m_fixtureList; f; f = f.m_next)
		{
			f.DestroyProxies(broadPhase);
		}

		// Destroy the attached contacts.
		var ce = this.m_contactList;
		while (ce)
		{
			var ce0 = ce;
			ce = ce.next;
			this.m_world.m_contactManager.Destroy(ce0.contact);
		}
		this.m_contactList = null;
	}
}

/** 
 * Get the active state of the body. 
 * @export 
 * @return {boolean}
 */
box2d.b2Body.prototype.IsActive = function ()
{
	return (this.m_flags & box2d.b2BodyFlag.e_activeFlag) === box2d.b2BodyFlag.e_activeFlag;
}

/** 
 * Set this body to have fixed rotation. This causes the mass to 
 * be reset. 
 * @export 
 * @return {void} 
 * @param {boolean} flag 
 */
box2d.b2Body.prototype.SetFixedRotation = function (flag)
{
	var status = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;
	if (status === flag)
	{
		return;
	}

	if (flag)
	{
		this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag;
	}
	else
	{
		this.m_flags &= ~box2d.b2BodyFlag.e_fixedRotationFlag;
	}

	this.m_angularVelocity = 0;

	this.ResetMassData();
}

/** 
 * Does this body have fixed rotation? 
 * @export 
 * @return {boolean}
 */
box2d.b2Body.prototype.IsFixedRotation = function ()
{
	return (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;
}

/** 
 * Get the list of all fixtures attached to this body. 
 * @export 
 * @return {box2d.b2Fixture}
 */
box2d.b2Body.prototype.GetFixtureList = function ()
{
	return this.m_fixtureList;
}

/** 
 * Get the list of all joints attached to this body. 
 * @export 
 * @return {box2d.b2JointEdge}
 */
box2d.b2Body.prototype.GetJointList = function ()
{
	return this.m_jointList;
}

/** 
 * Get the list of all contacts attached to this body. 
 * warning this list changes during the time step and you may 
 * miss some collisions if you don't use b2ContactListener. 
 * @export 
 * @return {box2d.b2ContactEdge}
 */
box2d.b2Body.prototype.GetContactList = function ()
{
	return this.m_contactList;
}

/** 
 * Get the next body in the world's body list. 
 * @export 
 * @return {box2d.b2Body}
 */
box2d.b2Body.prototype.GetNext = function ()
{
	return this.m_next;
}

/** 
 * Get the user data pointer that was provided in the body 
 * definition. 
 * @export 
 * @return {*} 
 */
box2d.b2Body.prototype.GetUserData = function ()
{
	return this.m_userData;
}

/** 
 * Set the user data. Use this to store your application 
 * specific data. 
 * @export 
 * @return {void} 
 * @param {*} data 
 */
box2d.b2Body.prototype.SetUserData = function (data)
{
	this.m_userData = data;
}

/** 
 * Get the parent world of this body. 
 * @export 
 * @return {box2d.b2World}
 */
box2d.b2Body.prototype.GetWorld = function ()
{
	return this.m_world;
}

/**
 * @export 
 * @return {void} 
 */
box2d.b2Body.prototype.SynchronizeFixtures = function ()
{
	var xf1 = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
	xf1.q.SetAngleRadians(this.m_sweep.a0);
	box2d.b2MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);
	box2d.b2SubVV(this.m_sweep.c0, xf1.p, xf1.p);

	var broadPhase = this.m_world.m_contactManager.m_broadPhase;
	for (var f = this.m_fixtureList; f; f = f.m_next)
	{
		f.Synchronize(broadPhase, xf1, this.m_xf);
	}
}
box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform();

/**
 * @export 
 * @return {void} 
 */
box2d.b2Body.prototype.SynchronizeTransform = function ()
{
	this.m_xf.q.SetAngleRadians(this.m_sweep.a);
	box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
	box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
}

/** 
 * This is used to prevent connected bodies from colliding. 
 * It may lie, depending on the collideConnected flag.
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Body} other 
 */
box2d.b2Body.prototype.ShouldCollide = function (other)
{
	// At least one body should be dynamic.
	if (this.m_type !== box2d.b2BodyType.b2_dynamicBody && other.m_type !== box2d.b2BodyType.b2_dynamicBody)
	{
		return false;
	}

	// Does a joint prevent collision?
	for (var jn = this.m_jointList; jn; jn = jn.next)
	{
		if (jn.other === other)
		{
			if (jn.joint.m_collideConnected === false)
			{
				return false;
			}
		}
	}

	return true;
}

/**
 * @export 
 * @return {void} 
 * @param {number} alpha 
 */
box2d.b2Body.prototype.Advance = function (alpha)
{
	// Advance to the new safe time. This doesn't sync the broad-phase.
	this.m_sweep.Advance(alpha);
	this.m_sweep.c.Copy(this.m_sweep.c0);
	this.m_sweep.a = this.m_sweep.a0;
	this.m_xf.q.SetAngleRadians(this.m_sweep.a);
	box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
	box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
}

/** 
 * Dump this body to a log file 
 * @export 
 * @return {void}
 */
box2d.b2Body.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var bodyIndex = this.m_islandIndex;
	
		box2d.b2Log("if (true)\n");
		box2d.b2Log("{\n");
		box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n");
		var type_str = '';
		switch (this.m_type)
		{
		case box2d.b2BodyType.b2_staticBody:
			type_str = 'box2d.b2BodyType.b2_staticBody';
			break;
		case box2d.b2BodyType.b2_kinematicBody:
			type_str = 'box2d.b2BodyType.b2_kinematicBody';
			break;
		case box2d.b2BodyType.b2_dynamicBody:
			type_str = 'box2d.b2BodyType.b2_dynamicBody';
			break;
		default:
			if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }
			break;
		}
		box2d.b2Log("  bd.type = %s;\n", type_str);
		box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
		box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a);
		box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
		box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
		box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
		box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
		box2d.b2Log("  bd.allowSleep = %s;\n", (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag)?('true'):('false'));
		box2d.b2Log("  bd.awake = %s;\n", (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)?('true'):('false'));
		box2d.b2Log("  bd.fixedRotation = %s;\n", (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag)?('true'):('false'));
		box2d.b2Log("  bd.bullet = %s;\n", (this.m_flags & box2d.b2BodyFlag.e_bulletFlag)?('true'):('false'));
		box2d.b2Log("  bd.active = %s;\n", (this.m_flags & box2d.b2BodyFlag.e_activeFlag)?('true'):('false'));
		box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
		box2d.b2Log("\n");
		box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n", this.m_islandIndex);
		box2d.b2Log("\n");
		for (/** @type {box2d.b2Fixture} */ var f = this.m_fixtureList; f; f = f.m_next)
		{
			box2d.b2Log("  if (true)\n");
			box2d.b2Log("  {\n");
			f.Dump(bodyIndex);
			box2d.b2Log("  }\n");
		}
		box2d.b2Log("}\n");
	}
}

/** 
 * @see box2d.b2Controller list 
 * @export 
 * @return {box2d.b2ControllerEdge}
 */
box2d.b2Body.prototype.GetControllerList = function ()
{
	return this.m_controllerList;
}

/** 
 * @see box2d.b2Controller list 
 * @export 
 * @return {number}
 */
box2d.b2Body.prototype.GetControllerCount = function ()
{
	return this.m_controllerCount;
}

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2World');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Draw');
goog.require('box2d.b2ContactManager');
goog.require('box2d.b2ContactSolver');
goog.require('box2d.b2Island');
goog.require('box2d.b2Body');
goog.require('box2d.b2Math');
goog.require('box2d.b2Collision');
goog.require('box2d.b2TimeStep');
goog.require('box2d.b2WorldCallbacks');
goog.require('box2d.b2JointFactory');

/**
 * The world class manages all physics entities, dynamic 
 * simulation, and asynchronous queries. The world also contains 
 * efficient memory management facilities. 
 */

/**
 * @export 
 * @enum
 */
box2d.b2WorldFlag = 
{
	e_none			: 0,
	e_newFixture	: 0x1,
	e_locked		: 0x2,
	e_clearForces	: 0x4
};
goog.exportProperty(box2d.b2WorldFlag, 'e_none'       , box2d.b2WorldFlag.e_none       );
goog.exportProperty(box2d.b2WorldFlag, 'e_newFixture' , box2d.b2WorldFlag.e_newFixture );
goog.exportProperty(box2d.b2WorldFlag, 'e_locked'     , box2d.b2WorldFlag.e_locked     );
goog.exportProperty(box2d.b2WorldFlag, 'e_clearForces', box2d.b2WorldFlag.e_clearForces);

/** 
 * Construct a world object. 
 * @export 
 * @constructor
 * @param {box2d.b2Vec2} gravity the world gravity vector.
 */
box2d.b2World = function (gravity)
{
	this.m_flags = box2d.b2WorldFlag.e_clearForces;

	this.m_contactManager = new box2d.b2ContactManager();

	this.m_gravity = gravity.Clone();
	this.m_out_gravity = new box2d.b2Vec2();
	this.m_allowSleep = true;

	this.m_destructionListener = null;
	this.m_debugDraw = null;

	this.m_warmStarting = true;
	this.m_continuousPhysics = true;
	this.m_subStepping = false;

	this.m_stepComplete = true;

	this.m_profile = new box2d.b2Profile();

	this.m_island = new box2d.b2Island();

	this.s_stack = new Array();
}

//b2BlockAllocator m_blockAllocator;
//b2StackAllocator m_stackAllocator;

/**
 * @export 
 * @type {box2d.b2WorldFlag}
 */
box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none;

/**
 * @export 
 * @type {box2d.b2ContactManager}
 */
box2d.b2World.prototype.m_contactManager = null;

/**
 * @export 
 * @type {box2d.b2Body}
 */
box2d.b2World.prototype.m_bodyList = null;
/**
 * @export 
 * @type {box2d.b2Joint}
 */
box2d.b2World.prototype.m_jointList = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2World.prototype.m_bodyCount = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2World.prototype.m_jointCount = 0;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2World.prototype.m_gravity = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2World.prototype.m_out_gravity = null;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2World.prototype.m_allowSleep = true;

/**
 * @export 
 * @type {box2d.b2DestructionListener}
 */
box2d.b2World.prototype.m_destructionListener = null;
/**
 * @export 
 * @type {box2d.b2Draw}
 */
box2d.b2World.prototype.m_debugDraw = null;

/** 
 * This is used to compute the time step ratio to support a 
 * variable time step. 
 * @export 
 * @type {number}
 */
box2d.b2World.prototype.m_inv_dt0 = 0;

/** 
 * These are for debugging the solver. 
 * @export 
 * @type {boolean}
 */
box2d.b2World.prototype.m_warmStarting = true;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2World.prototype.m_continuousPhysics = true;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2World.prototype.m_subStepping = false;

/**
 * @export 
 * @type {boolean}
 */
box2d.b2World.prototype.m_stepComplete = true;

/**
 * @export 
 * @type {box2d.b2Profile}
 */
box2d.b2World.prototype.m_profile = null;

/**
 * @export 
 * @type {box2d.b2Island}
 */
box2d.b2World.prototype.m_island = null;

/**
 * @export 
 * @type {Array.<?box2d.b2Body>}
 */
box2d.b2World.prototype.s_stack = null;

/** 
 * @see box2d.b2Controller list 
 * @export 
 * @type {box2d.b2Controller}
 */
box2d.b2World.prototype.m_controllerList = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2World.prototype.m_controllerCount = 0;

/** 
 * Enable/disable sleep. 
 * @export 
 * @return {void} 
 * @param {boolean} flag 
 */
box2d.b2World.prototype.SetAllowSleeping = function (flag)
{
	if (flag === this.m_allowSleep)
	{
		return;
	}

	this.m_allowSleep = flag;
	if (this.m_allowSleep === false)
	{
		for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			b.SetAwake(true);
		}
	}
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.GetAllowSleeping = function ()
{
	return this.m_allowSleep;
}

/** 
 * Enable/disable warm starting. For testing. 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2World.prototype.SetWarmStarting = function (flag)
{
	this.m_warmStarting = flag;
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.GetWarmStarting = function ()
{
	return this.m_warmStarting;
}

/** 
 * Enable/disable continuous physics. For testing. 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2World.prototype.SetContinuousPhysics = function (flag)
{
	this.m_continuousPhysics = flag;
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.GetContinuousPhysics = function ()
{
	return this.m_continuousPhysics;
}

/** 
 * Enable/disable single stepped continuous physics. For 
 * testing. 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2World.prototype.SetSubStepping = function (flag)
{
	this.m_subStepping = flag;
}

/** 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.GetSubStepping = function ()
{
	return this.m_subStepping;
}

/** 
 * Get the world body list. With the returned body, use 
 * b2Body::GetNext to get the next body in the world list. A 
 * NULL body indicates the end of the list. 
 * @export 
 * @return {box2d.b2Body} the head of the world body list.
 */
box2d.b2World.prototype.GetBodyList = function ()
{
	return this.m_bodyList;
}

/** 
 * Get the world joint list. With the returned joint, use 
 * b2Joint::GetNext to get the next joint in the world list. A 
 * NULL joint indicates the end of the list. 
 * @export 
 * @return {box2d.b2Joint} the head of the world joint list.
 */
box2d.b2World.prototype.GetJointList = function ()
{
	return this.m_jointList;
}

/** 
 * Get the world contact list. With the returned contact, use 
 * box2d.b2Contact::GetNext to get the next contact in the world 
 * list. A NULL contact indicates the end of the list. 
 * warning contacts are created and destroyed in the middle of a 
 * time step. 
 * Use box2d.b2ContactListener to avoid missing contacts.
 * @export 
 * @return {box2d.b2Contact} the head of the world contact list.
 */
box2d.b2World.prototype.GetContactList = function ()
{
	return this.m_contactManager.m_contactList;
}

/** 
 * Get the number of bodies. 
 * @export 
 * @return {number} 
 */
box2d.b2World.prototype.GetBodyCount = function ()
{
	return this.m_bodyCount;
}

/** 
 * Get the number of joints. 
 * @export 
 * @return {number} 
 */
box2d.b2World.prototype.GetJointCount = function ()
{
	return this.m_jointCount;
}

/** 
 * Get the number of contacts (each may have 0 or more contact 
 * points). 
 * @export 
 * @return {number} 
 */
box2d.b2World.prototype.GetContactCount = function ()
{
	return this.m_contactManager.m_contactCount;
}

/** 
 * Change the global gravity vector. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} gravity
 * @param {boolean=} wake also wake up the bodies 
 */
box2d.b2World.prototype.SetGravity = function (gravity, wake)
{
	wake = wake || true;

	if ((this.m_gravity.x !== gravity.x) || (this.m_gravity.y !== gravity.y))
	{
		this.m_gravity.Copy(gravity);

		if (wake)
		{
			for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
			{
				b.SetAwake(true);
			}
		}
	}
}

/** 
 * Get the global gravity vector. 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2=} out 
 */
box2d.b2World.prototype.GetGravity = function (out)
{
	out = out || this.m_out_gravity;
	return out.Copy(this.m_gravity);
}

/** 
 * Is the world locked (in the middle of a time step). 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.IsLocked = function ()
{
	return (this.m_flags & box2d.b2WorldFlag.e_locked) > 0;
}

/** 
 * Set flag to control automatic clearing of forces after each 
 * time step. 
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2World.prototype.SetAutoClearForces = function (flag)
{
	if (flag)
	{
		this.m_flags |= box2d.b2WorldFlag.e_clearForces;
	}
	else
	{
		this.m_flags &= ~box2d.b2WorldFlag.e_clearForces;
	}
}

/** 
 * Get the flag that controls automatic clearing of forces after 
 * each time step. 
 * @export 
 * @return {boolean}
 */
box2d.b2World.prototype.GetAutoClearForces = function ()
{
	return (this.m_flags & box2d.b2WorldFlag.e_clearForces) === box2d.b2WorldFlag.e_clearForces;
}

/** 
 * Get the contact manager for testing. 
 * @export 
 * @return {box2d.b2ContactManager}
 */
box2d.b2World.prototype.GetContactManager = function ()
{
	return this.m_contactManager;
}

/** 
 * Get the current profile. 
 * @export 
 * @return {box2d.b2Profile} 
 */
box2d.b2World.prototype.GetProfile = function ()
{
	return this.m_profile;
}

/** 
 * Register a destruction listener. The listener is owned by you 
 * and must remain in scope. 
 * @export 
 * @return {void} 
 * @param {box2d.b2DestructionListener} listener
 */
box2d.b2World.prototype.SetDestructionListener = function (listener)
{
	this.m_destructionListener = listener;
}

/** 
 * Register a contact filter to provide specific control over 
 * collision. Otherwise the default filter is used 
 * (b2_defaultFilter). The listener is owned by you and must 
 * remain in scope. 
 * @export 
 * @return {void} 
 * @param {box2d.b2ContactFilter} filter
 */
box2d.b2World.prototype.SetContactFilter = function (filter)
{
	this.m_contactManager.m_contactFilter = filter;
}

/** 
 * Register a contact event listener. The listener is owned by 
 * you and must remain in scope. 
 * @export 
 * @return {void} 
 * @param {box2d.b2ContactListener} listener
 */
box2d.b2World.prototype.SetContactListener = function (listener)
{
	this.m_contactManager.m_contactListener = listener;
}

/** 
 * Register a routine for debug drawing. The debug draw 
 * functions are called inside with b2World::DrawDebugData 
 * method. The debug draw object is owned by you and must remain 
 * in scope. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Draw} debugDraw
 */
box2d.b2World.prototype.SetDebugDraw = function (debugDraw)
{
	this.m_debugDraw = debugDraw;
}

/** 
 * Create a rigid body given a definition. No reference to the 
 * definition is retained. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {box2d.b2Body}
 * @param {box2d.b2BodyDef} def
 */
box2d.b2World.prototype.CreateBody = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }
	if (this.IsLocked())
	{
		return null;
	}

	/** @type {box2d.b2Body} */ var b = new box2d.b2Body(def, this);

	// Add to world doubly linked list.
	b.m_prev = null;
	b.m_next = this.m_bodyList;
	if (this.m_bodyList)
	{
		this.m_bodyList.m_prev = b;
	}
	this.m_bodyList = b;
	++this.m_bodyCount;

	return b;
}

/** 
 * Destroy a rigid body given a definition. No reference to the 
 * definition is retained. This function is locked during 
 * callbacks. 
 * warning This automatically deletes all associated shapes and 
 * joints. 
 * warning This function is locked during callbacks. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} b
 */
box2d.b2World.prototype.DestroyBody = function (b)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount > 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }
	if (this.IsLocked())
	{
		return;
	}

	// Delete the attached joints.
	/** @type {box2d.b2JointEdge} */ var je = b.m_jointList;
	while (je)
	{
		/** @type {box2d.b2JointEdge} */ var je0 = je;
		je = je.next;

		if (this.m_destructionListener)
		{
			this.m_destructionListener.SayGoodbyeJoint(je0.joint);
		}

		this.DestroyJoint(je0.joint);

		b.m_jointList = je;
	}
	b.m_jointList = null;

	/// @see box2d.b2Controller list
	/** @type {box2d.b2ControllerEdge} */ var coe = b.m_controllerList;
	while (coe)
	{
		/** @type {box2d.b2ControllerEdge} */ var coe0 = coe;
		coe = coe.nextController;
		coe0.controller.RemoveBody(b);
	}

	// Delete the attached contacts.
	/** @type {box2d.b2ContactEdge} */ var ce = b.m_contactList;
	while (ce)
	{
		/** @type {box2d.b2ContactEdge} */ var ce0 = ce;
		ce = ce.next;
		this.m_contactManager.Destroy(ce0.contact);
	}
	b.m_contactList = null;

	// Delete the attached fixtures. This destroys broad-phase proxies.
	/** @type {box2d.b2Fixture} */ var f = b.m_fixtureList;
	while (f)
	{
		/** @type {box2d.b2Fixture} */ var f0 = f;
		f = f.m_next;

		if (this.m_destructionListener)
		{
			this.m_destructionListener.SayGoodbyeFixture(f0);
		}

		f0.DestroyProxies(this.m_contactManager.m_broadPhase);
		f0.Destroy();


		b.m_fixtureList = f;
		b.m_fixtureCount -= 1;
	}
	b.m_fixtureList = null;
	b.m_fixtureCount = 0;

	// Remove world body list.
	if (b.m_prev)
	{
		b.m_prev.m_next = b.m_next;
	}

	if (b.m_next)
	{
		b.m_next.m_prev = b.m_prev;
	}

	if (b === this.m_bodyList)
	{
		this.m_bodyList = b.m_next;
	}

	--this.m_bodyCount;
}

/** 
 * Create a joint to constrain bodies together. No reference to 
 * the definition is retained. This may cause the connected 
 * bodies to cease colliding. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {box2d.b2Joint}
 * @param {box2d.b2JointDef} def 
 */
box2d.b2World.prototype.CreateJoint = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }
	if (this.IsLocked())
	{
		return null;
	}

	/** @type {box2d.b2Joint} */ var j = box2d.b2JointFactory.Create(def, null);

	// Connect to the world list.
	j.m_prev = null;
	j.m_next = this.m_jointList;
	if (this.m_jointList)
	{
		this.m_jointList.m_prev = j;
	}
	this.m_jointList = j;
	++this.m_jointCount;

	// Connect to the bodies' doubly linked lists.
	j.m_edgeA.joint = j;
	j.m_edgeA.other = j.m_bodyB;
	j.m_edgeA.prev = null;
	j.m_edgeA.next = j.m_bodyA.m_jointList;
	if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
	j.m_bodyA.m_jointList = j.m_edgeA;

	j.m_edgeB.joint = j;
	j.m_edgeB.other = j.m_bodyA;
	j.m_edgeB.prev = null;
	j.m_edgeB.next = j.m_bodyB.m_jointList;
	if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
	j.m_bodyB.m_jointList = j.m_edgeB;

	/** @type {box2d.b2Body} */ var bodyA = def.bodyA;
	/** @type {box2d.b2Body} */ var bodyB = def.bodyB;

	// If the joint prevents collisions, then flag any contacts for filtering.
	if (def.collideConnected === false)
	{
		/** @type {box2d.b2ContactEdge} */ var edge = bodyB.GetContactList();
		while (edge)
		{
			if (edge.other === bodyA)
			{
				// Flag the contact for filtering at the next time step (where either
				// body is awake).
				edge.contact.FlagForFiltering();
			}

			edge = edge.next;
		}
	}

	// Note: creating a joint doesn't wake the bodies.

	return j;
}

/** 
 * Destroy a joint. This may cause the connected bodies to begin 
 * colliding. 
 * warning This function is locked during callbacks.
 * @export 
 * @return {void} 
 * @param {box2d.b2Joint} j
 */
box2d.b2World.prototype.DestroyJoint = function (j)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }
	if (this.IsLocked())
	{
		return;
	}

	/** @type {boolean} */ var collideConnected = j.m_collideConnected;

	// Remove from the doubly linked list.
	if (j.m_prev)
	{
		j.m_prev.m_next = j.m_next;
	}

	if (j.m_next)
	{
		j.m_next.m_prev = j.m_prev;
	}

	if (j === this.m_jointList)
	{
		this.m_jointList = j.m_next;
	}

	// Disconnect from island graph.
	/** @type {box2d.b2Body} */ var bodyA = j.m_bodyA;
	/** @type {box2d.b2Body} */ var bodyB = j.m_bodyB;

	// Wake up connected bodies.
	bodyA.SetAwake(true);
	bodyB.SetAwake(true);

	// Remove from body 1.
	if (j.m_edgeA.prev)
	{
		j.m_edgeA.prev.next = j.m_edgeA.next;
	}

	if (j.m_edgeA.next)
	{
		j.m_edgeA.next.prev = j.m_edgeA.prev;
	}

	if (j.m_edgeA === bodyA.m_jointList)
	{
		bodyA.m_jointList = j.m_edgeA.next;
	}

	j.m_edgeA.prev = null;
	j.m_edgeA.next = null;

	// Remove from body 2
	if (j.m_edgeB.prev)
	{
		j.m_edgeB.prev.next = j.m_edgeB.next;
	}

	if (j.m_edgeB.next)
	{
		j.m_edgeB.next.prev = j.m_edgeB.prev;
	}

	if (j.m_edgeB === bodyB.m_jointList)
	{
		bodyB.m_jointList = j.m_edgeB.next;
	}

	j.m_edgeB.prev = null;
	j.m_edgeB.next = null;

	box2d.b2JointFactory.Destroy(j, null);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_jointCount > 0); }
	--this.m_jointCount;

	// If the joint prevents collisions, then flag any contacts for filtering.
	if (collideConnected === false)
	{
		/** @type {box2d.b2ContactEdge} */ var edge = bodyB.GetContactList();
		while (edge)
		{
			if (edge.other === bodyA)
			{
				// Flag the contact for filtering at the next time step (where either
				// body is awake).
				edge.contact.FlagForFiltering();
			}

			edge = edge.next;
		}
	}
}

/** 
 * Find islands, integrate and solve constraints, solve position 
 * constraints 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step
 */
box2d.b2World.prototype.Solve = function (step)
{
	/// @see box2d.b2Controller list
	for (/** @type {box2d.b2Controller} */ var controller = this.m_controllerList; controller; controller = controller.m_next)
	{
		controller.Step(step);
	}

	this.m_profile.solveInit = 0;
	this.m_profile.solveVelocity = 0;
	this.m_profile.solvePosition = 0;

	// Size the island for the worst case.
	/** @type {box2d.b2Island} */ var island = this.m_island;
	island.Initialize(this.m_bodyCount,
					  this.m_contactManager.m_contactCount,
					  this.m_jointCount,
					  null, // this.m_stackAllocator, 
					  this.m_contactManager.m_contactListener);

	// Clear all the island flags.
	for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
	{
		b.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
	}
	for (/** @type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)
	{
		c.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
	}
	for (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
	{
		j.m_islandFlag = false;
	}

	// Build and simulate all awake islands.
	/** @type {number} */ var stackSize = this.m_bodyCount;
	/** @type {Array.<?box2d.b2Body>} */ var stack = this.s_stack;
	for (/** @type {box2d.b2Body} */ var seed = this.m_bodyList; seed; seed = seed.m_next)
	{
		if (seed.m_flags & box2d.b2BodyFlag.e_islandFlag)
		{
			continue;
		}

		if (seed.IsAwake() === false || seed.IsActive() === false)
		{
			continue;
		}

		// The seed can be dynamic or kinematic.
		if (seed.GetType() === box2d.b2BodyType.b2_staticBody)
		{
			continue;
		}

		// Reset island and stack.
		island.Clear();
		/** @type {number} */ var stackCount = 0;
		stack[stackCount++] = seed;
		seed.m_flags |= box2d.b2BodyFlag.e_islandFlag;

		// Perform a depth first search (DFS) on the constraint graph.
		while (stackCount > 0)
		{
			// Grab the next body off the stack and add it to the island.
			/* type {box2d.b2Body} */ var b = stack[--stackCount];
			if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(b.IsActive() === true); }
			island.AddBody(b);

			// Make sure the body is awake.
			b.SetAwake(true);

			// To keep islands as small as possible, we don't
			// propagate islands across static bodies.
			if (b.GetType() === box2d.b2BodyType.b2_staticBody)
			{
				continue;
			}

			// Search all contacts connected to this body.
			for (/** @type {box2d.b2ContactEdge} */ var ce = b.m_contactList; ce; ce = ce.next)
			{
				/** @type {box2d.b2Contact} */ var contact = ce.contact;

				// Has this contact already been added to an island?
				if (contact.m_flags & box2d.b2ContactFlag.e_islandFlag)
				{
					continue;
				}

				// Is this contact solid and touching?
				if (contact.IsEnabled() === false ||
					contact.IsTouching() === false)
				{
					continue;
				}

				// Skip sensors.
				/** @type {boolean} */ var sensorA = contact.m_fixtureA.m_isSensor;
				/** @type {boolean} */ var sensorB = contact.m_fixtureB.m_isSensor;
				if (sensorA || sensorB)
				{
					continue;
				}

				island.AddContact(contact);
				contact.m_flags |= box2d.b2ContactFlag.e_islandFlag;

				/** @type {box2d.b2Body} */ var other = ce.other;

				// Was the other body already added to this island?
				if (other.m_flags & box2d.b2BodyFlag.e_islandFlag)
				{
					continue;
				}

				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(stackCount < stackSize); }
				stack[stackCount++] = other;
				other.m_flags |= box2d.b2BodyFlag.e_islandFlag;
			}

			// Search all joints connect to this body.
			for (/** @type {box2d.b2JointEdge} */ var je = b.m_jointList; je; je = je.next)
			{
				if (je.joint.m_islandFlag === true)
				{
					continue;
				}

				/* type {box2d.b2Body} */ var other = je.other;

				// Don't simulate joints connected to inactive bodies.
				if (other.IsActive() === false)
				{
					continue;
				}

				island.AddJoint(je.joint);
				je.joint.m_islandFlag = true;

				if (other.m_flags & box2d.b2BodyFlag.e_islandFlag)
				{
					continue;
				}

				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(stackCount < stackSize); }
				stack[stackCount++] = other;
				other.m_flags |= box2d.b2BodyFlag.e_islandFlag;
			}
		}

		/** @type {box2d.b2Profile} */ var profile = new box2d.b2Profile();
		island.Solve(profile, step, this.m_gravity, this.m_allowSleep);
		this.m_profile.solveInit += profile.solveInit;
		this.m_profile.solveVelocity += profile.solveVelocity;
		this.m_profile.solvePosition += profile.solvePosition;

		// Post solve cleanup.
		for (/** @type {number} */ var i = 0; i < island.m_bodyCount; ++i)
		{
			// Allow static bodies to participate in other islands.
			/* type {box2d.b2Body} */ var b = island.m_bodies[i];
			if (b.GetType() === box2d.b2BodyType.b2_staticBody)
			{
				b.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
			}
		}
	}

	for (/* type {number} */ var i = 0; i < stack.length; ++i)
	{
		if (!stack[i]) break;
		stack[i] = null;
	}

	{
		/** @type {box2d.b2Timer} */ var timer = new box2d.b2Timer();

		// Synchronize fixtures, check for out of range bodies.
		for (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			// If a body was not in an island then it did not move.
			if ((b.m_flags & box2d.b2BodyFlag.e_islandFlag) === 0)
			{
				continue;
			}
	
			if (b.GetType() === box2d.b2BodyType.b2_staticBody)
			{
				continue;
			}
	
			// Update fixtures (for broad-phase).
			b.SynchronizeFixtures();
		}
	
		// Look for new contacts.
		this.m_contactManager.FindNewContacts();
		this.m_profile.broadphase = timer.GetMilliseconds();
	}
}

/** 
 * Find TOI contacts and solve them. 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step
 */
box2d.b2World.prototype.SolveTOI = function (step)
{
//	box2d.b2Island island(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, &m_stackAllocator, m_contactManager.m_contactListener);
	/** @type {box2d.b2Island} */ var island = this.m_island;
	island.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);

	if (this.m_stepComplete)
	{
		for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			b.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
			b.m_sweep.alpha0 = 0;
		}

		for (/** @type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)
		{
			// Invalidate TOI
			c.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);
			c.m_toiCount = 0;
			c.m_toi = 1;
		}
	}

	// Find TOI events and solve them.
	for (;;)
	{
		// Find the first TOI.
		/** @type {box2d.b2Contact} */ var minContact = null;
		/** @type {number} */ var minAlpha = 1;

		for (/* type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)
		{
			// Is this contact disabled?
			if (c.IsEnabled() === false)
			{
				continue;
			}

			// Prevent excessive sub-stepping.
			if (c.m_toiCount > box2d.b2_maxSubSteps)
			{
				continue;
			}

			/** @type {number} */ var alpha = 1;
			if (c.m_flags & box2d.b2ContactFlag.e_toiFlag)
			{
				// This contact has a valid cached TOI.
				alpha = c.m_toi;
			}
			else
			{
				/** @type {box2d.b2Fixture} */ var fA = c.GetFixtureA();
				/** @type {box2d.b2Fixture} */ var fB = c.GetFixtureB();

				// Is there a sensor?
				if (fA.IsSensor() || fB.IsSensor())
				{
					continue;
				}

				/** @type {box2d.b2Body} */ var bA = fA.GetBody();
				/** @type {box2d.b2Body} */ var bB = fB.GetBody();

				/** @type {box2d.b2BodyType} */ var typeA = bA.m_type;
				/** @type {box2d.b2BodyType} */ var typeB = bB.m_type;
				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(typeA === box2d.b2BodyType.b2_dynamicBody || typeB === box2d.b2BodyType.b2_dynamicBody); }

				/** @type {boolean} */ var activeA = bA.IsAwake() && typeA !== box2d.b2BodyType.b2_staticBody;
				/** @type {boolean} */ var activeB = bB.IsAwake() && typeB !== box2d.b2BodyType.b2_staticBody;

				// Is at least one body active (awake and dynamic or kinematic)?
				if (activeA === false && activeB === false)
				{
					continue;
				}

				/** @type {boolean} */ var collideA = bA.IsBullet() || typeA !== box2d.b2BodyType.b2_dynamicBody;
				/** @type {boolean} */ var collideB = bB.IsBullet() || typeB !== box2d.b2BodyType.b2_dynamicBody;

				// Are these two non-bullet dynamic bodies?
				if (collideA === false && collideB === false)
				{
					continue;
				}

				// Compute the TOI for this contact.
				// Put the sweeps onto the same time interval.
				/** @type {number} */ var alpha0 = bA.m_sweep.alpha0;

				if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0)
				{
					alpha0 = bB.m_sweep.alpha0;
					bA.m_sweep.Advance(alpha0);
				}
				else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0)
				{
					alpha0 = bA.m_sweep.alpha0;
					bB.m_sweep.Advance(alpha0);
				}

				if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(alpha0 < 1); }

				/** @type {number} */ var indexA = c.GetChildIndexA();
				/** @type {number} */ var indexB = c.GetChildIndexB();

				// Compute the time of impact in interval [0, minTOI]
				/** @type {box2d.b2TOIInput} */ var input = box2d.b2World.prototype.SolveTOI.s_toi_input;
				input.proxyA.SetShape(fA.GetShape(), indexA);
				input.proxyB.SetShape(fB.GetShape(), indexB);
				input.sweepA.Copy(bA.m_sweep);
				input.sweepB.Copy(bB.m_sweep);
				input.tMax = 1;

				/** @type {box2d.b2TOIOutput} */ var output = box2d.b2World.prototype.SolveTOI.s_toi_output;
				box2d.b2TimeOfImpact(output, input);

				// Beta is the fraction of the remaining portion of the .
				/** @type {number} */ var beta = output.t;
				if (output.state === box2d.b2TOIOutputState.e_touching)
				{
					alpha = box2d.b2Min(alpha0 + (1 - alpha0) * beta, 1);
				}
				else
				{
					alpha = 1;
				}

				c.m_toi = alpha;
				c.m_flags |= box2d.b2ContactFlag.e_toiFlag;
			}

			if (alpha < minAlpha)
			{
				// This is the minimum TOI found so far.
				minContact = c;
				minAlpha = alpha;
			}
		}

		if (minContact === null || 1 - 10 * box2d.b2_epsilon < minAlpha)
		{
			// No more TOI events. Done!
			this.m_stepComplete = true;
			break;
		}

		// Advance the bodies to the TOI.
		/* type {box2d.b2Fixture} */ var fA = minContact.GetFixtureA();
		/* type {box2d.b2Fixture} */ var fB = minContact.GetFixtureB();
		/* type {box2d.b2Body} */ var bA = fA.GetBody();
		/* type {box2d.b2Body} */ var bB = fB.GetBody();

		/** @type {box2d.b2Sweep} */ var backup1 = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(bA.m_sweep);
		/** @type {box2d.b2Sweep} */ var backup2 = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(bB.m_sweep);

		bA.Advance(minAlpha);
		bB.Advance(minAlpha);

		// The TOI contact likely has some new contact points.
		minContact.Update(this.m_contactManager.m_contactListener);
		minContact.m_flags &= ~box2d.b2ContactFlag.e_toiFlag;
		++minContact.m_toiCount;

		// Is the contact solid?
		if (minContact.IsEnabled() === false || minContact.IsTouching() === false)
		{
			// Restore the sweeps.
			minContact.SetEnabled(false);
			bA.m_sweep.Copy(backup1);
			bB.m_sweep.Copy(backup2);
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			continue;
		}

		bA.SetAwake(true);
		bB.SetAwake(true);

		// Build the island
		island.Clear();
		island.AddBody(bA);
		island.AddBody(bB);
		island.AddContact(minContact);

		bA.m_flags |= box2d.b2BodyFlag.e_islandFlag;
		bB.m_flags |= box2d.b2BodyFlag.e_islandFlag;
		minContact.m_flags |= box2d.b2ContactFlag.e_islandFlag;

		// Get contacts on bodyA and bodyB.
		//** @type {box2d.b2Body} */ var bodies = [bA, bB];
		for (/** @type {number} */ var i = 0; i < 2; ++i)
		{
			/** @type {box2d.b2Body} */ var body = (i === 0)?(bA):(bB);//bodies[i];
			if (body.m_type === box2d.b2BodyType.b2_dynamicBody)
			{
				for (/** @type {box2d.b2ContactEdge} */ var ce = body.m_contactList; ce; ce = ce.next)
				{
					if (island.m_bodyCount === island.m_bodyCapacity)
					{
						break;
					}

					if (island.m_contactCount === island.m_contactCapacity)
					{
						break;
					}

					/** @type {box2d.b2Contact} */ var contact = ce.contact;

					// Has this contact already been added to the island?
					if (contact.m_flags & box2d.b2ContactFlag.e_islandFlag)
					{
						continue;
					}

					// Only add static, kinematic, or bullet bodies.
					/** @type {box2d.b2Body} */ var other = ce.other;
					if (other.m_type === box2d.b2BodyType.b2_dynamicBody &&
						body.IsBullet() === false && other.IsBullet() === false)
					{
						continue;
					}

					// Skip sensors.
					/** @type {boolean} */ var sensorA = contact.m_fixtureA.m_isSensor;
					/** @type {boolean} */ var sensorB = contact.m_fixtureB.m_isSensor;
					if (sensorA || sensorB)
					{
						continue;
					}

					// Tentatively advance the body to the TOI.
					/** @type {box2d.b2Sweep} */ var backup = box2d.b2World.prototype.SolveTOI.s_backup.Copy(other.m_sweep);
					if ((other.m_flags & box2d.b2BodyFlag.e_islandFlag) === 0)
					{
						other.Advance(minAlpha);
					}

					// Update the contact points
					contact.Update(this.m_contactManager.m_contactListener);

					// Was the contact disabled by the user?
					if (contact.IsEnabled() === false)
					{
						other.m_sweep.Copy(backup);
						other.SynchronizeTransform();
						continue;
					}

					// Are there contact points?
					if (contact.IsTouching() === false)
					{
						other.m_sweep.Copy(backup);
						other.SynchronizeTransform();
						continue;
					}

					// Add the contact to the island
					contact.m_flags |= box2d.b2ContactFlag.e_islandFlag;
					island.AddContact(contact);

					// Has the other body already been added to the island?
					if (other.m_flags & box2d.b2BodyFlag.e_islandFlag)
					{
						continue;
					}
					
					// Add the other body to the island.
					other.m_flags |= box2d.b2BodyFlag.e_islandFlag;

					if (other.m_type !== box2d.b2BodyType.b2_staticBody)
					{
						other.SetAwake(true);
					}

					island.AddBody(other);
				}
			}
		}

		/** @type {box2d.b2TimeStep} */ var subStep = box2d.b2World.prototype.SolveTOI.s_subStep;
		subStep.dt = (1 - minAlpha) * step.dt;
		subStep.inv_dt = 1 / subStep.dt;
		subStep.dtRatio = 1;
		subStep.positionIterations = 20;
		subStep.velocityIterations = step.velocityIterations;
		subStep.warmStarting = false;
		island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);

		// Reset island flags and synchronize broad-phase proxies.
		for (/* type {number} */ var i = 0; i < island.m_bodyCount; ++i)
		{
			/* type {box2d.b2Body} */ var body = island.m_bodies[i];
			body.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;

			if (body.m_type !== box2d.b2BodyType.b2_dynamicBody)
			{
				continue;
			}

			body.SynchronizeFixtures();

			// Invalidate all contact TOIs on this displaced body.
			for (/* type {box2d.b2ContactEdge} */ var ce = body.m_contactList; ce; ce = ce.next)
			{
				ce.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);
			}
		}

		// Commit fixture proxy movements to the broad-phase so that new contacts are created.
		// Also, some contacts can be destroyed.
		this.m_contactManager.FindNewContacts();

		if (this.m_subStepping)
		{
			this.m_stepComplete = false;
			break;
		}
	}
}
box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep();
box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep();
box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep();
box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep();
box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput();
box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput();

/** 
 * Take a time step. This performs collision detection, 
 * integration, and constraint solution. 
 * @export 
 * @return {void} 
 * @param {number} dt the amount of time to simulate, this should not vary.
 * @param {number} velocityIterations for the velocity constraint solver.
 * @param {number} positionIterations for the position constraint solver.
 */
box2d.b2World.prototype.Step = function (dt, velocityIterations, positionIterations)
{
	/** @type {box2d.b2Timer} */ var stepTimer = new box2d.b2Timer();

	// If new fixtures were added, we need to find the new contacts.
	if (this.m_flags & box2d.b2WorldFlag.e_newFixture)
	{
		this.m_contactManager.FindNewContacts();
		this.m_flags &= ~box2d.b2WorldFlag.e_newFixture;
	}

	this.m_flags |= box2d.b2WorldFlag.e_locked;

	/** @type {box2d.b2TimeStep} */ var step = box2d.b2World.prototype.Step.s_step;
	step.dt = dt;
	step.velocityIterations = velocityIterations;
	step.positionIterations = positionIterations;
	if (dt > 0)
	{
		step.inv_dt = 1 / dt;
	}
	else
	{
		step.inv_dt = 0;
	}

	step.dtRatio = this.m_inv_dt0 * dt;

	step.warmStarting = this.m_warmStarting;

	// Update contacts. This is where some contacts are destroyed.
	if (true)
	{
		/** @type {box2d.b2Timer} */ var timer = new box2d.b2Timer();
		this.m_contactManager.Collide();
		this.m_profile.collide = timer.GetMilliseconds();
	}

	// Integrate velocities, solve velocity constraints, and integrate positions.
	if (this.m_stepComplete && step.dt > 0)
	{
		/* type {box2d.b2Timer} */ var timer = new box2d.b2Timer();
		this.Solve(step);
		this.m_profile.solve = timer.GetMilliseconds();
	}

	// Handle TOI events.
	if (this.m_continuousPhysics && step.dt > 0)
	{
		/* type {box2d.b2Timer} */ var timer = new box2d.b2Timer();
		this.SolveTOI(step);
		this.m_profile.solveTOI = timer.GetMilliseconds();
	}

	if (step.dt > 0)
	{
		this.m_inv_dt0 = step.inv_dt;
	}

	if (this.m_flags & box2d.b2WorldFlag.e_clearForces)
	{
		this.ClearForces();
	}

	this.m_flags &= ~box2d.b2WorldFlag.e_locked;

	this.m_profile.step = stepTimer.GetMilliseconds();
}
box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep();

/**
 * Manually clear the force buffer on all bodies. By default, 
 * forces are cleared automatically after each call to Step. The 
 * default behavior is modified by calling SetAutoClearForces. 
 * The purpose of this function is to support sub-stepping. 
 * Sub-stepping is often used to maintain a fixed sized time 
 * step under a variable frame-rate. 
 * When you perform sub-stepping you will disable auto clearing 
 * of forces and instead call ClearForces after all sub-steps 
 * are complete in one pass of your game loop. 
 * @see SetAutoClearForces
 * @export 
 * @return {void} 
 */
box2d.b2World.prototype.ClearForces = function ()
{
	for (/** @type {box2d.b2Body} */ var body = this.m_bodyList; body; body = body.m_next)
	{
		body.m_force.SetZero();
		body.m_torque = 0;
	}
}

/** 
 * Query the world for all fixtures that potentially overlap the 
 * provided AABB. 
 * @export 
 * @return {void} 
 * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): 
 *  	  boolean} callback a user implemented callback class.
 * @param {box2d.b2AABB} aabb the query box.
 */
box2d.b2World.prototype.QueryAABB = function (callback, aabb)
{
	/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;

	/**
	 * @return {boolean} 
	 * @param {box2d.b2TreeNode} proxy 
	 */
	var WorldQueryWrapper = function (proxy)
	{
		/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }
		/* type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;
		/** @type {number} */ var index = fixture_proxy.childIndex;
		if (callback instanceof box2d.b2QueryCallback)
		{
			return callback.ReportFixture(fixture);
		}
		else //if (typeof(callback) === 'function')
		{
			return callback(fixture);
		}
	};

	broadPhase.Query(WorldQueryWrapper, aabb);
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): 
 *  	  boolean} callback
 * @param {box2d.b2Shape} shape
 * @param {box2d.b2Transform} transform
 */
box2d.b2World.prototype.QueryShape = function (callback, shape, transform)
{
	/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;

	/**
	 * @return {boolean} 
	 * @param {box2d.b2TreeNode} proxy 
	 */
	var WorldQueryWrapper = function (proxy)
	{
		/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }
		/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;
		/** @type {number} */ var index = fixture_proxy.childIndex;
		if (box2d.b2TestOverlapShape(shape, 0, fixture.GetShape(), 0, transform, fixture.GetBody().GetTransform()))
		{
			if (callback instanceof box2d.b2QueryCallback)
			{
				return callback.ReportFixture(fixture);
			}
			else //if (typeof(callback) === 'function')
			{
				return callback(fixture);
			}
		}
		return true;
	};

	/** @type {box2d.b2AABB} */ var aabb = box2d.b2World.prototype.QueryShape.s_aabb;
	shape.ComputeAABB(aabb, transform, 0); // TODO
	broadPhase.Query(WorldQueryWrapper, aabb);
}
box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): 
 *  	  boolean} callback
 * @param {box2d.b2Vec2} point
 */
box2d.b2World.prototype.QueryPoint = function (callback, point)
{
	/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;

	/**
	 * @return {boolean} 
	 * @param {box2d.b2TreeNode} proxy 
	 */
	var WorldQueryWrapper = function (proxy)
	{
		/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }
		/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;
		/** @type {number} */ var index = fixture_proxy.childIndex;
		if (fixture.TestPoint(point))
		{
			if (callback instanceof box2d.b2QueryCallback)
			{
				return callback.ReportFixture(fixture);
			}
			else //if (typeof(callback) === 'function')
			{
				return callback(fixture);
			}
		}
		return true;
	};

	/** @type {box2d.b2AABB} */ var aabb = box2d.b2World.prototype.QueryPoint.s_aabb;
	aabb.lowerBound.SetXY(point.x - box2d.b2_linearSlop, point.y - box2d.b2_linearSlop);
	aabb.upperBound.SetXY(point.x + box2d.b2_linearSlop, point.y + box2d.b2_linearSlop);
	broadPhase.Query(WorldQueryWrapper, aabb);
}
box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB();

/** 
 * Ray-cast the world for all fixtures in the path of the ray. 
 * Your callback controls whether you get the closest point, any 
 * point, or n-points. The ray-cast ignores shapes that contain 
 * the starting point. 
 * @export 
 * @return {void} 
 * @param {box2d.b2RayCastCallback | function(box2d.b2Fixture, 
 *  	  box2d.b2Vec2, box2d.b2Vec2, number)} callback a user
 *  	  implemented callback class.
 * @param {box2d.b2Vec2} point1 the ray starting point
 * @param {box2d.b2Vec2} point2 the ray ending point
 */
box2d.b2World.prototype.RayCast = function (callback, point1, point2)
{
	/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;

	/**
	 * @return {number} 
	 * @param {box2d.b2RayCastInput} input 
	 * @param {box2d.b2TreeNode} proxy 
	 */
	var WorldRayCastWrapper = function (input, proxy)
	{
		/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);
		if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }
		/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;
		/** @type {number} */ var index = fixture_proxy.childIndex;
		/** @type {box2d.b2RayCastOutput} */ var output = box2d.b2World.prototype.RayCast.s_output;
		/** @type {boolean} */ var hit = fixture.RayCast(output, input, index);

		if (hit)
		{
			/** @type {number} */ var fraction = output.fraction;
			/** @type {box2d.b2Vec2} */ var point = box2d.b2World.prototype.RayCast.s_point;
			point.SetXY((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);

			if (callback instanceof box2d.b2RayCastCallback)
			{
				return callback.ReportFixture(fixture, point, output.normal, fraction);
			}
			else //if (typeof(callback) === 'function')
			{
				return callback(fixture, point, output.normal, fraction);
			}
		}
		return input.maxFraction;
	};

	/** @type {box2d.b2RayCastInput} */ var input = box2d.b2World.prototype.RayCast.s_input;
	input.maxFraction = 1;
	input.p1.Copy(point1);
	input.p2.Copy(point2);
	broadPhase.RayCast(WorldRayCastWrapper, input);
}
box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput();
box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput();
box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2();

/** 
 * @export 
 * @return {box2d.b2Fixture} 
 * @param {box2d.b2Vec2} point1
 * @param {box2d.b2Vec2} point2 
 */
box2d.b2World.prototype.RayCastOne = function (point1, point2)
{
	/** @type {box2d.b2Fixture} */ var result = null;
	/** @type {number} */ var min_fraction = 1;

	/**
	 * @return {number} 
	 * @param {box2d.b2Fixture} fixture 
	 * @param {box2d.b2Vec2} point 
	 * @param {box2d.b2Vec2} normal 
	 * @param {number} fraction
	 */
	function WorldRayCastOneWrapper(fixture, point, normal, fraction)
	{
		if (fraction < min_fraction)
		{
			min_fraction = fraction;
			result = fixture;
		}

		return min_fraction;
	};

	this.RayCast(WorldRayCastOneWrapper, point1, point2);

	return result;
}

/** 
 * @export 
 * @return {Array.<box2d.b2Fixture>} 
 * @param {box2d.b2Vec2} point1
 * @param {box2d.b2Vec2} point2 
 * @param {Array.<box2d.b2Fixture>} out
 */
box2d.b2World.prototype.RayCastAll = function (point1, point2, out)
{
	out.length = 0;

	/**
	 * @return {number} 
	 * @param {box2d.b2Fixture} fixture 
	 * @param {box2d.b2Vec2} point 
	 * @param {box2d.b2Vec2} normal 
	 * @param {number} fraction
	 */
	function WorldRayCastAllWrapper(fixture, point, normal, fraction)
	{
		out.push(fixture);
		return 1;
	};

	this.RayCast(WorldRayCastAllWrapper, point1, point2);

	return out;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Fixture} fixture 
 * @param {box2d.b2Color} color 
 */
box2d.b2World.prototype.DrawShape = function (fixture, color)
{
	/** @type {box2d.b2Shape} */ var shape = fixture.GetShape();

	switch (shape.m_type)
	{
	case box2d.b2ShapeType.e_circleShape:
		{
			/** @type {box2d.b2CircleShape} */ var circle = ((shape instanceof box2d.b2CircleShape ? shape : null));

			/** @type {box2d.b2Vec2} */ var center = circle.m_p;
			/** @type {number} */ var radius = circle.m_radius;
			/** @type {box2d.b2Vec2} */ var axis = box2d.b2Vec2.UNITX;

			this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
		}
		break;

	case box2d.b2ShapeType.e_edgeShape:
		{
			/** @type {box2d.b2EdgeShape} */ var edge = ((shape instanceof box2d.b2EdgeShape ? shape : null));
			/** @type {box2d.b2Vec2} */ var v1 = edge.m_vertex1;
			/** @type {box2d.b2Vec2} */ var v2 = edge.m_vertex2;
			this.m_debugDraw.DrawSegment(v1, v2, color);
		}
		break;

	case box2d.b2ShapeType.e_chainShape:
		{
			/** @type {box2d.b2ChainShape} */ var chain = ((shape instanceof box2d.b2ChainShape ? shape : null));
			/** @type {number} */ var count = chain.m_count;
			/* type {Array.<box2d.b2Vec2>} */ var vertices = chain.m_vertices;

			/* type {box2d.b2Vec2} */ var v1 = vertices[0];
			// this.m_debugDraw.DrawCircle(v1, 0.05, color);
			for (/** @type {number} */ var i = 0; i < count; ++i)
			{
				/* type {box2d.b2Vec2} */ var v2 = vertices[i];
				this.m_debugDraw.DrawSegment(v1, v2, color);
				this.m_debugDraw.DrawCircle(v2, 0.05, color);
				v1 = v2;
			}
		}
		break;

	case box2d.b2ShapeType.e_polygonShape:
		{
			/** @type {box2d.b2PolygonShape} */ var poly = ((shape instanceof box2d.b2PolygonShape ? shape : null));
			/** @type {number} */ var vertexCount = poly.m_count;
			/* type {Array.<box2d.b2Vec2>} */ var vertices = poly.m_vertices;

			this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
		}
		break;
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Joint} joint
 */
box2d.b2World.prototype.DrawJoint = function (joint)
{
	/** @type {box2d.b2Body} */ var bodyA = joint.GetBodyA();
	/** @type {box2d.b2Body} */ var bodyB = joint.GetBodyB();
	/** @type {box2d.b2Transform} */ var xf1 = bodyA.m_xf;
	/** @type {box2d.b2Transform} */ var xf2 = bodyB.m_xf;
	/** @type {box2d.b2Vec2} */ var x1 = xf1.p;
	/** @type {box2d.b2Vec2} */ var x2 = xf2.p;
	/** @type {box2d.b2Vec2} */ var p1 = joint.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1);
	/** @type {box2d.b2Vec2} */ var p2 = joint.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2);

	/** @type {box2d.b2Color} */ var color = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(0.5, 0.8, 0.8);

	switch (joint.m_type)
	{
	case box2d.b2JointType.e_distanceJoint:
		this.m_debugDraw.DrawSegment(p1, p2, color);
		break;

	case box2d.b2JointType.e_pulleyJoint:
		{
			/** @type {box2d.b2PulleyJoint} */ var pulley = ((joint instanceof box2d.b2PulleyJoint ? joint : null));
			/** @type {box2d.b2Vec2} */ var s1 = pulley.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1);
			/** @type {box2d.b2Vec2} */ var s2 = pulley.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
			this.m_debugDraw.DrawSegment(s1, p1, color);
			this.m_debugDraw.DrawSegment(s2, p2, color);
			this.m_debugDraw.DrawSegment(s1, s2, color);
		}
		break;

	case box2d.b2JointType.e_mouseJoint:
		// don't draw this
		this.m_debugDraw.DrawSegment(p1, p2, color);
		break;

	default:
		this.m_debugDraw.DrawSegment(x1, p1, color);
		this.m_debugDraw.DrawSegment(p1, p2, color);
		this.m_debugDraw.DrawSegment(x2, p2, color);
	}
}
box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2();
box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2();
box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(0.5, 0.8, 0.8);
box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2();
box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2();

/**
 * Call this to draw shapes and other debug draw data.
 * @export 
 * @return {void} 
 */
box2d.b2World.prototype.DrawDebugData = function ()
{
	if (this.m_debugDraw === null)
	{
		return;
	}

	/** @type {number} */ var flags = this.m_debugDraw.GetFlags();
	/** @type {box2d.b2Color} */ var color = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);

	if (flags & box2d.b2DrawFlags.e_shapeBit)
	{
		for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			/** @type {box2d.b2Transform} */ var xf = b.m_xf;

			this.m_debugDraw.PushTransform(xf);

			for (/** @type {box2d.b2Fixture} */ var f = b.GetFixtureList(); f; f = f.m_next)
			{
				if (b.IsActive() === false)
				{
					color.SetRGB(0.5, 0.5, 0.3);
					this.DrawShape(f, color);
				}
				else if (b.GetType() === box2d.b2BodyType.b2_staticBody)
				{
					color.SetRGB(0.5, 0.9, 0.5);
					this.DrawShape(f, color);
				}
				else if (b.GetType() === box2d.b2BodyType.b2_kinematicBody)
				{
					color.SetRGB(0.5, 0.5, 0.9);
					this.DrawShape(f, color);
				}
				else if (b.IsAwake() === false)
				{
					color.SetRGB(0.6, 0.6, 0.6);
					this.DrawShape(f, color);
				}
				else
				{
					color.SetRGB(0.9, 0.7, 0.7);
					this.DrawShape(f, color);
				}
			}

			this.m_debugDraw.PopTransform(xf);
		}
	}

	if (flags & box2d.b2DrawFlags.e_jointBit)
	{
		for (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
		{
			this.DrawJoint(j);
		}
	}

	/*
	if (flags & box2d.b2DrawFlags.e_pairBit)
	{
		color.SetRGB(0.3, 0.9, 0.9);
		for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.m_next)
		{
			var fixtureA = contact.GetFixtureA();
			var fixtureB = contact.GetFixtureB();

			var cA = fixtureA.GetAABB().GetCenter();
			var cB = fixtureB.GetAABB().GetCenter();

			this.m_debugDraw.DrawSegment(cA, cB, color);
		}
	}
	*/

	if (flags & box2d.b2DrawFlags.e_aabbBit)
	{
		color.SetRGB(0.9, 0.3, 0.9);
		/** @type {box2d.b2BroadPhase} */ var bp = this.m_contactManager.m_broadPhase;
		/** @type {Array.<box2d.b2Vec2>} */ var vs = box2d.b2World.prototype.DrawDebugData.s_vs;

		for (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			if (b.IsActive() === false)
			{
				continue;
			}

			for (/* type {box2d.b2Fixture} */ var f = b.GetFixtureList(); f; f = f.m_next)
			{
				for (/** @type {number} */ var i = 0; i < f.m_proxyCount; ++i)
				{
					/** @type {box2d.b2FixtureProxy} */ var proxy = f.m_proxies[i];

					/** @type {box2d.b2AABB} */ var aabb = bp.GetFatAABB(proxy.proxy);
					vs[0].SetXY(aabb.lowerBound.x, aabb.lowerBound.y);
					vs[1].SetXY(aabb.upperBound.x, aabb.lowerBound.y);
					vs[2].SetXY(aabb.upperBound.x, aabb.upperBound.y);
					vs[3].SetXY(aabb.lowerBound.x, aabb.upperBound.y);
	
					this.m_debugDraw.DrawPolygon(vs, 4, color);
				}
			}
		}
	}

	if (flags & box2d.b2DrawFlags.e_centerOfMassBit)
	{
		for (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			/* type {box2d.b2Transform} */ var xf = box2d.b2World.prototype.DrawDebugData.s_xf;
			xf.q.Copy(b.m_xf.q);
			xf.p.Copy(b.GetWorldCenter());
			this.m_debugDraw.DrawTransform(xf);
		}
	}

	/// @see box2d.b2Controller list
	if (flags & box2d.b2DrawFlags.e_controllerBit)
	{
		for (/** @type {box2d.b2Controller} */ var c = this.m_controllerList; c; c = c.m_next)
		{
			c.Draw(this.m_debugDraw);
		}
	}
}
box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0);
box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4);
box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2BroadPhase} broadPhase
 */
box2d.b2World.prototype.SetBroadPhase = function (broadPhase)
{
	var oldBroadPhase = this.m_contactManager.m_broadPhase;

	this.m_contactManager.m_broadPhase = broadPhase;

	for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
	{
		for (/** @type {box2d.b2Fixture} */ var f = b.m_fixtureList; f; f = f.m_next)
		{
			f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
		}
	}
}

/** 
 * Get the number of broad-phase proxies. 
 * @export 
 * @return {number}
 */
box2d.b2World.prototype.GetProxyCount = function ()
{
	return this.m_contactManager.m_broadPhase.GetProxyCount();
}

/** 
 * Get the height of the dynamic tree. 
 * @export 
 * @return {number}
 */
box2d.b2World.prototype.GetTreeHeight = function ()
{
	return this.m_contactManager.m_broadPhase.GetTreeHeight();
}

/** 
 * Get the balance of the dynamic tree. 
 * @export 
 * @return {number}
 */
box2d.b2World.prototype.GetTreeBalance = function ()
{
	return this.m_contactManager.m_broadPhase.GetTreeBalance();
}

/** 
 * Get the quality metric of the dynamic tree. The smaller the 
 * better. The minimum is 1. 
 * @export 
 * @return {number}
 */
box2d.b2World.prototype.GetTreeQuality = function ()
{
	return this.m_contactManager.m_broadPhase.GetTreeQuality();
}

/** 
 * Shift the world origin. Useful for large worlds. 
 * The body shift formula is: position -= newOrigin
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin
 */
box2d.b2World.prototype.ShiftOrigin = function (newOrigin)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }
	if (this.IsLocked())
	{
		return;
	}

	for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
	{
		b.m_xf.p.SelfSub(newOrigin);
		b.m_sweep.c0.SelfSub(newOrigin);
		b.m_sweep.c.SelfSub(newOrigin);
	}

	for (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
	{
		j.ShiftOrigin(newOrigin);
	}

	this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
}

/** 
 * Dump the world into the log file. 
 * warning this should be called outside of a time step.
 * @export 
 * @return {void}
 */
box2d.b2World.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		if ((this.m_flags & box2d.b2WorldFlag.e_locked) === box2d.b2WorldFlag.e_locked)
		{
			return;
		}
	
		box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
		box2d.b2Log("this.m_world.SetGravity(g);\n");
	
		box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount);
		box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount);
		var i = 0;
		for (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)
		{
			b.m_islandIndex = i;
			b.Dump();
			++i;
		}
	
		i = 0;
		for (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
		{
			j.m_index = i;
			++i;
		}
	
		// First pass on joints, skip gear joints.
		for (/* type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
		{
			if (j.m_type === box2d.b2JointType.e_gearJoint)
			{
				continue;
			}
	
			box2d.b2Log("if (true)\n");
			box2d.b2Log("{\n");
			j.Dump();
			box2d.b2Log("}\n");
		}
	
		// Second pass on joints, only gear joints.
		for (/* type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)
		{
			if (j.m_type !== box2d.b2JointType.e_gearJoint)
			{
				continue;
			}
	
			box2d.b2Log("if (true)\n");
			box2d.b2Log("{\n");
			j.Dump();
			box2d.b2Log("}\n");
		}
	}
}

/**
 * @see box2d.b2Controller list 
 * @export 
 * @return {box2d.b2Controller} 
 * @param {box2d.b2Controller} controller
 */
box2d.b2World.prototype.AddController = function (controller)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(controller.m_world === null, "Controller can only be a member of one world"); }
	controller.m_world = this;
	controller.m_next = this.m_controllerList;
	controller.m_prev = null;
	if (this.m_controllerList)
		this.m_controllerList.m_prev = controller;
	this.m_controllerList = controller;
	++this.m_controllerCount;
	return controller;
}

/**
 * @see box2d.b2Controller list
 * @export 
 * @return {void} 
 * @param {box2d.b2Controller} controller
 */
box2d.b2World.prototype.RemoveController = function (controller)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(controller.m_world === this, "Controller is not a member of this world"); }
	if (controller.m_prev)
		controller.m_prev.m_next = controller.m_next;
	if (controller.m_next)
		controller.m_next.m_prev = controller.m_prev;
	if (this.m_controllerList === controller)
		this.m_controllerList = controller.m_next;
	--this.m_controllerCount;
	controller.m_prev = null;
	controller.m_next = null;
	controller.m_world = null;
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2AreaJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Definition for a {@link box2d.b2AreaJoint}, which connects a 
 * group a bodies together so they maintain a constant area 
 * within them. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2AreaJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_areaJoint); // base class constructor

	this.bodies = new Array();
}

goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef);

/**
 * @export 
 * @type {box2d.b2World}
 */
box2d.b2AreaJointDef.prototype.world = null;

/**
 * @export 
 * @type {Array.<box2d.b2Body>}
 */
box2d.b2AreaJointDef.prototype.bodies = null;

/** 
 * The mass-spring-damper frequency in Hertz. A value of 0 
 * disables softness. 
 * @export 
 * @type {number}
 */
box2d.b2AreaJointDef.prototype.frequencyHz = 0;

/** 
 * The damping ratio. 0 = no damping, 1 = critical damping. 
 * @export 
 * @type {number}
 */
box2d.b2AreaJointDef.prototype.dampingRatio = 0;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} body
 */
box2d.b2AreaJointDef.prototype.AddBody = function (body)
{
	this.bodies.push(body);

	if (this.bodies.length === 1)
	{
		this.bodyA = body;
	}
	else if (this.bodies.length === 2)
	{
		this.bodyB = body;
	}
}

/** 
 * A distance joint constrains two points on two bodies to 
 * remain at a fixed distance from each other. You can view this 
 * as a massless, rigid rod. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2AreaJointDef} def 
 */
box2d.b2AreaJoint = function (def)
{
	goog.base(this, def); // base class constructor

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.bodies.length >= 3, "You cannot create an area joint with less than three bodies."); }

	this.m_bodies = def.bodies;
	this.m_frequencyHz = def.frequencyHz;
	this.m_dampingRatio = def.dampingRatio;

	this.m_targetLengths = box2d.b2MakeNumberArray(def.bodies.length);
	this.m_normals = box2d.b2Vec2.MakeArray(def.bodies.length);
	this.m_joints = new Array(def.bodies.length);
	this.m_deltas = box2d.b2Vec2.MakeArray(def.bodies.length);
	this.m_delta = new box2d.b2Vec2();

	var djd = new box2d.b2DistanceJointDef();
	djd.frequencyHz = def.frequencyHz;
	djd.dampingRatio = def.dampingRatio;

	this.m_targetArea = 0;

	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var body = this.m_bodies[i];
		var next = this.m_bodies[(i+1)%ict];

		var body_c = body.GetWorldCenter();
		var next_c = next.GetWorldCenter();

		this.m_targetLengths[i] = box2d.b2DistanceVV(body_c, next_c);

		this.m_targetArea += box2d.b2CrossVV(body_c, next_c);

		djd.Initialize(body, next, body_c, next_c);
		this.m_joints[i] = def.world.CreateJoint(djd);
	}

	this.m_targetArea *= 0.5;
}

goog.inherits(box2d.b2AreaJoint, box2d.b2Joint);

/**
 * @export 
 * @type {Array.<box2d.b2Body>}
 */
box2d.b2AreaJoint.prototype.m_bodies = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2AreaJoint.prototype.m_frequencyHz = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2AreaJoint.prototype.m_dampingRatio = 0;

// Solver shared
/**
 * @export 
 * @type {number}
 */
box2d.b2AreaJoint.prototype.m_impulse = 0;

// Solver temp
box2d.b2AreaJoint.prototype.m_targetLengths = null;
box2d.b2AreaJoint.prototype.m_targetArea = 0;
box2d.b2AreaJoint.prototype.m_normals = null;
box2d.b2AreaJoint.prototype.m_joints = null;
box2d.b2AreaJoint.prototype.m_deltas = null;
box2d.b2AreaJoint.prototype.m_delta = null;

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2AreaJoint.prototype.GetAnchorA = function (out)
{
	return out.SetZero();
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2AreaJoint.prototype.GetAnchorB = function (out)
{
	return out.SetZero();
}

/** 
 * Get the reaction force given the inverse time step. 
 * Unit is N.
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2AreaJoint.prototype.GetReactionForce = function (inv_dt, out)
{
	return out.SetZero();
}

/** 
 * Get the reaction torque given the inverse time step. 
 * Unit is N*m. This is always zero for a distance joint.
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2AreaJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * Set/get frequency in Hz. 
 * @export 
 * @return {void} 
 * @param {number} hz
 */
box2d.b2AreaJoint.prototype.SetFrequency = function (hz)
{
	this.m_frequencyHz = hz;

	for (var i = 0, ict = this.m_joints.length; i < ict; ++i)
	{
		this.m_joints[i].SetFrequency(hz);
	}
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2AreaJoint.prototype.GetFrequency = function ()
{
	return this.m_frequencyHz;
}

/** 
 * Set/get damping ratio. 
 * @export 
 * @return {void} 
 * @param {number} ratio
 */
box2d.b2AreaJoint.prototype.SetDampingRatio = function (ratio)
{
	this.m_dampingRatio = ratio;

	for (var i = 0, ict = this.m_joints.length; i < ict; ++i)
	{
		this.m_joints[i].SetDampingRatio(ratio);
	}
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2AreaJoint.prototype.GetDampingRatio = function ()
{
	return this.m_dampingRatio;
}

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2AreaJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		box2d.b2Log("Area joint dumping is not supported.\n");
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2AreaJoint.prototype.InitVelocityConstraints = function (data)
{
	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var prev = this.m_bodies[(i+ict-1)%ict];
		var next = this.m_bodies[(i+1)%ict];
		var prev_c = data.positions[prev.m_islandIndex].c;
		var next_c = data.positions[next.m_islandIndex].c;
		var delta = this.m_deltas[i];

		box2d.b2SubVV(next_c, prev_c, delta);
	}

	if (data.step.warmStarting)
	{
		this.m_impulse *= data.step.dtRatio;

		for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
		{
			var body = this.m_bodies[i];
			var body_v = data.velocities[body.m_islandIndex].v;
			var delta = this.m_deltas[i];

			body_v.x += body.m_invMass *  delta.y * 0.5 * this.m_impulse;
			body_v.y += body.m_invMass * -delta.x * 0.5 * this.m_impulse;
		}
	}
	else
	{
		this.m_impulse = 0;
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function (data)
{
	var dotMassSum = 0;
	var crossMassSum = 0;

	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var body = this.m_bodies[i];
		var body_v = data.velocities[body.m_islandIndex].v;
		var delta = this.m_deltas[i];

		dotMassSum += delta.GetLengthSquared() / body.GetMass();
		crossMassSum += box2d.b2CrossVV(body_v, delta);
	}

	var lambda = -2 * crossMassSum / dotMassSum;
	//lambda = box2d.b2Clamp(lambda, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection);

	this.m_impulse += lambda;

	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var body = this.m_bodies[i];
		var body_v = data.velocities[body.m_islandIndex].v;
		var delta = this.m_deltas[i];

		body_v.x += body.m_invMass *  delta.y * 0.5 * lambda;
		body_v.y += body.m_invMass * -delta.x * 0.5 * lambda;
	}
}

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2AreaJoint.prototype.SolvePositionConstraints = function (data)
{
	var perimeter = 0;
	var area = 0;

	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var body = this.m_bodies[i];
		var next = this.m_bodies[(i+1)%ict];
		var body_c = data.positions[body.m_islandIndex].c;
		var next_c = data.positions[next.m_islandIndex].c;

		var delta = box2d.b2SubVV(next_c, body_c, this.m_delta);

		var dist = delta.GetLength();
		if (dist < box2d.b2_epsilon)
		{
			dist = 1;
		}

		this.m_normals[i].x =  delta.y / dist;
		this.m_normals[i].y = -delta.x / dist;

		perimeter += dist;

		area += box2d.b2CrossVV(body_c, next_c);
	}

	area *= 0.5;

	var deltaArea = this.m_targetArea - area;
	var toExtrude = 0.5 * deltaArea / perimeter;
	var done = true;

	for (var i = 0, ict = this.m_bodies.length; i < ict; ++i)
	{
		var body = this.m_bodies[i];
		var body_c = data.positions[body.m_islandIndex].c;
		var next_i = (i+1)%ict;

		var delta = box2d.b2AddVV(this.m_normals[i], this.m_normals[next_i], this.m_delta);
		delta.SelfMul(toExtrude);

		var norm_sq = delta.GetLengthSquared();
		if (norm_sq > box2d.b2Sq(box2d.b2_maxLinearCorrection))
		{
			delta.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(norm_sq));
		}
		if (norm_sq > box2d.b2Sq(box2d.b2_linearSlop))
		{
			done = false;
		}

		body_c.x += delta.x;
		body_c.y += delta.y;
	}

	return done;
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2BuoyancyController');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Controller');
goog.require('box2d.b2Math');
goog.require('box2d.b2WorldCallbacks');

/** 
 * Calculates buoyancy forces for fluids in the form of a half 
 * plane. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Controller} 
 */
box2d.b2BuoyancyController = function ()
{
	goog.base(this); // base class constructor

	this.normal = new box2d.b2Vec2(0, 1);
	this.velocity = new box2d.b2Vec2(0, 0);
	this.gravity = new box2d.b2Vec2(0, 0);
};

goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller);

/** 
 * The outer surface normal 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2BuoyancyController.prototype.normal = null;
/** 
 * The height of the fluid surface along the normal 
 * @export 
 * @type {number} 
 */
box2d.b2BuoyancyController.prototype.offset = 0;
/** 
 * The fluid density 
 * @export 
 * @type {number} 
 */
box2d.b2BuoyancyController.prototype.density = 0;
/** 
 * Fluid velocity, for drag calculations 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2BuoyancyController.prototype.velocity = null;
/** 
 * Linear drag co-efficient 
 * @export 
 * @type {number} 
 */
box2d.b2BuoyancyController.prototype.linearDrag = 0;
/** 
 * Linear drag co-efficient 
 * @export 
 * @type {number} 
 */
box2d.b2BuoyancyController.prototype.angularDrag = 0;
/** 
 * If false, bodies are assumed to be uniformly dense, otherwise 
 * use the shapes densities 
 * @export 
 * @type {boolean} 
 */
box2d.b2BuoyancyController.prototype.useDensity = false; //False by default to prevent a gotcha
/** 
 * If true, gravity is taken from the world instead of the
 * @export 
 * @type {boolean} 
 */
box2d.b2BuoyancyController.prototype.useWorldGravity = true;
/** 
 * Gravity vector, if the world's gravity is not used 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2BuoyancyController.prototype.gravity = null;

/** 
 * @see box2d.b2Controller::Step 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2BuoyancyController.prototype.Step = function (step)
{
	if (!this.m_bodyList) 
		return;
	if (this.useWorldGravity)
	{
		this.gravity.Copy(this.GetWorld().GetGravity());
	}
	for (var i = this.m_bodyList; i; i = i.nextBody)
	{
		var body = i.body;
		if (body.IsAwake() === false)
		{
			//Buoyancy force is just a function of position,
			//so unlike most forces, it is safe to ignore sleeping bodes
			continue;
		}
		var areac = new box2d.b2Vec2();
		var massc = new box2d.b2Vec2();
		var area = 0;
		var mass = 0;
		for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next)
		{
			var sc = new box2d.b2Vec2();
			var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
			area += sarea;
			areac.x += sarea * sc.x;
			areac.y += sarea * sc.y;
			var shapeDensity = 0;
			if (this.useDensity)
			{
				//TODO: Expose density publicly
				shapeDensity = fixture.GetDensity();
			}
			else
			{
				shapeDensity = 1;
			}
			mass += sarea * shapeDensity;
			massc.x += sarea * sc.x * shapeDensity;
			massc.y += sarea * sc.y * shapeDensity;
		}
		areac.x /= area;
		areac.y /= area;
//		b2Vec2 localCentroid = b2MulT(body->GetXForm(),areac);
		massc.x /= mass;
		massc.y /= mass;
		if (area < box2d.b2_epsilon)
			continue;
		//Buoyancy
		var buoyancyForce = box2d.b2NegV(this.gravity, new box2d.b2Vec2());
		buoyancyForce.SelfMul(this.density * area);
		body.ApplyForce(buoyancyForce, massc);
		//Linear drag
		var dragForce = body.GetLinearVelocityFromWorldPoint(areac, new box2d.b2Vec2());
		dragForce.SelfSub(this.velocity);
		dragForce.SelfMul((-this.linearDrag * area));
		body.ApplyForce(dragForce, areac);
		//Angular drag
		//TODO: Something that makes more physical sense?
		body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
	}
}

/** 
 * @see b2Controller::Draw 
 * @export 
 * @return {void} 
 * @param {box2d.b2Draw} debugDraw
 */
box2d.b2BuoyancyController.prototype.Draw = function (debugDraw)
{
	var r = 100;
	var p1 = new box2d.b2Vec2();
	var p2 = new box2d.b2Vec2();
	p1.x = this.normal.x * this.offset + this.normal.y * r;
	p1.y = this.normal.y * this.offset - this.normal.x * r;
	p2.x = this.normal.x * this.offset - this.normal.y * r;
	p2.y = this.normal.y * this.offset + this.normal.x * r;

	var color = new box2d.b2Color(0, 0, 0.8);

	debugDraw.DrawSegment(p1, p2, color);
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2TensorDampingController');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Controller');
goog.require('box2d.b2Math');

/** 
 * Applies top down linear damping to the controlled bodies 
 * The damping is calculated by multiplying velocity by a matrix 
 * in local co-ordinates. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Controller} 
 */
box2d.b2TensorDampingController = function ()
{
	goog.base(this); // base class constructor

	/// Tensor to use in damping model
	/** @type {box2d.b2Mat22} */ this.T = new box2d.b2Mat22();
	/*Some examples (matrixes in format (row1; row2))
	(-a 0; 0 -a)		Standard isotropic damping with strength a
	( 0 a; -a 0)		Electron in fixed field - a force at right angles to velocity with proportional magnitude
	(-a 0; 0 -b)		Differing x and y damping. Useful e.g. for top-down wheels.
	*/
	//By the way, tensor in this case just means matrix, don't let the terminology get you down.

	/// Set this to a positive number to clamp the maximum amount of damping done.
	/** @type {number} */ this.maxTimestep = 0;
	// Typically one wants maxTimestep to be 1/(max eigenvalue of T), so that damping will never cause something to reverse direction
};

goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller);

/** 
 * Tensor to use in damping model 
 * @export 
 * @type {box2d.b2Mat22} 
 */
box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22();
/*Some examples (matrixes in format (row1; row2))
(-a 0; 0 -a)		Standard isotropic damping with strength a
( 0 a; -a 0)		Electron in fixed field - a force at right angles to velocity with proportional magnitude
(-a 0; 0 -b)		Differing x and y damping. Useful e.g. for top-down wheels.
*/
//By the way, tensor in this case just means matrix, don't let the terminology get you down.

/** 
 * Set this to a positive number to clamp the maximum amount of 
 * damping done. 
 * @export 
 * @type {number} 
 */
box2d.b2TensorDampingController.prototype.maxTimestep = 0;
// Typically one wants maxTimestep to be 1/(max eigenvalue of T), so that damping will never cause something to reverse direction

/** 
 * @see b2Controller::Step 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2TensorDampingController.prototype.Step = function (step)
{
	var timestep = step.dt;
	if (timestep <= box2d.b2_epsilon)
		return;
	if (timestep > this.maxTimestep && this.maxTimestep > 0)
		timestep = this.maxTimestep;
	for (var i = this.m_bodyList; i; i = i.nextBody)
	{
		var body = i.body;
		if (!body.IsAwake())
			continue;
		var damping = body.GetWorldVector(
			box2d.b2MulMV(
				this.T, 
				body.GetLocalVector(
					body.GetLinearVelocity(), 
					box2d.b2Vec2.s_t0), 
				box2d.b2Vec2.s_t1),
			box2d.b2TensorDampingController.prototype.Step.s_damping);
//		body->SetLinearVelocity(body->GetLinearVelocity() + timestep * damping);
		body.SetLinearVelocity(box2d.b2AddVV(body.GetLinearVelocity(), box2d.b2MulSV(timestep, damping, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
	}
}
box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2();

/** 
 * Sets damping independantly along the x and y axes 
 * @return {void} 
 * @param {number} xDamping 
 * @param {number} yDamping 
 */
box2d.b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping)
{
	this.T.ex.x = (-xDamping);
	this.T.ex.y = 0;
	this.T.ey.x = 0;
	this.T.ey.y = (-yDamping);
	if (xDamping > 0 || yDamping > 0)
	{
		this.maxTimestep = 1 / box2d.b2Max(xDamping, yDamping);
	}
	else
	{
		this.maxTimestep = 0;
	}
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2DistanceJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Distance joint definition. This requires defining an anchor 
 * point on both bodies and the non-zero length of the distance 
 * joint. The definition uses local anchor points so that the 
 * initial configuration can violate the constraint slightly. 
 * This helps when saving and loading a game. 
 * warning Do not use a zero or short length.
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2DistanceJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_distanceJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2();
	this.localAnchorB = new box2d.b2Vec2();
}

goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJointDef.prototype.localAnchorB = null;

/** 
 * The natural length between the anchor points. 
 * @export 
 * @type {number}
 */
box2d.b2DistanceJointDef.prototype.length = 1;

/** 
 * The mass-spring-damper frequency in Hertz. A value of 0 
 * disables softness. 
 * @export 
 * @type {number}
 */
box2d.b2DistanceJointDef.prototype.frequencyHz = 0;

/** 
 * The damping ratio. 0 = no damping, 1 = critical damping. 
 * @export 
 * @type {number}
 */
box2d.b2DistanceJointDef.prototype.dampingRatio = 0;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} b1 
 * @param {box2d.b2Body} b2 
 * @param {box2d.b2Vec2} anchor1 
 * @param {box2d.b2Vec2} anchor2 
 */
box2d.b2DistanceJointDef.prototype.Initialize = function (b1, b2, anchor1, anchor2)
{
	this.bodyA = b1;
	this.bodyB = b2;
	this.bodyA.GetLocalPoint(anchor1, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor2, this.localAnchorB);
	this.length = box2d.b2DistanceVV(anchor1, anchor2);
	this.frequencyHz = 0;
	this.dampingRatio = 0;
}

/** 
 * A distance joint constrains two points on two bodies to 
 * remain at a fixed distance from each other. You can view this 
 * as a massless, rigid rod. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2DistanceJointDef} def 
 */
box2d.b2DistanceJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_u = new box2d.b2Vec2();
	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();

	this.m_frequencyHz = def.frequencyHz;
	this.m_dampingRatio = def.dampingRatio;

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();
	this.m_length = def.length;
}

goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint);

/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_frequencyHz = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_dampingRatio = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_bias = 0;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_gamma = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_impulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_length = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_u = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2DistanceJoint.prototype.m_mass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2DistanceJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2DistanceJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2DistanceJoint.prototype.m_lalcB = null;

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2DistanceJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2DistanceJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * Get the reaction force given the inverse time step. 
 * Unit is N.
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2DistanceJoint.prototype.GetReactionForce = function (inv_dt, out)
{
	return out.SetXY(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
}

/** 
 * Get the reaction torque given the inverse time step. 
 * Unit is N*m. This is always zero for a distance joint.
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * @export 
 * @return {void} 
 * @param {number} length
 */
box2d.b2DistanceJoint.prototype.SetLength = function (length)
{
	this.m_length = length;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2DistanceJoint.prototype.GetLength = function ()
{
	return this.m_length;
}

/** 
 * Set/get frequency in Hz. 
 * @export 
 * @return {void} 
 * @param {number} hz
 */
box2d.b2DistanceJoint.prototype.SetFrequency = function (hz)
{
	this.m_frequencyHz = hz;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2DistanceJoint.prototype.GetFrequency = function ()
{
	return this.m_frequencyHz;
}

/** 
 * Set/get damping ratio. 
 * @export 
 * @return {void} 
 * @param {number} ratio
 */
box2d.b2DistanceJoint.prototype.SetDampingRatio = function (ratio)
{
	this.m_dampingRatio = ratio;
}

/** 
 * @export 
 * @return {number}
 */
box2d.b2DistanceJoint.prototype.GetDampingRatio = function ()
{
	return this.m_dampingRatio;
}

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2DistanceJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.length = %.15f;\n", this.m_length);
		box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
		box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	var qA = new box2d.b2Rot(aA), qB = new box2d.b2Rot(aB);
	var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	m_u = cB + m_rB - cA - m_rA;
	this.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;
	this.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;

	// Handle singularity.
	var length = this.m_u.GetLength();
	if (length > box2d.b2_linearSlop)
	{
		this.m_u.SelfMul(1 / length);
	}
	else
	{
		this.m_u.SetZero();
	}

//	float32 crAu = b2Cross(m_rA, m_u);
	var crAu = box2d.b2CrossVV(this.m_rA, this.m_u);
//	float32 crBu = b2Cross(m_rB, m_u);
	var crBu = box2d.b2CrossVV(this.m_rB, this.m_u);
//	float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;
	var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;

	// Compute the effective mass matrix.
	this.m_mass = invMass !== 0 ? 1 / invMass : 0;

	if (this.m_frequencyHz > 0)
	{
		var C = length - this.m_length;

		// Frequency
		var omega = 2 * box2d.b2_pi * this.m_frequencyHz;

		// Damping coefficient
		var d = 2 * this.m_mass * this.m_dampingRatio * omega;

		// Spring stiffness
		var k = this.m_mass * omega * omega;

		// magic formulas
		/*float32*/ var h = data.step.dt;
		this.m_gamma = h * (d + h * k);
		this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;
		this.m_bias = C * h * k * this.m_gamma;

		invMass += this.m_gamma;
		this.m_mass = invMass !== 0 ? 1 / invMass : 0;
	}
	else
	{
		this.m_gamma = 0;
		this.m_bias = 0;
	}

	if (data.step.warmStarting)
	{
		// Scale the impulse to support a variable time step.
		this.m_impulse *= data.step.dtRatio;

//		box2d.b2Vec2 P = m_impulse * m_u;
		var P = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P);

//		vA -= m_invMassA * P;
		vA.SelfMulSub(this.m_invMassA, P);
//		wA -= m_invIA * b2Cross(m_rA, P);
		wA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);
//		vB += m_invMassB * P;
		vB.SelfMulAdd(this.m_invMassB, P);
//		wB += m_invIB * b2Cross(m_rB, P);
		wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);
	}
	else
	{
		this.m_impulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	box2d.b2Vec2 vpA = vA + b2Cross(wA, m_rA);
	var vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA);
//	box2d.b2Vec2 vpB = vB + b2Cross(wB, m_rB);
	var vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB);
//	float32 Cdot = b2Dot(m_u, vpB - vpA);
	var Cdot = box2d.b2DotVV(this.m_u, box2d.b2SubVV(vpB, vpA, box2d.b2Vec2.s_t0));

	var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
	this.m_impulse += impulse;

//	box2d.b2Vec2 P = impulse * m_u;
	var P = box2d.b2MulSV(impulse, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);

//	vA -= m_invMassA * P;
	vA.SelfMulSub(this.m_invMassA, P);
//	wA -= m_invIA * b2Cross(m_rA, P);
	wA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);
//	vB += m_invMassB * P;
	vB.SelfMulAdd(this.m_invMassB, P);
//	wB += m_invIB * b2Cross(m_rB, P);
	wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function (data)
{
	if (this.m_frequencyHz > 0)
	{
		// There is no position correction for soft distance constraints.
		return true;
	}

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

//	var qA = new box2d.b2Rot(aA), qB = new box2d.b2Rot(aB);
	var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	box2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	var rA = box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA); // use m_rA
//	box2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	var rB = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB); // use m_rB
//	box2d.b2Vec2 u = cB + rB - cA - rA;
	var u = this.m_u; // use m_u
	u.x = cB.x + rB.x - cA.x - rA.x;
	u.y = cB.y + rB.y - cA.y - rA.y;

//	float32 length = u.Normalize();
	var length = this.m_u.Normalize();
//	float32 C = length - m_length;
	var C = length - this.m_length;
	C = box2d.b2Clamp(C, (-box2d.b2_maxLinearCorrection), box2d.b2_maxLinearCorrection);

	var impulse = (-this.m_mass * C);
//	box2d.b2Vec2 P = impulse * u;
	var P = box2d.b2MulSV(impulse, u, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);

//	cA -= m_invMassA * P;
	cA.SelfMulSub(this.m_invMassA, P);
//	aA -= m_invIA * b2Cross(rA, P);
	aA -= this.m_invIA * box2d.b2CrossVV(rA, P);
//	cB += m_invMassB * P;
	cB.SelfMulAdd(this.m_invMassB, P);
//	aB += m_invIB * b2Cross(rB, P);
	aB += this.m_invIB * box2d.b2CrossVV(rB, P);

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return box2d.b2Abs(C) < box2d.b2_linearSlop;
}
box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2FrictionJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Friction joint definition. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2FrictionJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_frictionJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2();
	this.localAnchorB = new box2d.b2Vec2();
}

goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJointDef.prototype.localAnchorB = null;

/** 
 * The maximum friction force in N. 
 * @export 
 * @type {number}
 */
box2d.b2FrictionJointDef.prototype.maxForce = 0;

/** 
 * The maximum friction torque in N-m. 
 * @export 
 * @type {number}
 */
box2d.b2FrictionJointDef.prototype.maxTorque = 0;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} anchor 
 */
box2d.b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
}

/** 
 * Friction joint. This is used for top-down friction. It 
 * provides 2D translational friction and angular friction. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2FrictionJointDef} def 
 */
box2d.b2FrictionJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();

	this.m_linearImpulse = new box2d.b2Vec2().SetZero();
	this.m_maxForce = def.maxForce;
	this.m_maxTorque = def.maxTorque;

	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();
	this.m_linearMass = new box2d.b2Mat22().SetZero();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_K = new box2d.b2Mat22();
}

goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint);

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_localAnchorB = null;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_linearImpulse = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_angularImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_maxForce = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_maxTorque = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2FrictionJoint.prototype.m_linearMass = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2FrictionJoint.prototype.m_angularMass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2FrictionJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2FrictionJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2FrictionJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2FrictionJoint.prototype.m_K = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

//	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

//	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	/*box2d.b2Rot*/ var qA = new box2d.b2Rot(aA), /*box2d.b2Rot*/ qB = new box2d.b2Rot(aB);
	var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	// Compute the effective mass matrix.
//	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*box2d.b2Mat22*/ var K = this.m_K; //new box2d.b2Mat22();
	K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
	K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
	K.ey.x = K.ex.y;
	K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

	K.GetInverse(this.m_linearMass);

	this.m_angularMass = iA + iB;
	if (this.m_angularMass > 0)
	{
		this.m_angularMass = 1 / this.m_angularMass;
	}

	if (data.step.warmStarting)
	{
		// Scale impulses to support a variable time step.
//		m_linearImpulse *= data.step.dtRatio;
		this.m_linearImpulse.SelfMul(data.step.dtRatio);
		this.m_angularImpulse *= data.step.dtRatio;

//		/*box2d.b2Vec2*/ var P(m_linearImpulse.x, m_linearImpulse.y);
		/*box2d.b2Vec2*/ var P = this.m_linearImpulse;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
//		wA -= iA * (b2Cross(m_rA, P) + m_angularImpulse);
		wA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_angularImpulse);
//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
//		wB += iB * (b2Cross(m_rB, P) + m_angularImpulse);
		wB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_angularImpulse);
	}
	else
	{
		this.m_linearImpulse.SetZero();
		this.m_angularImpulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*float32*/ var h = data.step.dt;

	// Solve angular friction
	if (true)
	{
		/*float32*/ var Cdot = wB - wA;
		/*float32*/ var impulse = (-this.m_angularMass * Cdot);

		/*float32*/ var oldImpulse = this.m_angularImpulse;
		/*float32*/ var maxImpulse = h * this.m_maxTorque;
		this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
		impulse = this.m_angularImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve linear friction
	if (true)
	{
//		b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
		var Cdot = box2d.b2SubVV(
			box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0), 
			box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1), 
			box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);

//		b2Vec2 impulse = -b2Mul(m_linearMass, Cdot);
		var impulseV = box2d.b2MulMV(this.m_linearMass, Cdot, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg();
//		b2Vec2 oldImpulse = m_linearImpulse;
		var oldImpulseV = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
//		m_linearImpulse += impulse;
		this.m_linearImpulse.SelfAdd(impulseV);

		/*float32*/ var maxImpulse = h * this.m_maxForce;

		if (this.m_linearImpulse.GetLengthSquared() > maxImpulse * maxImpulse)
		{
			this.m_linearImpulse.Normalize();
			this.m_linearImpulse.SelfMul(maxImpulse);
		}

//		impulse = m_linearImpulse - oldImpulse;
		box2d.b2SubVV(this.m_linearImpulse, oldImpulseV, impulseV);

//		vA -= mA * impulse;
		vA.SelfMulSub(mA, impulseV);
//		wA -= iA * b2Cross(m_rA, impulse);
		wA -= iA * box2d.b2CrossVV(this.m_rA, impulseV);

//		vB += mB * impulse;
		vB.SelfMulAdd(mB, impulseV);
//		wB += iB * b2Cross(m_rB, impulse);
		wB += iB * box2d.b2CrossVV(this.m_rB, impulseV);
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2();
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function (data)
{
	return true;
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2FrictionJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2FrictionJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2FrictionJoint.prototype.GetReactionForce = function (inv_dt, out)
{
	return out.SetXY(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_angularImpulse;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * Set the maximum friction force in N. 
 * @export 
 * @return {void} 
 * @param {number} force
 */
box2d.b2FrictionJoint.prototype.SetMaxForce = function (force)
{
	this.m_maxForce = force;
}

/** 
 * Get the maximum friction force in N. 
 * @export 
 * @return {number}
 */
box2d.b2FrictionJoint.prototype.GetMaxForce = function ()
{
	return this.m_maxForce;
}

/** 
 * Set the maximum friction torque in N*m. 
 * @export 
 * @return {void} 
 * @param {number} torque
 */
box2d.b2FrictionJoint.prototype.SetMaxTorque = function (torque)
{
	this.m_maxTorque = torque;
}

/** 
 * Get the maximum friction torque in N*m. 
 * @export 
 * @return {number}
 */
box2d.b2FrictionJoint.prototype.GetMaxTorque = function ()
{
	return this.m_maxTorque;
}

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2FrictionJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
		box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2MouseJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/** 
 * Mouse joint definition. This requires a world target point, 
 * tuning parameters, and the time step. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2MouseJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_mouseJoint); // base class constructor

	this.target = new box2d.b2Vec2();
}

goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef);

/** 
 * The initial world target point. This is assumed to coincide 
 * with the body anchor initially. 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2MouseJointDef.prototype.target = null;

/** 
 * The maximum constraint force that can be exerted to move the 
 * candidate body. Usually you will express as some multiple of 
 * the weight (multiplier * mass * gravity). 
 * @export 
 * @type {number} 
 */
box2d.b2MouseJointDef.prototype.maxForce = 0;

/** 
 * The response speed. 
 * @export 
 * @type {number} 
 */
box2d.b2MouseJointDef.prototype.frequencyHz = 5;

/** 
 * The damping ratio. 0 = no damping, 1 = critical damping. 
 * @export 
 * @type {number} 
 */
box2d.b2MouseJointDef.prototype.dampingRatio = 0.7;

/** 
 * A mouse joint is used to make a point on a body track a 
 * specified world point. This a soft constraint with a maximum 
 * force. This allows the constraint to stretch and without 
 * applying huge forces. 
 * NOTE: this joint is not documented in the manual because it 
 * was developed to be used in the testbed. If you want to learn 
 * how to use the mouse joint, look at the testbed. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2MouseJointDef} def 
 */
box2d.b2MouseJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_localAnchorB = new box2d.b2Vec2();
	this.m_targetA = new box2d.b2Vec2();

	this.m_impulse = new box2d.b2Vec2();

	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();
	this.m_mass = new box2d.b2Mat22();
	this.m_C = new box2d.b2Vec2();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_K = new box2d.b2Mat22();

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.target.IsValid()); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.maxForce) && def.maxForce >= 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.frequencyHz) && def.frequencyHz >= 0); }
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.dampingRatio) && def.dampingRatio >= 0); }

	this.m_targetA.Copy(def.target);
	box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);

	this.m_maxForce = def.maxForce;
	this.m_impulse.SetZero();

	this.m_frequencyHz = def.frequencyHz;
	this.m_dampingRatio = def.dampingRatio;

	this.m_beta = 0;
	this.m_gamma = 0;
}

goog.inherits(box2d.b2MouseJoint, box2d.b2Joint);

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_targetA = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_frequencyHz = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_dampingRatio = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_beta = 0;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_impulse = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_maxForce = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_gamma = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MouseJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2MouseJoint.prototype.m_mass = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_C = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2MouseJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MouseJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2MouseJoint.prototype.m_K = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} target
 */
box2d.b2MouseJoint.prototype.SetTarget = function (target)
{
	if (this.m_bodyB.IsAwake() === false)
	{
		this.m_bodyB.SetAwake(true);
	}
	this.m_targetA.Copy(target);
}

/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MouseJoint.prototype.GetTarget = function (out)
{
	return out.Copy(this.m_targetA);
}

/**
 * @export 
 * @return {void} 
 * @param {number} maxForce
 */
box2d.b2MouseJoint.prototype.SetMaxForce = function (maxForce)
{
	this.m_maxForce = maxForce;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2MouseJoint.prototype.GetMaxForce = function ()
{
	return this.m_maxForce;
}

/**
 * @export 
 * @return {void} 
 * @param {number} hz
 */
box2d.b2MouseJoint.prototype.SetFrequency = function (hz)
{
	this.m_frequencyHz = hz;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2MouseJoint.prototype.GetFrequency = function ()
{
	return this.m_frequencyHz;
}

/**
 * @export 
 * @return {void} 
 * @param {number} ratio
 */
box2d.b2MouseJoint.prototype.SetDampingRatio = function (ratio)
{
	this.m_dampingRatio = ratio;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2MouseJoint.prototype.GetDampingRatio = function ()
{
	return this.m_dampingRatio;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2MouseJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	var qB = this.m_qB.SetAngleRadians(aB);

	/*float32*/ var mass = this.m_bodyB.GetMass();

	// Frequency
	/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;

	// Damping coefficient
	/*float32*/ var d = 2 * mass * this.m_dampingRatio * omega;

	// Spring stiffness
	/*float32*/ var k = mass * (omega * omega);

	// magic formulas
	// gamma has units of inverse mass.
	// beta has units of inverse time.
	/*float32*/ var h = data.step.dt;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(d + h * k > box2d.b2_epsilon); }
	this.m_gamma = h * (d + h * k);
	if (this.m_gamma !== 0)
	{
		this.m_gamma = 1 / this.m_gamma;
	}
	this.m_beta = h * k * this.m_gamma;

	// Compute the effective mass matrix.
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
	//      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
	//        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
	var K = this.m_K;
	K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
	K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
	K.ey.x = K.ex.y;
	K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;

	K.GetInverse(this.m_mass);

//	m_C = cB + m_rB - m_targetA;
	this.m_C.x = cB.x + this.m_rB.x - this.m_targetA.x;
	this.m_C.y = cB.y + this.m_rB.y - this.m_targetA.y;
//	m_C *= m_beta;
	this.m_C.SelfMul(this.m_beta);

	// Cheat with some damping
	wB *= 0.98;

	if (data.step.warmStarting)
	{
		this.m_impulse.SelfMul(data.step.dtRatio);
//		vB += m_invMassB * m_impulse;
		vB.x += this.m_invMassB * this.m_impulse.x;
		vB.y += this.m_invMassB * this.m_impulse.y;
		wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse);
	}
	else
	{
		this.m_impulse.SetZero();
	}

//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	// Cdot = v + cross(w, r)
//	b2Vec2 Cdot = vB + b2Cross(wB, m_rB);
	var Cdot = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot);
//	b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_C + m_gamma * m_impulse));
	var impulse = box2d.b2MulMV(
		this.m_mass, 
		box2d.b2AddVV(
			Cdot, 
			box2d.b2AddVV(this.m_C, 
				box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), 
				box2d.b2Vec2.s_t0),
			box2d.b2Vec2.s_t0).SelfNeg(),
		box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse);

//	b2Vec2 oldImpulse = m_impulse;
	var oldImpulse = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
//	m_impulse += impulse;
	this.m_impulse.SelfAdd(impulse);
	/*float32*/ var maxImpulse = data.step.dt * this.m_maxForce;
	if (this.m_impulse.GetLengthSquared() > maxImpulse * maxImpulse)
	{
		this.m_impulse.SelfMul(maxImpulse / this.m_impulse.GetLength());
	}
//	impulse = m_impulse - oldImpulse;
	box2d.b2SubVV(this.m_impulse, oldImpulse, impulse);

//	vB += m_invMassB * impulse;
	vB.SelfMulAdd(this.m_invMassB, impulse);
	wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, impulse);

//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2();
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2();

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2MouseJoint.prototype.SolvePositionConstraints = function (data)
{
	return true;
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out
 */
box2d.b2MouseJoint.prototype.GetAnchorA = function (out)
{
	return out.Copy(this.m_targetA);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MouseJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2MouseJoint.prototype.GetReactionForce = function (inv_dt, out)
{
	return box2d.b2MulSV(inv_dt, this.m_impulse, out);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2MouseJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * The mouse joint does not support dumping. 
 * @export
 */
box2d.b2MouseJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		box2d.b2Log("Mouse joint dumping is not supported.\n");
	}
}

/** 
 * Implement b2Joint::ShiftOrigin 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} newOrigin
 */
box2d.b2MouseJoint.prototype.ShiftOrigin = function (newOrigin)
{
	this.m_targetA.SelfSub(newOrigin);
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2ConstantForceController');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Controller');
goog.require('box2d.b2Math');

/** 
 * Applies a force every frame 
 * @export 
 * @constructor 
 * @extends {box2d.b2Controller} 
 */
box2d.b2ConstantForceController = function ()
{
	goog.base(this); // base class constructor

	this.F = new box2d.b2Vec2(0, 0);
};

goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller);

/** 
 * The force to apply 
 * @export 
 * @type {box2d.b2Vec2} 
 */
box2d.b2ConstantAccelController.prototype.F = null;

/** 
 * @see box2d.b2Controller::Step 
 * @export 
 * @return {void} 
 * @param {box2d.b2TimeStep} step 
 */
box2d.b2ConstantForceController.prototype.Step = function (step)
{
	for (var i = this.m_bodyList; i; i = i.nextBody)
	{
		var body = i.body;
		if (!body.IsAwake())
			continue;
		body.ApplyForce(this.F, body.GetWorldCenter());
	}
}

/*
* Copyright (c) 2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2PulleyJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Joint');
goog.require('box2d.b2Math');

/**
 * @export 
 * @const 
 * @type {number} 
 */
box2d.b2_minPulleyLength = 2;

/** 
 * Pulley joint definition. This requires two ground anchors, 
 * two dynamic body anchor points, and a pulley ratio. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2PulleyJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_pulleyJoint); // base class constructor
	this.collideConnected = true;

	this.groundAnchorA = new box2d.b2Vec2(-1, 1);
	this.groundAnchorB = new box2d.b2Vec2(1, 1);

	this.localAnchorA = new box2d.b2Vec2(-1, 0);
	this.localAnchorB = new box2d.b2Vec2(1, 0);
}

goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef);

/** 
 * The first ground anchor in world coordinates. This point 
 * never moves. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJointDef.prototype.groundAnchorA = null;

/** 
 * The second ground anchor in world coordinates. This point 
 * never moves. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJointDef.prototype.groundAnchorB = null;

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJointDef.prototype.localAnchorB = null;

/** 
 * The a reference length for the segment attached to bodyA. 
 * @export 
 * @type {number}
 */
box2d.b2PulleyJointDef.prototype.lengthA = 0;

/** 
 * The a reference length for the segment attached to bodyB. 
 * @export 
 * @type {number}
 */
box2d.b2PulleyJointDef.prototype.lengthB = 0;

/** 
 * The pulley ratio, used to simulate a block-and-tackle. 
 * @export 
 * @type {number}
 */
box2d.b2PulleyJointDef.prototype.ratio = 1;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} groundA 
 * @param {box2d.b2Vec2} groundB 
 * @param {box2d.b2Vec2} anchorA
 * @param {box2d.b2Vec2} anchorB
 * @param {number} r 
 */
box2d.b2PulleyJointDef.prototype.Initialize = function (bA, bB, groundA, groundB, anchorA, anchorB, r)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.groundAnchorA.Copy(groundA);
	this.groundAnchorB.Copy(groundB);
	this.bodyA.GetLocalPoint(anchorA, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchorB, this.localAnchorB);
	this.lengthA = box2d.b2DistanceVV(anchorA, groundA);
	this.lengthB = box2d.b2DistanceVV(anchorB, groundB);
	this.ratio = r;
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.ratio > box2d.b2_epsilon); }
}

/** 
 * The pulley joint is connected to two bodies and two fixed ground points. 
 * The pulley supports a ratio such that: 
 * lengthA + ratio * lengthB <= constant 
 * Yes, the force transmitted is scaled by the ratio. 
 * Warning: the pulley joint can get a bit squirrelly by itself.
 * They often work better when combined with prismatic joints. 
 * You should also cover the the anchor points with static 
 * shapes to prevent one side from going to zero length. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2PulleyJointDef} def 
 */
box2d.b2PulleyJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_groundAnchorA = new box2d.b2Vec2();
	this.m_groundAnchorB = new box2d.b2Vec2();
	this.m_localAnchorA = new box2d.b2Vec2();
	this.m_localAnchorB = new box2d.b2Vec2();

	this.m_uA = new box2d.b2Vec2();
	this.m_uB = new box2d.b2Vec2();
	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();
	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();

	this.m_groundAnchorA.Copy(def.groundAnchorA);
	this.m_groundAnchorB.Copy(def.groundAnchorB);
	this.m_localAnchorA.Copy(def.localAnchorA);
	this.m_localAnchorB.Copy(def.localAnchorB);

	this.m_lengthA = def.lengthA;
	this.m_lengthB = def.lengthB;

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.ratio !== 0); }
	this.m_ratio = def.ratio;

	this.m_constant = def.lengthA + this.m_ratio * def.lengthB;

	this.m_impulse = 0;
}

goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint);

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_groundAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_groundAnchorB = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_lengthA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_lengthB = 0;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_constant = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_ratio = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_impulse = 0;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_uA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_uB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2PulleyJoint.prototype.m_mass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2PulleyJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2PulleyJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2PulleyJoint.prototype.m_lalcB = null;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	box2d.b2Rot qA(aA), qB(aB);
	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// Get the pulley axes.
//	m_uA = cA + m_rA - m_groundAnchorA;
	this.m_uA.Copy(cA).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
//	m_uB = cB + m_rB - m_groundAnchorB;
	this.m_uB.Copy(cB).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);

	/*float32*/ var lengthA = this.m_uA.GetLength();
	/*float32*/ var lengthB = this.m_uB.GetLength();

	if (lengthA > 10 * box2d.b2_linearSlop)
	{
		this.m_uA.SelfMul(1 / lengthA);
	}
	else
	{
		this.m_uA.SetZero();
	}

	if (lengthB > 10 * box2d.b2_linearSlop)
	{
		this.m_uB.SelfMul(1 / lengthB);
	}
	else
	{
		this.m_uB.SetZero();
	}

	// Compute effective mass.
	/*float32*/ var ruA = box2d.b2CrossVV(this.m_rA, this.m_uA);
	/*float32*/ var ruB = box2d.b2CrossVV(this.m_rB, this.m_uB);

	/*float32*/ var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
	/*float32*/ var mB = this.m_invMassB + this.m_invIB * ruB * ruB;

	this.m_mass = mA + this.m_ratio * this.m_ratio * mB;

	if (this.m_mass > 0)
	{
		this.m_mass = 1 / this.m_mass;
	}

	if (data.step.warmStarting)
	{
		// Scale impulses to support variable time steps.
		this.m_impulse *= data.step.dtRatio;

		// Warm starting.
//		box2d.b2Vec2 PA = -(m_impulse) * m_uA;
		var PA = box2d.b2MulSV(-(this.m_impulse), this.m_uA, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA);
//		box2d.b2Vec2 PB = (-m_ratio * m_impulse) * m_uB;
		var PB = box2d.b2MulSV((-this.m_ratio * this.m_impulse), this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB);

//		vA += m_invMassA * PA;
		vA.SelfMulAdd(this.m_invMassA, PA);
		wA += this.m_invIA * box2d.b2CrossVV(this.m_rA, PA);
//		vB += m_invMassB * PB;
		vB.SelfMulAdd(this.m_invMassB, PB);
		wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, PB);
	}
	else
	{
		this.m_impulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2();
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

//	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
	var vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA);
//	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
	var vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB);

	/*float32*/ var Cdot = -box2d.b2DotVV(this.m_uA, vpA) - this.m_ratio * box2d.b2DotVV(this.m_uB, vpB);
	/*float32*/ var impulse = -this.m_mass * Cdot;
	this.m_impulse += impulse;

//	b2Vec2 PA = -impulse * m_uA;
	var PA = box2d.b2MulSV(-impulse, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA);
//	b2Vec2 PB = -m_ratio * impulse * m_uB;
	var PB = box2d.b2MulSV(-this.m_ratio * impulse, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
//	vA += m_invMassA * PA;
	vA.SelfMulAdd(this.m_invMassA, PA);
	wA += this.m_invIA * box2d.b2CrossVV(this.m_rA, PA);
//	vB += m_invMassB * PB;
	vB.SelfMulAdd(this.m_invMassB, PB);
	wB += this.m_invIB * box2d.b2CrossVV(this.m_rB, PB);

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2();
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

//	box2d.b2Rot qA(aA), qB(aB);
	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);

	// Get the pulley axes.
//	b2Vec2 uA = cA + rA - m_groundAnchorA;
	var uA = this.m_uA.Copy(cA).SelfAdd(rA).SelfSub(this.m_groundAnchorA);
//	b2Vec2 uB = cB + rB - m_groundAnchorB;
	var uB = this.m_uB.Copy(cB).SelfAdd(rB).SelfSub(this.m_groundAnchorB);

	/*float32*/ var lengthA = uA.GetLength();
	/*float32*/ var lengthB = uB.GetLength();

	if (lengthA > 10 * box2d.b2_linearSlop)
	{
		uA.SelfMul(1 / lengthA);
	}
	else
	{
		uA.SetZero();
	}

	if (lengthB > 10 * box2d.b2_linearSlop)
	{
		uB.SelfMul(1 / lengthB);
	}
	else
	{
		uB.SetZero();
	}

	// Compute effective mass.
	/*float32*/ var ruA = box2d.b2CrossVV(rA, uA);
	/*float32*/ var ruB = box2d.b2CrossVV(rB, uB);

	/*float32*/ var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
	/*float32*/ var mB = this.m_invMassB + this.m_invIB * ruB * ruB;

	/*float32*/ var mass = mA + this.m_ratio * this.m_ratio * mB;

	if (mass > 0)
	{
		mass = 1 / mass;
	}

	/*float32*/ var C = this.m_constant - lengthA - this.m_ratio * lengthB;
	/*float32*/ var linearError = box2d.b2Abs(C);

	/*float32*/ var impulse = -mass * C;

//	b2Vec2 PA = -impulse * uA;
	var PA = box2d.b2MulSV(-impulse, uA, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA);
//	b2Vec2 PB = -m_ratio * impulse * uB;
	var PB = box2d.b2MulSV(-this.m_ratio * impulse, uB, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);

//	cA += m_invMassA * PA;
	cA.SelfMulAdd(this.m_invMassA, PA);
	aA += this.m_invIA * box2d.b2CrossVV(rA, PA);
//	cB += m_invMassB * PB;
	cB.SelfMulAdd(this.m_invMassB, PB);
	aB += this.m_invIB * box2d.b2CrossVV(rB, PB);

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return linearError < box2d.b2_linearSlop;
}
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2();
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2();

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PulleyJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PulleyJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2PulleyJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	b2Vec2 P = m_impulse * m_uB;
//	return inv_dt * P;
	return out.SetXY(inv_dt * this.m_impulse * this.m_uB.x, inv_dt * this.m_impulse * this.m_uB.y);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return 0;
}

/** 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function (out)
{
	return out.Copy(this.m_groundAnchorA);
}

/** 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function (out)
{
	return out.Copy(this.m_groundAnchorB);
}

/** 
 * Get the current length of the segment attached to bodyA. 
 * @export 
 * @return {number}
 */
box2d.b2PulleyJoint.prototype.GetLengthA = function ()
{
	return this.m_lengthA;
}

/** 
 * Get the current length of the segment attached to bodyB. 
 * @export 
 * @return {number}
 */
box2d.b2PulleyJoint.prototype.GetLengthB = function ()
{
	return this.m_lengthB;
}

/** 
 * Get the pulley ratio. 
 * @export 
 * @return {number}
 */
box2d.b2PulleyJoint.prototype.GetRatio = function ()
{
	return this.m_ratio;
}

/** 
 * Get the current length of the segment attached to bodyA. 
 * @export 
 * @return {number}
 */
box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function ()
{
//	b2Vec2 p = m_bodyA->GetWorldPoint(m_localAnchorA);
//	b2Vec2 s = m_groundAnchorA;
//	b2Vec2 d = p - s;
//	return d.Length();
	var p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p);
	var s = this.m_groundAnchorA;
	return box2d.b2DistanceVV(p, s);
}
box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2();

/** 
 * Get the current length of the segment attached to bodyB. 
 * @export 
 * @return {number}
 */
box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function ()
{
//	b2Vec2 p = m_bodyB->GetWorldPoint(m_localAnchorB);
//	b2Vec2 s = m_groundAnchorB;
//	b2Vec2 d = p - s;
//	return d.Length();
	var p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p);
	var s = this.m_groundAnchorB;
	return box2d.b2DistanceVV(p, s);
}
box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2();

/** 
 * Dump joint to dmLog 
 * @export 
 * @return {void}
 */
box2d.b2PulleyJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
		box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n", this.m_groundAnchorB.x, this.m_groundAnchorB.y);
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA);
		box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB);
		box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/** 
 * Implement b2Joint::ShiftOrigin 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} newOrigin
 */
box2d.b2PulleyJoint.prototype.ShiftOrigin = function (newOrigin)
{
	this.m_groundAnchorA.SelfSub(newOrigin);
	this.m_groundAnchorB.SelfSub(newOrigin);
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2CircleShape');

goog.require('box2d.b2Shape');

/** 
 * A circle shape. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Shape} 
 * @param {number=} radius 
 */
box2d.b2CircleShape = function (radius)
{
	goog.base(this, box2d.b2ShapeType.e_circleShape, radius || 0); // base class constructor

	this.m_p = new box2d.b2Vec2();
}

goog.inherits(box2d.b2CircleShape, box2d.b2Shape);

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2CircleShape.prototype.m_p = null;

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {box2d.b2Shape}
 */
box2d.b2CircleShape.prototype.Clone = function ()
{
	return new box2d.b2CircleShape().Copy(this);
}

/**
 * @export 
 * @return {box2d.b2Shape} 
 * @param {box2d.b2Shape} other
 */
box2d.b2CircleShape.prototype.Copy = function (other)
{
	goog.base(this, 'Copy', other);

	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2CircleShape); }

	this.m_p.Copy(other.m_p);
	return this;
}

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {number}
 */
box2d.b2CircleShape.prototype.GetChildCount = function ()
{
	return 1;
}

/** 
 * Implement box2d.b2Shape. 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2Transform} transform 
 * @param {box2d.b2Vec2} p 
 */
box2d.b2CircleShape.prototype.TestPoint = function (transform, p)
{
	var center = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center);
	var d = box2d.b2SubVV(p, center, box2d.b2CircleShape.prototype.TestPoint.s_d);
	return box2d.b2DotVV(d, d) <= box2d.b2Sq(this.m_radius);
}
box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2();
box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2();

/** 
 * Implement box2d.b2Shape. 
 * Collision Detection in Interactive 3D Environments by Gino 
 * van den Bergen From Section 3.1.2 
 * x = s + a * r 
 * norm(x) = radius 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2RayCastOutput} output 
 * @param {box2d.b2RayCastInput} input 
 * @param {box2d.b2Transform} transform 
 * @param {number} childIndex 
 */
box2d.b2CircleShape.prototype.RayCast = function (output, input, transform, childIndex)
{
	var position = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position);
	var s = box2d.b2SubVV(input.p1, position, box2d.b2CircleShape.prototype.RayCast.s_s);
	var b = box2d.b2DotVV(s, s) - box2d.b2Sq(this.m_radius);

	// Solve quadratic equation.
	var r = box2d.b2SubVV(input.p2, input.p1, box2d.b2CircleShape.prototype.RayCast.s_r);
	var c = box2d.b2DotVV(s, r);
	var rr = box2d.b2DotVV(r, r);
	var sigma = c * c - rr * b;

	// Check for negative discriminant and short segment.
	if (sigma < 0 || rr < box2d.b2_epsilon)
	{
		return false;
	}

	// Find the point of intersection of the line with the circle.
	var a = (-(c + box2d.b2Sqrt(sigma)));

	// Is the intersection point on the segment?
	if (0 <= a && a <= input.maxFraction * rr)
	{
		a /= rr;
		output.fraction = a;
		box2d.b2AddVMulSV(s, a, r, output.normal).SelfNormalize();
		return true;
	}

	return false;
}
box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2();
box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2();
box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeAABB 
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Transform} transform 
 * @param {number} childIndex 
 */
box2d.b2CircleShape.prototype.ComputeAABB = function (aabb, transform, childIndex)
{
	var p = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
	aabb.lowerBound.SetXY(p.x - this.m_radius, p.y - this.m_radius);
	aabb.upperBound.SetXY(p.x + this.m_radius, p.y + this.m_radius);
}
box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2();

/** 
 * @see box2d.b2Shape::ComputeMass 
 * @export 
 * @return {void} 
 * @param {box2d.b2MassData} massData 
 * @param {number} density 
 */
box2d.b2CircleShape.prototype.ComputeMass = function (massData, density)
{
	var radius_sq = box2d.b2Sq(this.m_radius);
	massData.mass = density * box2d.b2_pi * radius_sq;
	massData.center.Copy(this.m_p);

	// inertia about the local origin
	massData.I = massData.mass * (0.5 * radius_sq + box2d.b2DotVV(this.m_p, this.m_p));
}

/**
 * @return {void} 
 * @param {box2d.b2DistanceProxy} proxy 
 * @param {number} index 
 */
box2d.b2CircleShape.prototype.SetupDistanceProxy = function (proxy, index)
{
	proxy.m_vertices = new Array(1, true);
	proxy.m_vertices[0] = this.m_p;
	proxy.m_count = 1;
	proxy.m_radius = this.m_radius;
}

/**
 * @export 
 * @return {number}
 * @param {box2d.b2Vec2} normal
 * @param {number} offset
 * @param {box2d.b2Transform} xf
 * @param {box2d.b2Vec2} c
 */
box2d.b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
{
	/** @type {box2d.b2Vec2} */ var p = box2d.b2MulXV(xf, this.m_p, new box2d.b2Vec2());
	/** @type {number} */ var l = (-(box2d.b2DotVV(normal, p) - offset));

	if (l < (-this.m_radius) + box2d.b2_epsilon)
	{
		//Completely dry
		return 0;
	}
	if (l > this.m_radius)
	{
		//Completely wet
		c.Copy(p);
		return box2d.b2_pi * this.m_radius * this.m_radius;
	}

	//Magic
	/** @type {number} */ var r2 = this.m_radius * this.m_radius;
	/** @type {number} */ var l2 = l * l;
	/** @type {number} */ var area = r2 * (box2d.b2Asin(l / this.m_radius) + box2d.b2_pi / 2) + l * box2d.b2Sqrt(r2 - l2);
	/** @type {number} */ var com = (-2 / 3 * box2d.b2Pow(r2 - l2, 1.5) / area);

	c.x = p.x + normal.x * com;
	c.y = p.y + normal.y * com;

	return area;
}

/** 
 * Dump this shape to the log file. 
 * @export 
 * @return {void}
 */
box2d.b2CircleShape.prototype.Dump = function ()
{
	box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n");
	box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
	box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y);
}

/*
* Copyright (c) 2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2Rope');

goog.require('box2d.b2Math');
goog.require('box2d.b2Draw');

/**
 * @export 
 * @constructor
 */
box2d.b2RopeDef = function ()
{
	this.vertices = new Array();
	this.masses = new Array();
	this.gravity = new box2d.b2Vec2();
};

/*box2d.b2Vec2[]*/ box2d.b2RopeDef.prototype.vertices = null;

/*int32*/ box2d.b2RopeDef.prototype.count = 0;

/*float32[]*/ box2d.b2RopeDef.prototype.masses = null;

/*box2d.b2Vec2*/ box2d.b2RopeDef.prototype.gravity = null;

/*float32*/ box2d.b2RopeDef.prototype.damping = 0.1;

/**
 * Stretching stiffness
 */
/*float32*/ box2d.b2RopeDef.prototype.k2 = 0.9;

/**
 * Bending stiffness. Values above 0.5 can make the simulation 
 * blow up. 
 */
/*float32*/ box2d.b2RopeDef.prototype.k3 = 0.1;

/**
 * @export 
 * @constructor
 */
box2d.b2Rope = function ()
{
	this.m_gravity = new box2d.b2Vec2();
};

/*int32*/ box2d.b2Rope.prototype.m_count = 0;
/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_ps = null;
/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_p0s = null;
/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_vs = null;

/*float32[]*/ box2d.b2Rope.prototype.m_ims = null;

/*float32[]*/ box2d.b2Rope.prototype.m_Ls = null;
/*float32[]*/ box2d.b2Rope.prototype.m_as = null;

/*box2d.b2Vec2*/ box2d.b2Rope.prototype.m_gravity = null;
/*float32*/ box2d.b2Rope.prototype.m_damping = 0;

/*float32*/ box2d.b2Rope.prototype.m_k2 = 1;
/*float32*/ box2d.b2Rope.prototype.m_k3 = 0.1;

/** 
 * @export 
 * @return {number}
 */
box2d.b2Rope.prototype.GetVertexCount = function ()
{
	return this.m_count;
}

/**
 * @export 
 * @return {Array.<box2d.b2Vec2>}
 */
box2d.b2Rope.prototype.GetVertices = function ()
{
	return this.m_ps;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2RopeDef} def
 */
box2d.b2Rope.prototype.Initialize = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.count >= 3); }
	this.m_count = def.count;
//	this.m_ps = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));
	this.m_ps = box2d.b2Vec2.MakeArray(this.m_count);
//	this.m_p0s = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));
	this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count);
//	this.m_vs = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));
	this.m_vs = box2d.b2Vec2.MakeArray(this.m_count);
//	this.m_ims = (float32*)b2Alloc(this.m_count * sizeof(float32));
	this.m_ims = box2d.b2MakeNumberArray(this.m_count);

	for (/*int32*/ var i = 0; i < this.m_count; ++i)
	{
		this.m_ps[i].Copy(def.vertices[i]);
		this.m_p0s[i].Copy(def.vertices[i]);
		this.m_vs[i].SetZero();

		/*float32*/ var m = def.masses[i];
		if (m > 0)
		{
			this.m_ims[i] = 1 / m;
		}
		else
		{
			this.m_ims[i] = 0;
		}
	}

	/*int32*/ var count2 = this.m_count - 1;
	/*int32*/ var count3 = this.m_count - 2;
//	this.m_Ls = (float32*)be2Alloc(count2 * sizeof(float32));
	this.m_Ls = box2d.b2MakeNumberArray(count2);
//	this.m_as = (float32*)b2Alloc(count3 * sizeof(float32));
	this.m_as = box2d.b2MakeNumberArray(count3);

	for (/*int32*/ var i = 0; i < count2; ++i)
	{
		/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];
		/*box2d.b2Vec2&*/ var p2 = this.m_ps[i+1];
		this.m_Ls[i] = box2d.b2DistanceVV(p1, p2);
	}

	for (/*int32*/ var i = 0; i < count3; ++i)
	{
		/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];
		/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];
		/*box2d.b2Vec2&*/ var p3 = this.m_ps[i + 2];

		/*box2d.b2Vec2*/ var d1 = box2d.b2SubVV(p2, p1, box2d.b2Vec2.s_t0);
		/*box2d.b2Vec2*/ var d2 = box2d.b2SubVV(p3, p2, box2d.b2Vec2.s_t1);

		/*float32*/ var a = box2d.b2CrossVV(d1, d2);
		/*float32*/ var b = box2d.b2DotVV(d1, d2);

		this.m_as[i] = box2d.b2Atan2(a, b);
	}

	this.m_gravity.Copy(def.gravity);
	this.m_damping = def.damping;
	this.m_k2 = def.k2;
	this.m_k3 = def.k3;
}

/**
 * @export 
 * @return {void} 
 * @param {number} h 
 * @param {number} iterations 
 */
box2d.b2Rope.prototype.Step = function (/*float32*/ h, /*int32*/ iterations)
{
	if (h === 0)
	{
		return;
	}

	/*float32*/ var d = Math.exp(- h * this.m_damping);

	for (/*int32*/ var i = 0; i < this.m_count; ++i)
	{
		this.m_p0s[i].Copy(this.m_ps[i]);
		if (this.m_ims[i] > 0)
		{
			this.m_vs[i].SelfMulAdd(h, this.m_gravity);
		}
		this.m_vs[i].SelfMul(d);
		this.m_ps[i].SelfMulAdd(h, this.m_vs[i]);

	}

	for (/*int32*/ var i = 0; i < iterations; ++i)
	{
		this.SolveC2();
		this.SolveC3();
		this.SolveC2();
	}

	/*float32*/ var inv_h = 1 / h;
	for (/*int32*/ var i = 0; i < this.m_count; ++i)
	{
		box2d.b2MulSV(inv_h, box2d.b2SubVV(this.m_ps[i], this.m_p0s[i], box2d.b2Vec2.s_t0), this.m_vs[i]);
	}
}

/**
 * @export 
 * @return {void}
 */
box2d.b2Rope.prototype.SolveC2 = function ()
{
	/*int32*/ var count2 = this.m_count - 1;

	for (/*int32*/ var i = 0; i < count2; ++i)
	{
		/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];
		/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];

		/*box2d.b2Vec2*/ var d = box2d.b2SubVV(p2, p1, box2d.b2Rope.s_d);
		/*float32*/ var L = d.Normalize();

		/*float32*/ var im1 = this.m_ims[i];
		/*float32*/ var im2 = this.m_ims[i + 1];

		if (im1 + im2 === 0)
		{
			continue;
		}

		/*float32*/ var s1 = im1 / (im1 + im2);
		/*float32*/ var s2 = im2 / (im1 + im2);

		p1.SelfMulSub(this.m_k2 * s1 * (this.m_Ls[i] - L), d);
		p2.SelfMulAdd(this.m_k2 * s2 * (this.m_Ls[i] - L), d);

//		this.m_ps[i] = p1;
//		this.m_ps[i + 1] = p2;
	}
}
box2d.b2Rope.s_d = new box2d.b2Vec2();

/**
 * @export 
 * @return {void}
 * @param {number} angle
 */
box2d.b2Rope.prototype.SetAngleRadians = function (angle)
{
	/*int32*/ var count3 = this.m_count - 2;
	for (/*int32*/ var i = 0; i < count3; ++i)
	{
		this.m_as[i] = angle;
	}
}

/**
 * @export 
 * @return {void}
 */
box2d.b2Rope.prototype.SolveC3 = function ()
{
	/*int32*/ var count3 = this.m_count - 2;

	for (/*int32*/ var i = 0; i < count3; ++i)
	{
		/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];
		/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];
		/*box2d.b2Vec2&*/ var p3 = this.m_ps[i + 2];

		/*float32*/ var m1 = this.m_ims[i];
		/*float32*/ var m2 = this.m_ims[i + 1];
		/*float32*/ var m3 = this.m_ims[i + 2];

		/*box2d.b2Vec2*/ var d1 = box2d.b2SubVV(p2, p1, box2d.b2Rope.s_d1);
		/*box2d.b2Vec2*/ var d2 = box2d.b2SubVV(p3, p2, box2d.b2Rope.s_d2);

		/*float32*/ var L1sqr = d1.GetLengthSquared();
		/*float32*/ var L2sqr = d2.GetLengthSquared();

		if (L1sqr * L2sqr === 0)
		{
			continue;
		}

		/*float32*/ var a = box2d.b2CrossVV(d1, d2);
		/*float32*/ var b = box2d.b2DotVV(d1, d2);

		/*float32*/ var angle = box2d.b2Atan2(a, b);

		/*box2d.b2Vec2*/ var Jd1 = box2d.b2MulSV((-1 / L1sqr), d1.SelfSkew(), box2d.b2Rope.s_Jd1);
		/*box2d.b2Vec2*/ var Jd2 = box2d.b2MulSV(( 1 / L2sqr), d2.SelfSkew(), box2d.b2Rope.s_Jd2);

		/*box2d.b2Vec2*/ var J1 = box2d.b2NegV(Jd1, box2d.b2Rope.s_J1);
		/*box2d.b2Vec2*/ var J2 = box2d.b2SubVV(Jd1, Jd2, box2d.b2Rope.s_J2);
		/*box2d.b2Vec2*/ var J3 = Jd2;

		/*float32*/ var mass = m1 * box2d.b2DotVV(J1, J1) + m2 * box2d.b2DotVV(J2, J2) + m3 * box2d.b2DotVV(J3, J3);
		if (mass === 0)
		{
			continue;
		}

		mass = 1 / mass;

		/*float32*/ var C = angle - this.m_as[i];

		while (C > box2d.b2_pi)
		{
			angle -= 2 * box2d.b2_pi;
			C = angle - this.m_as[i];
		}

		while (C < -box2d.b2_pi)
		{
			angle += 2 * box2d.b2_pi;
			C = angle - this.m_as[i];
		}

		/*float32*/ var impulse = - this.m_k3 * mass * C;

		p1.SelfMulAdd((m1 * impulse), J1);
		p2.SelfMulAdd((m2 * impulse), J2);
		p3.SelfMulAdd((m3 * impulse), J3);

//		this.m_ps[i] = p1;
//		this.m_ps[i + 1] = p2;
//		this.m_ps[i + 2] = p3;
	}
}
box2d.b2Rope.s_d1 = new box2d.b2Vec2();
box2d.b2Rope.s_d2 = new box2d.b2Vec2();
box2d.b2Rope.s_Jd1 = new box2d.b2Vec2();
box2d.b2Rope.s_Jd2 = new box2d.b2Vec2();
box2d.b2Rope.s_J1 = new box2d.b2Vec2();
box2d.b2Rope.s_J2 = new box2d.b2Vec2();

/** 
 * @export 
 * @return {void}
 * @param {box2d.b2Draw} draw
 */
box2d.b2Rope.prototype.Draw = function (draw)
{
	/*box2d.b2Color*/ var c = new box2d.b2Color(0.4, 0.5, 0.7);

	for (/*int32*/ var i = 0; i < this.m_count - 1; ++i)
	{
		draw.DrawSegment(this.m_ps[i], this.m_ps[i+1], c);
	}
}

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2WheelJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');

/** 
 * Wheel joint definition. This requires defining a line of 
 * motion using an axis and an anchor point. The definition uses 
 * local anchor points and a local axis so that the initial 
 * configuration can violate the constraint slightly. The joint 
 * translation is zero when the local anchor points coincide in 
 * world space. Using local anchors and a local axis helps when 
 * saving and loading a game. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2WheelJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_wheelJoint); // base class constructor

	this.localAnchorA = new box2d.b2Vec2(0, 0);
	this.localAnchorB = new box2d.b2Vec2(0, 0);
	this.localAxisA = new box2d.b2Vec2(1, 0);
}

goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef);

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJointDef.prototype.localAnchorA = null;

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJointDef.prototype.localAnchorB = null;

/** 
 * The local translation axis in bodyA. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJointDef.prototype.localAxisA = null;

/** 
 * Enable/disable the joint motor. 
 * @export 
 * @type {boolean}
 */
box2d.b2WheelJointDef.prototype.enableMotor = false;

/** 
 * The maximum motor torque, usually in N-m. 
 * @export 
 * @type {number}
 */
box2d.b2WheelJointDef.prototype.maxMotorTorque = 0;

/** 
 * The desired motor speed in radians per second. 
 * @export 
 * @type {number}
 */
box2d.b2WheelJointDef.prototype.motorSpeed = 0;

/** 
 * Suspension frequency, zero indicates no suspension 
 * @export 
 * @type {number}
 */
box2d.b2WheelJointDef.prototype.frequencyHz = 2;

/** 
 * Suspension damping ratio, one indicates critical damping 
 * @export 
 * @type {number}
 */
box2d.b2WheelJointDef.prototype.dampingRatio = 0.7;

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 * @param {box2d.b2Vec2} anchor 
 * @param {box2d.b2Vec2} axis 
 */
box2d.b2WheelJointDef.prototype.Initialize = function (bA, bB, anchor, axis)
{
	this.bodyA = bA;
	this.bodyB = bB;
	this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
	this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
	this.bodyA.GetLocalVector(axis, this.localAxisA);
}

/** 
 * A wheel joint. This joint provides two degrees of freedom: 
 * translation along an axis fixed in bodyA and rotation in the 
 * plane. You can use a joint limit to restrict the range of 
 * motion and a joint motor to drive the rotation or to model 
 * rotational friction. 
 * This joint is designed for vehicle suspensions.
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2WheelJointDef} def 
 */
box2d.b2WheelJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_frequencyHz = def.frequencyHz;
	this.m_dampingRatio = def.dampingRatio;

	this.m_localAnchorA = def.localAnchorA.Clone();
	this.m_localAnchorB = def.localAnchorB.Clone();
	this.m_localXAxisA = def.localAxisA.Clone();
	this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2());

	this.m_maxMotorTorque = def.maxMotorTorque;
	this.m_motorSpeed = def.motorSpeed;
	this.m_enableMotor = def.enableMotor;

	this.m_localCenterA = new box2d.b2Vec2();
	this.m_localCenterB = new box2d.b2Vec2();

	this.m_ax = new box2d.b2Vec2(), this.m_ay = new box2d.b2Vec2();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_lalcA = new box2d.b2Vec2();
	this.m_lalcB = new box2d.b2Vec2();
	this.m_rA = new box2d.b2Vec2();
	this.m_rB = new box2d.b2Vec2();

	this.m_ax.SetZero();
	this.m_ay.SetZero();
}

goog.inherits(box2d.b2WheelJoint, box2d.b2Joint);

/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_frequencyHz = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_dampingRatio = 0;

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localAnchorA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localAnchorB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localXAxisA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localYAxisA = null;

/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_impulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_motorImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_springImpulse = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_motorSpeed = 0;
/**
 * @export 
 * @type {boolean}
 */
box2d.b2WheelJoint.prototype.m_enableMotor = false;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_invIB = 0;

/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_ax = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_ay = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_sAx = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_sBx = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_sAy = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_sBy = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_mass = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_motorMass = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_springMass = 0;

/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_bias = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2WheelJoint.prototype.m_gamma = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2WheelJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2WheelJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_lalcA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_lalcB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2WheelJoint.prototype.m_rB = null;

/** 
 * Get the motor speed, usually in radians per second. 
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetMotorSpeed = function ()
{
	return this.m_motorSpeed;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function ()
{
	return this.m_maxMotorTorque;
}

/**
 * @export 
 * @return {void} 
 * @param {number} hz
 */
box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function (hz)
{
	this.m_frequencyHz = hz;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function ()
{
	return this.m_frequencyHz;
}

/**
 * @export 
 * @return {void} 
 * @param {number} ratio
 */
box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function (ratio)
{
	this.m_dampingRatio = ratio;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function ()
{
	return this.m_dampingRatio;
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2WheelJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	// Compute the effective masses.
//	box2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	box2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	box2d.b2Vec2 d = cB + rB - cA - rA;
	var d = box2d.b2SubVV(
		box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), 
		box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), 
		box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);

	// Point to line constraint
	{
//		m_ay = b2Mul(qA, m_localYAxisA);
		box2d.b2MulRV(qA, this.m_localYAxisA, this.m_ay);
//		m_sAy = b2Cross(d + rA, m_ay);
		this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_ay);
//		m_sBy = b2Cross(rB, m_ay);
		this.m_sBy = box2d.b2CrossVV(rB, this.m_ay);

		this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;

		if (this.m_mass > 0)
		{
			this.m_mass = 1 / this.m_mass;
		}
	}

	// Spring constraint
	this.m_springMass = 0;
	this.m_bias = 0;
	this.m_gamma = 0;
	if (this.m_frequencyHz > 0)
	{
//		m_ax = b2Mul(qA, m_localXAxisA);
		box2d.b2MulRV(qA, this.m_localXAxisA, this.m_ax);
//		m_sAx = b2Cross(d + rA, m_ax);
		this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_ax);
//		m_sBx = b2Cross(rB, m_ax);
		this.m_sBx = box2d.b2CrossVV(rB, this.m_ax);

		/*float32*/ var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;

		if (invMass > 0)
		{
			this.m_springMass = 1 / invMass;

			/*float32*/ var C = box2d.b2DotVV(d, this.m_ax);

			// Frequency
			/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;

			// Damping coefficient
			/*float32*/ var dc = 2 * this.m_springMass * this.m_dampingRatio * omega;

			// Spring stiffness
			/*float32*/ var k = this.m_springMass * omega * omega;

			// magic formulas
			/*float32*/ var h = data.step.dt;
			this.m_gamma = h * (dc + h * k);
			if (this.m_gamma > 0)
			{
				this.m_gamma = 1 / this.m_gamma;
			}

			this.m_bias = C * h * k * this.m_gamma;

			this.m_springMass = invMass + this.m_gamma;
			if (this.m_springMass > 0)
			{
				this.m_springMass = 1 / this.m_springMass;
			}
		}
	}
	else
	{
		this.m_springImpulse = 0;
	}

	// Rotational motor
	if (this.m_enableMotor)
	{
		this.m_motorMass = iA + iB;
		if (this.m_motorMass > 0)
		{
			this.m_motorMass = 1 / this.m_motorMass;
		}
	}
	else
	{
		this.m_motorMass = 0;
		this.m_motorImpulse = 0;
	}

	if (data.step.warmStarting)
	{
		// Account for variable time step.
		this.m_impulse *= data.step.dtRatio;
		this.m_springImpulse *= data.step.dtRatio;
		this.m_motorImpulse *= data.step.dtRatio;

//		box2d.b2Vec2 P = m_impulse * m_ay + m_springImpulse * m_ax;
		var P = box2d.b2AddVV(
			box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), 
			box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), 
			box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P);
//		float32 LA = m_impulse * m_sAy + m_springImpulse * m_sAx + m_motorImpulse;
		/*float32*/ var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
//		float32 LB = m_impulse * m_sBy + m_springImpulse * m_sBx + m_motorImpulse;
		/*float32*/ var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;

//		vA -= m_invMassA * P;
		vA.SelfMulSub(this.m_invMassA, P);
		wA -= this.m_invIA * LA;

//		vB += m_invMassB * P;
		vB.SelfMulAdd(this.m_invMassB, P);
		wB += this.m_invIB * LB;
	}
	else
	{
		this.m_impulse = 0;
		this.m_springImpulse = 0;
		this.m_motorImpulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2();
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	// Solve spring constraint
	if (true)
	{
		/*float32*/ var Cdot = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_sBx * wB - this.m_sAx * wA;
		/*float32*/ var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
		this.m_springImpulse += impulse;

//		box2d.b2Vec2 P = impulse * m_ax;
		var P = box2d.b2MulSV(impulse, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);
		/*float32*/ var LA = impulse * this.m_sAx;
		/*float32*/ var LB = impulse * this.m_sBx;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}

	// Solve rotational motor constraint
	if (true)
	{
		/*float32*/ var Cdot = wB - wA - this.m_motorSpeed;
		/*float32*/ var impulse = -this.m_motorMass * Cdot;

		/*float32*/ var oldImpulse = this.m_motorImpulse;
		/*float32*/ var maxImpulse = data.step.dt * this.m_maxMotorTorque;
		this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = this.m_motorImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve point to line constraint
	if (true)
	{
		/*float32*/ var Cdot = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_sBy * wB - this.m_sAy * wA;
		/*float32*/ var impulse = -this.m_mass * Cdot;
		this.m_impulse += impulse;

//		box2d.b2Vec2 P = impulse * m_ay;
		var P = box2d.b2MulSV(impulse, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);
		/*float32*/ var LA = impulse * this.m_sAy;
		/*float32*/ var LB = impulse * this.m_sBy;

//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * LA;

//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * LB;
	}

//	data.velocities[this.m_indexA].v = vA;
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB;
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2WheelJoint.prototype.SolvePositionConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

//	box2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
	box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
	var rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);
//	box2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
	box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
	var rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);
//	box2d.b2Vec2 d = (cB - cA) + rB - rA;
	var d = box2d.b2AddVV(
		box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), 
		box2d.b2SubVV(rB, rA, box2d.b2Vec2.s_t1), 
		box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d);

//	box2d.b2Vec2 ay = b2Mul(qA, m_localYAxisA);
	var ay = box2d.b2MulRV(qA, this.m_localYAxisA, this.m_ay);

//	float32 sAy = b2Cross(d + rA, ay);
	var sAy = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), ay);
//	float32 sBy = b2Cross(rB, ay);
	var sBy = box2d.b2CrossVV(rB, ay);

//	float32 C = b2Dot(d, ay);
	var C = box2d.b2DotVV(d, this.m_ay);

	/*float32*/ var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;

	/*float32*/ var impulse;
	if (k !== 0)
	{
		impulse = - C / k;
	}
	else
	{
		impulse = 0;
	}

//	box2d.b2Vec2 P = impulse * ay;
	var P = box2d.b2MulSV(impulse, ay, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P);
	/*float32*/ var LA = impulse * sAy;
	/*float32*/ var LB = impulse * sBy;

//	cA -= m_invMassA * P;
	cA.SelfMulSub(this.m_invMassA, P);
	aA -= this.m_invIA * LA;
//	cB += m_invMassB * P;
	cB.SelfMulAdd(this.m_invMassB, P);
	aB += this.m_invIB * LB;

//	data.positions[this.m_indexA].c = cA;
	data.positions[this.m_indexA].a = aA;
//	data.positions[this.m_indexB].c = cB;
	data.positions[this.m_indexB].a = aB;

	return box2d.b2Abs(C) <= box2d.b2_linearSlop;
}
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2();
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();

/**
 * @export 
 * @return {box2d.b2WheelJointDef} 
 * @param {box2d.b2WheelJointDef} def 
 */
box2d.b2WheelJoint.prototype.GetDefinition = function (def)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); } // TODO
	return def;
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WheelJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WheelJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2WheelJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	return inv_dt * (m_impulse * m_ay + m_springImpulse * m_ax);
	out.x = inv_dt * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);
	out.y = inv_dt * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);
	return out;
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2WheelJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_motorImpulse;
}

/** 
 * The local anchor point relative to bodyA's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WheelJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }

/** 
 * The local anchor point relative to bodyB's origin. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WheelJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }

/** 
 * The local joint axis relative to bodyA. 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2WheelJoint.prototype.GetLocalAxisA = function (out) { return out.Copy(this.m_localXAxisA); }

/**
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetJointTranslation = function ()
{
	/*box2d.b2Body*/ var bA = this.m_bodyA;
	/*box2d.b2Body*/ var bB = this.m_bodyB;

	/*box2d.b2Vec2*/ var pA = bA.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2());
	/*box2d.b2Vec2*/ var pB = bB.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2());
	/*box2d.b2Vec2*/ var d = box2d.b2SubVV(pB, pA, new box2d.b2Vec2());
	/*box2d.b2Vec2*/ var axis = bA.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2());

	/*float32*/ var translation = box2d.b2DotVV(d, axis);
	return translation;
}

/**
 * @export 
 * @return {number}
 */
box2d.b2WheelJoint.prototype.GetJointSpeed = function ()
{
	/*float32*/ var wA = this.m_bodyA.m_angularVelocity;
	/*float32*/ var wB = this.m_bodyB.m_angularVelocity;
	return wB - wA;
}

/**
 * @export 
 * @return {boolean}
 */
box2d.b2WheelJoint.prototype.IsMotorEnabled = function ()
{
	return this.m_enableMotor;
}

/**
 * @export 
 * @return {void} 
 * @param {boolean} flag
 */
box2d.b2WheelJoint.prototype.EnableMotor = function (flag)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_enableMotor = flag;
}

/** 
 * Set the motor speed, usually in radians per second. 
 * @export 
 * @return {void} 
 * @param {number} speed
 */
box2d.b2WheelJoint.prototype.SetMotorSpeed = function (speed)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_motorSpeed = speed;
}

/** 
 * Set/Get the maximum motor force, usually in N-m. 
 * @export 
 * @return {void} 
 * @param {number} force
 */
box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function (force)
{
	this.m_bodyA.SetAwake(true);
	this.m_bodyB.SetAwake(true);
	this.m_maxMotorTorque = force;
}

/** 
 * Get the current motor torque given the inverse time step, 
 * usually in N-m. 
 * @export 
 * @return {number}
 * @param {number} inv_dt 
 */
box2d.b2WheelJoint.prototype.GetMotorTorque = function (inv_dt)
{
	return inv_dt * this.m_motorImpulse;
}

/** 
 * Dump to b2Log 
 * @export 
 * @return {void}
 */
box2d.b2WheelJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;
	
		box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n");
		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));
		box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
		box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
		box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
		box2d.b2Log("  jd.enableMotor = %s;\n", (this.m_enableMotor)?('true'):('false'));
		box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
		box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
		box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
		box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.b2MotorJoint');

goog.require('box2d.b2Settings');
goog.require('box2d.b2Math');

/** 
 * Motor joint definition. 
 * @export 
 * @constructor 
 * @extends {box2d.b2JointDef} 
 */
box2d.b2MotorJointDef = function ()
{
	goog.base(this, box2d.b2JointType.e_motorJoint); // base class constructor

	this.linearOffset = new box2d.b2Vec2(0, 0);
}

goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef);

/** 
 * Position of bodyB minus the position of bodyA, in bodyA's 
 * frame, in meters. 
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJointDef.prototype.linearOffset = null;

/** 
 * The bodyB angle minus bodyA angle in radians. 
 * @export 
 * @type {number}
 */
box2d.b2MotorJointDef.prototype.angularOffset = 0;

/** 
 * The maximum motor force in N. 
 * @export 
 * @type {number}
 */
box2d.b2MotorJointDef.prototype.maxForce = 1;

/** 
 * The maximum motor torque in N-m. 
 * @export 
 * @type {number}
 */
box2d.b2MotorJointDef.prototype.maxTorque = 1;

/** 
 * Position correction factor in the range [0,1]. 
 * @export 
 * @type {number}
 */
box2d.b2MotorJointDef.prototype.correctionFactor = 0.3;

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Body} bA 
 * @param {box2d.b2Body} bB 
 */
box2d.b2MotorJointDef.prototype.Initialize = function (bA, bB)
{
	this.bodyA = bA;
	this.bodyB = bB;
//	b2Vec2 xB = bodyB->GetPosition();
//	linearOffset = bodyA->GetLocalPoint(xB);
	this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);

	/** @type {number} */ var angleA = this.bodyA.GetAngleRadians();
	/** @type {number} */ var angleB = this.bodyB.GetAngleRadians();
	this.angularOffset = angleB - angleA;
}

/** 
 * A motor joint is used to control the relative motion between 
 * two bodies. A typical usage is to control the movement of a 
 * dynamic body with respect to the ground. 
 * @export 
 * @constructor 
 * @extends {box2d.b2Joint} 
 * @param {box2d.b2MotorJointDef} def 
 */
box2d.b2MotorJoint = function (def)
{
	goog.base(this, def); // base class constructor

	this.m_linearOffset = def.linearOffset.Clone();
	this.m_linearImpulse = new box2d.b2Vec2(0, 0);
	this.m_maxForce = def.maxForce;
	this.m_maxTorque = def.maxTorque;
	this.m_correctionFactor = def.correctionFactor;

	this.m_rA = new box2d.b2Vec2(0, 0);
	this.m_rB = new box2d.b2Vec2(0, 0);
	this.m_localCenterA = new box2d.b2Vec2(0, 0);
	this.m_localCenterB = new box2d.b2Vec2(0, 0);
	this.m_linearError = new box2d.b2Vec2(0, 0);
	this.m_linearMass = new box2d.b2Mat22();

	this.m_qA = new box2d.b2Rot();
	this.m_qB = new box2d.b2Rot();
	this.m_K = new box2d.b2Mat22();
}

goog.inherits(box2d.b2MotorJoint, box2d.b2Joint);

// Solver shared
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_linearOffset = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_angularOffset = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_linearImpulse = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_angularImpulse = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_maxForce = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_maxTorque = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_correctionFactor = 0.3;

// Solver temp
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_indexA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_indexB = 0;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_rA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_rB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_localCenterA = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_localCenterB = null;
/**
 * @export 
 * @type {box2d.b2Vec2}
 */
box2d.b2MotorJoint.prototype.m_linearError = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_angularError = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_invMassA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_invMassB = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_invIA = 0;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_invIB = 0;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2MotorJoint.prototype.m_linearMass = null;
/**
 * @export 
 * @type {number}
 */
box2d.b2MotorJoint.prototype.m_angularMass = 0;

/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2MotorJoint.prototype.m_qA = null;
/**
 * @export 
 * @type {box2d.b2Rot}
 */
box2d.b2MotorJoint.prototype.m_qB = null;
/**
 * @export 
 * @type {box2d.b2Mat22}
 */
box2d.b2MotorJoint.prototype.m_K = null;

/** 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MotorJoint.prototype.GetAnchorA = function (out)
{
	return this.m_bodyA.GetPosition(out);
}
/**
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MotorJoint.prototype.GetAnchorB = function (out)
{
	return this.m_bodyB.GetPosition(out);
}

/** 
 * @export 
 * @return {box2d.b2Vec2} 
 * @param {number} inv_dt 
 * @param {box2d.b2Vec2} out
 */
box2d.b2MotorJoint.prototype.GetReactionForce = function (inv_dt, out)
{
//	return inv_dt * m_linearImpulse;
	return box2d.b2MulSV(inv_dt, this.m_linearImpulse, out);
}

/** 
 * @export 
 * @return {number} 
 * @param {number} inv_dt 
 */
box2d.b2MotorJoint.prototype.GetReactionTorque = function (inv_dt)
{
	return inv_dt * this.m_angularImpulse;
}

/**
 * Set the position correction factor in the range [0,1]. 
 * @return {void} 
 * @param {number} factor 
 */
box2d.b2MotorJoint.prototype.SetCorrectionFactor = function (factor)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(factor) && 0.0 <= factor && factor <= 1.0) };
	this._correctionFactor = factor;
}

/**
 * Get the position correction factor in the range [0,1]. 
 * @return {number} 
 */
box2d.b2MotorJoint.prototype.GetCorrectionFactor = function ()
{
	return this.m_correctionFactor;
}

/** 
 * Set/get the target linear offset, in frame A, in meters. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} linearOffset
 */
box2d.b2MotorJoint.prototype.SetLinearOffset = function (linearOffset)
{
	if (!box2d.b2IsEqualToV(linearOffset, this.m_linearOffset))
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_linearOffset.Copy(linearOffset);
	}
}
/** 
 * @export 
 * @return {box2d.b2Vec2}
 * @param {box2d.b2Vec2} out 
 */
box2d.b2MotorJoint.prototype.GetLinearOffset = function (out)
{
	return out.Copy(this.m_linearOffset);
}

/** 
 * Set/get the target angular offset, in radians. 
 * @export 
 * @return {void} 
 * @param {number} angularOffset
 */
box2d.b2MotorJoint.prototype.SetAngularOffset = function (angularOffset)
{
	if (angularOffset !== this.m_angularOffset)
	{
		this.m_bodyA.SetAwake(true);
		this.m_bodyB.SetAwake(true);
		this.m_angularOffset = angularOffset;
	}
}
/** 
 * @export 
 * @return {number}
 */
box2d.b2MotorJoint.prototype.GetAngularOffset = function ()
{
	return this.m_angularOffset;
}

/** 
 * Set the maximum friction force in N. 
 * @export 
 * @return {void} 
 * @param {number} force
 */
box2d.b2MotorJoint.prototype.SetMaxForce = function (force)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(force) && force >= 0); }
	this.m_maxForce = force;
}

/** 
 * Get the maximum friction force in N. 
 * @export 
 * @return {number}
 */
box2d.b2MotorJoint.prototype.GetMaxForce = function ()
{
	return this.m_maxForce;
}

/** 
 * Set the maximum friction torque in N*m. 
 * @export 
 * @return {void} 
 * @param {number} torque
 */
box2d.b2MotorJoint.prototype.SetMaxTorque = function (torque)
{
	if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(torque) && torque >= 0); }
	this.m_maxTorque = torque;
}

/** 
 * Get the maximum friction torque in N*m. 
 * @export 
 * @return {number}
 */
box2d.b2MotorJoint.prototype.GetMaxTorque = function ()
{
	return this.m_maxTorque;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2MotorJoint.prototype.InitVelocityConstraints = function (data)
{
	this.m_indexA = this.m_bodyA.m_islandIndex;
	this.m_indexB = this.m_bodyB.m_islandIndex;
	this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
	this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
	this.m_invMassA = this.m_bodyA.m_invMass;
	this.m_invMassB = this.m_bodyB.m_invMass;
	this.m_invIA = this.m_bodyA.m_invI;
	this.m_invIB = this.m_bodyB.m_invI;

	/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;
	/*float32*/ var aA = data.positions[this.m_indexA].a;
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;

	/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;
	/*float32*/ var aB = data.positions[this.m_indexB].a;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);

	// Compute the effective mass matrix.
//	this.m_rA = b2Mul(qA, -this.m_localCenterA);
	var rA = box2d.b2MulRV(qA, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA);
//	this.m_rB = b2Mul(qB, -this.m_localCenterB); 
	var rB = box2d.b2MulRV(qB, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;
	 
	/*b2Mat22*/ var K = this.m_K;
	K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
	K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
	K.ey.x = K.ex.y;
	K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

//	this.m_linearMass = K.GetInverse(); 
	K.GetInverse(this.m_linearMass);

	this.m_angularMass = iA + iB;
	if (this.m_angularMass > 0)
	{
		this.m_angularMass = 1 / this.m_angularMass;
	}

//	this.m_linearError = cB + rB - cA - rA - b2Mul(qA, this.m_linearOffset);
	box2d.b2SubVV(
		box2d.b2SubVV(
			box2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), 
			box2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), 
			box2d.b2Vec2.s_t2),
		box2d.b2MulRV(qA, this.m_linearOffset, box2d.b2Vec2.s_t3), 
		this.m_linearError);
	this.m_angularError = aB - aA - this.m_angularOffset; 

	if (data.step.warmStarting)
	{
		// Scale impulses to support a variable time step.
//		this.m_linearImpulse *= data.step.dtRatio;
		this.m_linearImpulse.SelfMul(data.step.dtRatio);
		this.m_angularImpulse *= data.step.dtRatio;

//		b2Vec2 P(this.m_linearImpulse.x, this.m_linearImpulse.y);
		var P = this.m_linearImpulse;
//		vA -= mA * P;
		vA.SelfMulSub(mA, P);
		wA -= iA * (box2d.b2CrossVV(rA, P) + this.m_angularImpulse);
//		vB += mB * P;
		vB.SelfMulAdd(mB, P);
		wB += iB * (box2d.b2CrossVV(rB, P) + this.m_angularImpulse);
	}
	else
	{
		this.m_linearImpulse.SetZero();
		this.m_angularImpulse = 0;
	}

//	data.velocities[this.m_indexA].v = vA; // vA is a reference
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB; // vB is a reference
	data.velocities[this.m_indexB].w = wB;
}

/** 
 * @export 
 * @return {void} 
 * @param {box2d.b2SolverData} data
 */
box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function (data)
{
	/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;
	/*float32*/ var wA = data.velocities[this.m_indexA].w;
	/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;
	/*float32*/ var wB = data.velocities[this.m_indexB].w;

	/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;
	/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;

	/*float32*/ var h = data.step.dt;
	/*float32*/ var inv_h = data.step.inv_dt;

	// Solve angular friction
	{
		/*float32*/ var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
		/*float32*/ var impulse = -this.m_angularMass * Cdot;

		/*float32*/ var oldImpulse = this.m_angularImpulse;
		/*float32*/ var maxImpulse = h * this.m_maxTorque;
		this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = this.m_angularImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve linear friction
	{
		var rA = this.m_rA;
		var rB = this.m_rB;

//		b2Vec2 Cdot = vB + b2CrossSV(wB, rB) - vA - b2CrossSV(wA, rA) + inv_h * this.m_correctionFactor * this.m_linearError;
		var Cdot = 
			box2d.b2AddVV(
				box2d.b2SubVV(
					box2d.b2AddVV(vB, box2d.b2CrossSV(wB, rB, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), 
					box2d.b2AddVV(vA, box2d.b2CrossSV(wA, rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), 
				box2d.b2MulSV(inv_h * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), 
				box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot);

//		b2Vec2 impulse = -b2Mul(this.m_linearMass, Cdot);
		var impulse = box2d.b2MulMV(this.m_linearMass, Cdot, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
//		b2Vec2 oldImpulse = this.m_linearImpulse;
		var oldImpulse = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
//		this.m_linearImpulse += impulse;
		this.m_linearImpulse.SelfAdd(impulse);

		/*float32*/ var maxImpulse = h * this.m_maxForce;

		if (this.m_linearImpulse.GetLengthSquared() > maxImpulse * maxImpulse)
		{
			this.m_linearImpulse.Normalize();
//			this.m_linearImpulse *= maxImpulse;
			this.m_linearImpulse.SelfMul(maxImpulse);
		}

//		impulse = this.m_linearImpulse - oldImpulse;
		box2d.b2SubVV(this.m_linearImpulse, oldImpulse, impulse);

//		vA -= mA * impulse;
		vA.SelfMulSub(mA, impulse);
//		wA -= iA * b2CrossVV(rA, impulse);
		wA -= iA * box2d.b2CrossVV(rA, impulse);

//		vB += mB * impulse;
		vB.SelfMulAdd(mB, impulse);
//		wB += iB * b2CrossVV(rB, impulse);
		wB += iB * box2d.b2CrossVV(rB, impulse);
	}

//	data.velocities[this.m_indexA].v = vA; // vA is a reference
	data.velocities[this.m_indexA].w = wA;
//	data.velocities[this.m_indexB].v = vB; // vB is a reference
	data.velocities[this.m_indexB].w = wB;
}
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2();
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2();

/** 
 * @export 
 * @return {boolean} 
 * @param {box2d.b2SolverData} data 
 */
box2d.b2MotorJoint.prototype.SolvePositionConstraints = function (data)
{
	return true;
}

/** 
 * Dump to b2Log 
 * @export 
 * @return {void}
 */
box2d.b2MotorJoint.prototype.Dump = function ()
{
	if (box2d.DEBUG)
	{
		var indexA = this.m_bodyA.m_islandIndex;
		var indexB = this.m_bodyB.m_islandIndex;

		box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n");

		box2d.b2Log("  jd.bodyA = bodies[%d];\n", indexA);
		box2d.b2Log("  jd.bodyB = bodies[%d];\n", indexB);
		box2d.b2Log("  jd.collideConnected = %s;\n", (this.m_collideConnected)?('true'):('false'));

		box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
		box2d.b2Log("  jd.angularOffset = %.15f;\n", this.m_angularOffset);
		box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
		box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
		box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
		box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
	}
}

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d');

/**
\mainpage Box2D API Documentation

\section intro_sec Getting Started

For documentation please see http://box2d.org/documentation.html

For discussion please visit http://box2d.org/forum
*/

// These include files constitute the main Box2D API

goog.require('box2d.b2Settings');
goog.require('box2d.b2Draw');
goog.require('box2d.b2Timer');

goog.require('box2d.b2CircleShape');
goog.require('box2d.b2EdgeShape');
goog.require('box2d.b2ChainShape');
goog.require('box2d.b2PolygonShape');

goog.require('box2d.b2BroadPhase');
goog.require('box2d.b2Distance');
goog.require('box2d.b2DynamicTree');
goog.require('box2d.b2TimeOfImpact');

goog.require('box2d.b2Body');
goog.require('box2d.b2Fixture');
goog.require('box2d.b2WorldCallbacks');
goog.require('box2d.b2TimeStep');
goog.require('box2d.b2World');

goog.require('box2d.b2Contact');

goog.require('box2d.b2AreaJoint');
goog.require('box2d.b2DistanceJoint');
goog.require('box2d.b2FrictionJoint');
goog.require('box2d.b2GearJoint');
goog.require('box2d.b2MotorJoint');
goog.require('box2d.b2MouseJoint');
goog.require('box2d.b2PrismaticJoint');
goog.require('box2d.b2PulleyJoint');
goog.require('box2d.b2RevoluteJoint');
goog.require('box2d.b2RopeJoint');
goog.require('box2d.b2WeldJoint');
goog.require('box2d.b2WheelJoint');

goog.require('box2d.b2Rope');

goog.require('box2d.b2BuoyancyController');
goog.require('box2d.b2ConstantAccelController');
goog.require('box2d.b2ConstantForceController');
goog.require('box2d.b2GravityController');
goog.require('box2d.b2TensorDampingController');


/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/**
* @class Phaser.Physics.Box2D
* @classdesc Physics World Constructor
* @constructor
* @param {Phaser.Game} game - Reference to the current game instance.
*/
Phaser.Physics.Box2D = function (game, config) {
    
    /**
    * @property {Phaser.Game} game - Local reference to game.
    */
    this.game = game;
    
    /**
    * @property {number} ptmRatio - Pixels to Meters ratio.
    * @default 50
    */
    this.ptmRatio = 50;
    
    /**
    * @property {box2d.b2World} world - The Box2D world in which the simulation is run.
    * @protected
    */
    this.world = new box2d.b2World(new box2d.b2Vec2(0, 0));

    /**
    * @property {Phaser.Physics.Box2D.DefaultDebugDraw} - used for rendering debug information
    * @default
    */
    this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.mpx(1));
    this.world.SetDebugDraw(this.debugDraw);

    /**
    * @property {Phaser.Physics.Box2D.DefaultContactListener} - used to check if bodies have contact callbacks set
    * @default
    */
    this.contactListener = new Phaser.Physics.Box2D.DefaultContactListener();
    this.world.SetContactListener(this.contactListener);

    /**
    * @property {number} nextBodyId - The id to give the next created body
    * @protected
    */
    this.nextBodyId = 0;

    /**
    * @property {number} nextFixtureId - The id to give the next created fixture
    * @protected
    */
    this.nextFixtureId = 0;

    /**
    * @property {box2d.b2Vec2} gravity - The gravity of the Box2D world.
    * @protected
    */
    this.gravity = new Phaser.Physics.Box2D.PointProxy(this, this.world, this.world.GetGravity, this.world.SetGravity);

    /**
    * @property {number} friction - The default friction for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc
    * @default
    */
    this.friction = 0.2;

    /**
    * @property {number} restitution - The default restitution for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc
    * @default
    */
    this.restitution = 0.0;

    /**
    * @property {number} density - The default density for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc
    * @default
    */
    this.density = 1.0;

    /**
    * @property {number} frameRate - The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.
    * @default
    */
    this.frameRate = 1 / 60;

    /**
    * @property {number} velocityIterations - The maximum number of iterations allowed to adjust velocities to match constraints. Defaults to 8.
    * @default
    */
    this.velocityIterations = 8;

    /**
    * @property {number} positionIterations - The maximum number of iterations allowed to adjust positions to match constraints. Defaults to 3.
    * @default
    */
    this.positionIterations = 3;

    /**
    * @property {boolean} useElapsedTime - If true the frameRate value will be ignored and instead Box2D will step with the value of Game.Time.physicsElapsed, which is a delta time value.
    * @default
    */
    this.useElapsedTime = false;

    /**
    * @property {boolean} paused - The paused state of the Box2D world.
    * @default
    */
    this.paused = false;

    /**
    * @property {box2d.b2ParticleSystem} particleSystem - The World Particle System. Enabled with World.createParticleSystem.
    */
    this.particleSystem = null;

    /**
    * @property {box2d.b2Body} mouseJointBody - A static body with no fixtures, used internally as the 'body A' for mouse joints when dragging dynamic bodies.
    * @default
    */
    var bd = new box2d.b2BodyDef();
    this.mouseJointBody = this.world.CreateBody(bd);

    /**
    * @property {box2d.b2MouseJoint} mouseJoint - The active mouse joint for dragging dynamic bodies.
    * @default
    */
    this.mouseJoint = null;

    //  Pixel to meter function overrides. 
    if (config.hasOwnProperty('mpx') && config.hasOwnProperty('pxm'))
    {
        this.mpx = config.mpx;
        this.pxm = config.pxm;
    }

    /**
    * @property {object} walls - An object containing the 4 wall bodies that bound the physics world.
    */
    this.walls = { left: null, right: null, top: null, bottom: null };

    /**
    * @property {Phaser.Signal} onBodyAdded - Dispatched when a new Body is added to the World.
    */
    this.onBodyAdded = new Phaser.Signal();

    /**
    * @property {Phaser.Signal} onBodyRemoved - Dispatched when a Body is removed from the World.
    */
    this.onBodyRemoved = new Phaser.Signal();

    /**
    * @property {array} _toRemove - Internal var used to hold references to bodies to remove from the world on the next step.
    * @private
    */
    this._toRemove = [];

};

// By default Box2D uses a 16bit value for collision filter category and mask. Most commonly,
// users will use categories starting from 1, 2, 4, 8 etc. The value 0x8000 sets the highest
// bit of a 16bit value and should cause the least interference with this method.
Phaser.Physics.Box2D.worldBoundsFilterCategory = 0x8000;

Phaser.Physics.Box2D.prototype = {

    /**
    * Returns the next id to use to keep body ids unique
    *
    * @method Phaser.Physics.Box2D#getNextBodyId
    * @return {number} The next unique id for a body to be created with.
    */
    getNextBodyId: function () {

        var id = this.nextBodyId;
        this.nextBodyId += 1;
        return id;

    },

    /**
    * Returns the next id to use to keep fixture ids unique
    *
    * @method Phaser.Physics.Box2D#getNextFixtureId
    * @return {number} The next unique id for a fixture to be created with.
    */
    getNextFixtureId: function () {

        var id = this.nextFixtureId;
        this.nextFixtureId += 1;
        return id;

    },

    /**
    * This will add a Box2D physics body into the removal list for the next step.
    *
    * @method Phaser.Physics.Box2D#removeBodyNextStep
    * @param {Phaser.Physics.Box2D.Body} body - The body to remove at the start of the next step.
    */
    removeBodyNextStep: function (body) {

        this._toRemove.push(body);

    },

    /**
    * Called at the start of the core update loop. Purges flagged bodies from the world.
    *
    * @method Phaser.Physics.Box2D#preUpdate
    */
    preUpdate: function () {

        var i = this._toRemove.length;

        while (i--)
        {
            this.removeBody(this._toRemove[i]);
        }

        this._toRemove.length = 0;

    },

    /**
    * This will create a Box2D physics body on the given game object or array of game objects.
    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
    * Note: When the game object is enabled for Box2D physics it has its anchor x/y set to 0.5 so it becomes centered.
    *
    * @method Phaser.Physics.Box2D#enable
    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.
    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.
    */
    enable: function (object, children) {

        if (typeof children === 'undefined') { children = true; }

        var i = 1;

        if (Array.isArray(object))
        {
            i = object.length;

            while (i--)
            {
                if (object[i] instanceof Phaser.Group)
                {
                    //  If it's a Group then we do it on the children regardless
                    this.enable(object[i].children, children);
                }
                else
                {
                    this.enableBody(object[i]);

                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0)
                    {
                        this.enable(object[i], true);
                    }
                }
            }
        }
        else
        {
            if (object instanceof Phaser.Group)
            {
                //  If it's a Group then we do it on the children regardless
                this.enable(object.children, children);
            }
            else
            {
                this.enableBody(object);

                if (children && object.hasOwnProperty('children') && object.children.length > 0)
                {
                    this.enable(object.children, true);
                }
            }
        }

    },

    /**
    * Creates a Box2D physics body on the given game object.
    * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
    *
    * @method Phaser.Physics.Box2D#enableBody
    * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.
    */
    enableBody: function (object) {

        if (object.hasOwnProperty('body') && object.body === null)
        {
            object.body = new Phaser.Physics.Box2D.Body(this.game, object, object.x, object.y, 2);
            object.anchor.set(0.5);
        }

    },

    /**
    * Sets the bounds of the Physics world to match the Game.World dimensions.
    * You can optionally set which 'walls' to create: left, right, top or bottom.
    *
    * @method Phaser.Physics#setBoundsToWorld
    * @param {boolean} [left=true] - If true will create the left bounds wall.
    * @param {boolean} [right=true] - If true will create the right bounds wall.
    * @param {boolean} [top=true] - If true will create the top bounds wall.
    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.
    * @param {number} [collisionCategory=1] - The category (bitmask) to use for the walls.
    * @param {number} [collisionMask=0xFFFFFFFF] - The mask (bitmask) to use for the walls.
    */
    setBoundsToWorld: function (left, right, top, bottom, collisionCategory, collisionMask) {

        if (typeof left === 'undefined') { left = true; }
        if (typeof right === 'undefined') { right = true; }
        if (typeof top === 'undefined') { top = true; }
        if (typeof bottom === 'undefined') { bottom = true; }
        if (typeof collisionCategory === 'undefined') { collisionCategory = 1; }
        if (typeof collisionMask === 'undefined') { collisionCategory = 0xFFFFFFFF; }
        
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, collisionCategory, collisionMask);

    },

    /**
    * Sets the bounds of the Physics world to match the given world pixel dimensions.
    * You can optionally set which 'walls' to create: left, right, top or bottom.
    *
    * @method Phaser.Physics.Box2D#setBounds
    * @param {number} x - The x coordinate of the top-left corner of the bounds.
    * @param {number} y - The y coordinate of the top-left corner of the bounds.
    * @param {number} width - The width of the bounds.
    * @param {number} height - The height of the bounds.
    * @param {boolean} [left=true] - If true will create the left bounds wall.
    * @param {boolean} [right=true] - If true will create the right bounds wall.
    * @param {boolean} [top=true] - If true will create the top bounds wall.
    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.
    * @param {number} [collisionCategory=1] - The category (bitmask) to use for the walls.
    * @param {number} [collisionMask=0xFFFFFFFF] - The mask (bitmask) to use for the walls.
    */
    setBounds: function (x, y, width, height, left, right, top, bottom, collisionCategory, collisionMask) {

        if (typeof left === 'undefined') { left = true; }
        if (typeof right === 'undefined') { right = true; }
        if (typeof top === 'undefined') { top = true; }
        if (typeof bottom === 'undefined') { bottom = true; }
        if (typeof collisionCategory === 'undefined') { collisionCategory = 1; }
        if (typeof collisionMask === 'undefined') { collisionMask = 0xFFFFFFFF; }

        if (this.walls.left)
        {
            this.removeBody(this.walls.left);
        }

        if (this.walls.right)
        {
            this.removeBody(this.walls.right);
        }

        if (this.walls.top)
        {
            this.removeBody(this.walls.top);
        }

        if (this.walls.bottom)
        {
            this.removeBody(this.walls.bottom);
        }
        
        // Prepare shape and fixture definitions for use below
        var polygonShape = new box2d.b2PolygonShape();

        var fixtureDef = new box2d.b2FixtureDef();
        fixtureDef.shape = polygonShape;

        fixtureDef.filter.categoryBits = Phaser.Physics.Box2D.worldBoundsFilterCategory;
        fixtureDef.filter.maskBits = 0xFFFF;

        // We could also use edge shapes, but polygons will make sure that if anything
        // should somehow get outside the bounds, it will be brought back (provided it
        // didn't get all the way outside the polygon wall as well of course)
        var boundThickness = this.pxm(100);
        
        var bounds = this.game.world.bounds;

        if (left)
        {
            this.walls.left = this.createBody(0, 0, 0);
            
            polygonShape.SetAsOrientedBox(boundThickness, this.pxm(bounds.height) + boundThickness, new box2d.b2Vec2(boundThickness, 0), 0);
            
            var f = this.walls.left.data.CreateFixture(fixtureDef);
            f.id = this.getNextFixtureId();
        }

        if (right)
        {
            this.walls.right = this.createBody(0, 0, 0);
            
            polygonShape.SetAsOrientedBox(boundThickness, this.pxm(bounds.height) + boundThickness, new box2d.b2Vec2(this.pxm(-bounds.width) - boundThickness, 0), 0);
            
            var f = this.walls.right.data.CreateFixture(fixtureDef);
            f.id = this.getNextFixtureId();
        }

        if (top)
        {
            this.walls.top = this.createBody(0, 0, 0);

            polygonShape.SetAsOrientedBox(this.pxm(bounds.width) + boundThickness, boundThickness, new box2d.b2Vec2(0, boundThickness), 0);
    
            var f = this.walls.top.data.CreateFixture(fixtureDef);
            f.id = this.getNextFixtureId();
        }

        if (bottom)
        {
            this.walls.bottom = this.createBody(0, 0, 0);

            polygonShape.SetAsOrientedBox(this.pxm(bounds.width) + boundThickness, boundThickness, new box2d.b2Vec2(0, this.pxm(-bounds.height) - boundThickness), 0);
    
            var f = this.walls.bottom.data.CreateFixture(fixtureDef);
            f.id = this.getNextFixtureId();
        }

    },

    /**
    * Pauses the Box2D world independent of the game pause state.
    *
    * @method Phaser.Physics.Box2D#pause
    */
    pause: function() {

        this.paused = true;

    },
    
    /**
    * Resumes a paused Box2D world.
    *
    * @method Phaser.Physics.Box2D#resume
    */
    resume: function() {

        this.paused = false;

    },

    /**
    * Internal Box2D update loop.
    *
    * @method Phaser.Physics.Box2D#update
    */
    update: function () {

        // Do nothing when the physics engine was paused before
        if (this.paused)
        {
            return;
        }
        
        if (this.useElapsedTime)
        {
            this.world.Step(this.game.time.physicsElapsed, this.velocityIterations, this.positionIterations);
        }
        else
        {
            this.world.Step(this.frameRate, this.velocityIterations, this.positionIterations);
        }

    },

    /**
    * Clears all bodies from the simulation, resets callbacks.
    *
    * @method Phaser.Physics.Box2D#reset
    */
    reset: function () {

        this.clear();

    },

    /**
    * Clears all bodies from the simulation, resets callbacks.
    *
    * @method Phaser.Physics.Box2D#clear
    */
    clear: function () {

        var gravity = this.world.GetGravity().Clone();

        this.world = new box2d.b2World(gravity);
        this.world.SetDebugDraw(this.debugDraw);
        this.world.SetContactListener(this.contactListener);
        this._toRemove = [];

    },

    /**
    * Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.
    *
    * @method Phaser.Physics.Box2D#destroy
    */
    destroy: function () {

        this.clear();

        this.gravity = null;
        this.world = null;

        this.game = null;

    },

    /**
    * Creates a new Body and adds it to the World.
    *
    * @method Phaser.Physics.Box2D#createBody
    * @param {number} [x=0] - The x coordinate of this Body.
    * @param {number} [y=0] - The y coordinate of this Body.
    * @param {number} [density=2] - The default density of this Body (0 = static, 1 = kinematic, 2 = dynamic, 3 = bullet).
    * @return {Phaser.Physics.P2.Body} The body
    */
    createBody: function (x, y, density) {

        var body = new Phaser.Physics.Box2D.Body(this.game, null, x, y, density, this);

        return body;

    },

    /**
    * Creates a new dynamic Body and adds a Circle fixture to it of the given size.
    *
    * @method Phaser.Physics.Box2D#createCircle
    * @param {number} [x=0] - The x coordinate of this Body.
    * @param {number} [y=0] - The y coordinate of this Body.
    * @param {number} [radius=32] - The radius of this circle in pixels.
    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
    * @return {Phaser.Physics.P2.Body} The body
    */
    createCircle: function (x, y, radius, offsetX, offsetY) {
    
        var body = this.createBody(x, y, 2);

        return body.setCircle(radius, offsetX, offsetY);

    },

    /**
    * Creates a new dynamic Body and adds a Rectangle fixture to it of the given dimensions.
    *
    * @method Phaser.Physics.Box2D#createRectangle
    * @param {number} [x=0] - The x coordinate of this Body.
    * @param {number} [y=0] - The y coordinate of this Body.
    * @param {number} [width=16] - The width of the rectangle in pixels.
    * @param {number} [height=16] - The height of the rectangle in pixels.
    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
    * @return {Phaser.Physics.P2.Body} The body
    */
    createRectangle: function (x, y, width, height, offsetX, offsetY, rotation) {
    
        var body = this.createBody(x, y, 2);

        return body.setRectangle(width, height, offsetX, offsetY, rotation);

    },

    /**
    * Creates a new dynamic Body and adds a Polygon fixture to it.
    *
    * @method Phaser.Physics.Box2D#createPolygon
    * @param {number} [x=0] - The x coordinate of this Body.
    * @param {number} [y=0] - The y coordinate of this Body.
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @return {Phaser.Physics.P2.Body} The body
    */
    createPolygon: function (x, y, vertices, firstIndex, count) {
    
        var body = this.createBody(x, y, 2);

        return body.setPolygon(vertices, firstIndex, count);

    },

    /**
    * Adds an already created Box2D Body to this Box2D world.
    *
    * @method Phaser.Physics.Box2D#addBody
    * @param {Phaser.Physics.Box2D.Body} body - The Body to add to the World. Must already exist and not be part of another Box2D world.
    * @return {boolean} True if the Body was added successfully, otherwise false.
    */
    addBody: function (body) {

        if (body.data.world)
        {
            return false;
        }
        else
        {
            body.data = this.world.CreateBody(body.bodyDef);
            body.data.world = this.world;
            body.data.parent = body;

            this.onBodyAdded.dispatch(body);

            return true;
        }

    },

    /**
    * Removes a body from the world. This will silently fail if the body wasn't part of the world to begin with.
    *
    * @method Phaser.Physics.Box2D#removeBody
    * @param {Phaser.Physics.Box2D.Body} body - The Body to remove from the World.
    * @return {Phaser.Physics.Box2D.Body} The Body that was removed.
    */
    removeBody: function (body) {

        if (body.data.world == this.world)
        {
            this.world.DestroyBody(body.data);

            this.onBodyRemoved.dispatch(body);
        }

        return body;

    },

    /**
    * Populates and returns an array with references to of all current Bodies in the world.
    *
    * @method Phaser.Physics.Box2D#getBodies
    * @return {array<Phaser.Physics.Box2D.Body>} An array containing all current Bodies in the world.
    */
    getBodies: function () {

        var output = [];
        
        for (var b = this.world.GetBodyList(); b; b = b.GetNext())
        {
            output.push(b);
        }

        return output;

    },

    /**
    * Checks the given object to see if it has a Box2D body and if so returns it.
    *
    * @method Phaser.Physics.Box2D#getBody
    * @param {object} object - The object to check for a box2d.b2Body on.
    * @return {box2d.b2Body} The Box2D body, or null if not found.
    */
    getBody: function (object) {

        if (object instanceof box2d.b2Body)
        {
            //  Native Box2D body
            return object;
        }
        else if (object instanceof Phaser.Physics.Box2D.Body)
        {
            //  Phaser Box2D Body
            return object.data;
        }
        else if (object['body'] && object['body'].type === Phaser.Physics.BOX2D)
        {
            //  Sprite, TileSprite, etc
            return object.body.data;
        }

        return null;

    },

    /**
    * Converts the current world into a JSON object.
    *
    * @method Phaser.Physics.Box2D#toJSON
    * @return {object} A JSON representation of the world.
    */
    toJSON: function () {

        return this.world.toJSON();

    },

    /**
    * Convert Box2D physics value (meters) to pixel scale.
    * By default we use a scale of 50px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @method Phaser.Physics.Box2D#mpx
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    mpx: function (v) {

        return v *= this.ptmRatio;

    },

    /**
    * Convert pixel value to Box2D physics scale (meters).
    * By default we use a scale of 50px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @method Phaser.Physics.Box2D#pxm
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    pxm: function (v) {

        return v / this.ptmRatio;

    },
    
    /**
    * Runs the standard 'debug draw' rendering. What actually gets drawn will depend
    * on the current status of the flags set in the debug draw object held by the b2World.
    * This could perhaps be made modifiable at runtime, but for now it is just rendering
    * shapes (see usage of b2Shapes flag below).
    *
    * @method Phaser.Physics.Box2D#renderDebugDraw
    * @param {object} context - The context to render to.
    */
    renderDebugDraw: function(context) {
        
        if (!this.game.physics.box2d) {
            return;
        }
        
        var world = this.game.physics.box2d;
        
        world.debugDraw.start(context);
    
        world.world.DrawDebugData();
        
        world.debugDraw.stop();
    },
    
    /**
    * Renders information about the body as text. This is intended to be used internally by Phaser.Utils.Debug.
    * To make use of this from your code you would call something like game.debug.bodyInfo(sprite, x, y)
    *
    * @method Phaser.Physics.Box2D#renderBodyInfo
    * @param {Phaser.Utils.Debug} debug - The Debug class to use.
    * @param {Phaser.Physics.Box2D} body - The Body to render the info of.
    */
    renderBodyInfo: function (debug, body) {
    
        debug.line('Position: x: ' + body.x.toFixed(3) + ' y: ' + body.y.toFixed(3));
        debug.line('Rotation: ' + body.rotation.toFixed(3) + ' degrees');
        debug.line('Velocity: x: ' + body.velocity.x.toFixed(3) + ' y: ' + body.velocity.y.toFixed(3));
        debug.line('Angular velocity: ' + body.angularVelocity.toFixed(3) + ' degrees/sec');
    
    },

    /**
    * Returns all fixtures found under the given point. Set the onlyOne parameter to true if you only
    * care about finding one fixture under the point.
    *
    * @method Phaser.Physics.Box2D#getFixturesAtPoint
    * @param {Phaser.Pointer} x - The x coordinate of the location to test for (pixel coordinates)
    * @param {Phaser.Pointer} y - The y coordinate of the location to test for (pixel coordinates)
    * @param {boolean} [onlyOne=false] - If true, this function will return after finding just one fixture.
    * @param {boolean} [onlyDynamic=false] - If true, only fixtures on dynamic bodies will be returned.
    * @return {Array} All fixtures found at the given point.
    */
    getFixturesAtPoint: function (x, y, onlyOne, onlyDynamic) {
        
        if (typeof onlyOne === 'undefined') { onlyOne = false; }
        if (typeof onlyDynamic === 'undefined') { onlyDynamic = false; }
        
        var worldx = this.pxm(-x);
        var worldy = this.pxm(-y);
        var worldPoint = new box2d.b2Vec2(worldx, worldy);
        
        // Make a small box.
        var aabb = new box2d.b2AABB();
        var d = new box2d.b2Vec2();

        d.SetXY(0.001, 0.001);

        box2d.b2SubVV(worldPoint, d, aabb.lowerBound);
        box2d.b2AddVV(worldPoint, d, aabb.upperBound);

        var hitFixtures = [];

        // Query the world for overlapping shapes.
        // Here we return true to keep checking, or false to quit.
        var callback = function (fixture)
        {
            if (onlyDynamic && fixture.GetBody().GetType() !== box2d.b2BodyType.b2_dynamicBody)
            {
                return true;
            }
         
            if (fixture.TestPoint(worldPoint))
            {
                hitFixtures.push(fixture);
                return !onlyOne;
            }
         
            return true;
        };

        this.world.QueryAABB(callback, aabb);
        
        return hitFixtures;

    },

    /**
    * Returns all bodies (Phaser.Physics.Box2D.Body) found under the given coordinates. Set the onlyOne
    * parameter to true if you only care about finding one body.
    *
    * @method Phaser.Physics.Box2D#getBodiesAtPoint
    * @param {number} x - The x coordinate of the location to test for (pixel coordinates)
    * @param {number} y - The y coordinate of the location to test for (pixel coordinates)
    * @param {boolean} [onlyOne=false] - If true, this function will return after finding just one body.
    * @param {boolean} [onlyDynamic=false] - If true, only dynamic bodies will be returned.
    * @return {Array} All bodies that have fixtures at the given point.
    */
    getBodiesAtPoint: function (x, y, onlyOne, onlyDynamic) {
        
        if (typeof onlyOne === 'undefined') { onlyOne = false; }
        if (typeof onlyDynamic === 'undefined') { onlyDynamic = false; }
        
        var fixtures = this.getFixturesAtPoint(x, y, onlyOne, onlyDynamic);
        
        if (fixtures.length < 1)
        {
            return fixtures;
        }
        
        var bodies = [];

        for (var i = 0; i < fixtures.length; i++)
        {
            bodies.push(fixtures[i].GetBody().parent);
        }
        
        // http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array/9229821
        bodies.filter(function(elem, pos) {
            return bodies.indexOf(elem) === pos;
        });
        
        return bodies;

    },    
    
    /**
    * If there is a dynamic body under the given point, a mouse joint will be created
    * to drag that body around. Use the mouseDragMove and mouseDragEnd functions to
    * continue the drag action. Any mouse drag already in progress will be canceled.
    *
    * @method Phaser.Physics.Box2D#mouseDragStart
    * @param {Phaser.Point} point - The location for the drag start (pixel coordinates)
    */
    mouseDragStart: function (point) {
        
        this.mouseDragEnd();
        
        var fixturesAtPoint = this.getFixturesAtPoint(point.x, point.y, true, true);
        
        if ( fixturesAtPoint.length < 1 ) {
            return;
        }
        
        var worldx = this.pxm(-point.x);
        var worldy = this.pxm(-point.y);
        var worldPoint = new box2d.b2Vec2(worldx, worldy);
        
        var jd = new box2d.b2MouseJointDef();
        jd.bodyA = this.mouseJointBody;
        jd.bodyB = fixturesAtPoint[0].GetBody();
        jd.target.Copy(worldPoint);
        jd.maxForce = 1000 * jd.bodyB.GetMass();
        this.mouseJoint = this.world.CreateJoint(jd);
        jd.bodyB.SetAwake(true);
    },
    
    /**
    * Updates the target location of the active mouse joint, if there is one. If there
    * is no mouse joint active, this does nothing.
    *
    * @method Phaser.Physics.Box2D#mouseDragMove
    * @param {Phaser.Point} point - The location for the drag move (pixel coordinates)
    */
    mouseDragMove: function (point) {

        if (!this.mouseJoint)
        {
            return;
        }
        
        var worldx = this.pxm(-point.x);
        var worldy = this.pxm(-point.y);
        var worldPoint = new box2d.b2Vec2(worldx, worldy);
    
        this.mouseJoint.SetTarget(worldPoint);
    
    },
    
    /**
    * Ends the active mouse joint if there is one. If there is no mouse joint active, does nothing.
    *
    * @method Phaser.Physics.Box2D#mouseDragEnd
    */
    mouseDragEnd: function () {

        if (this.mouseJoint)
        {
            this.world.DestroyJoint(this.mouseJoint);
            this.mouseJoint = null;
        }
    
    },
    
    /**
    * Creates a distance joint.
    *
    * @method Phaser.Physics.Box2D#distanceJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} length - target length of joint. If not given, the current position of the anchor points will be used to calculate the joint length.
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [frequency=0] - frequency of joint
    * @param {number} [damping=0] - damping of joint
    * @return {box2d.b2DistanceJoint} The created joint.
    */
    distanceJoint: function (bodyA, bodyB, length, ax, ay, bx, by, frequency, damping) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }        
        if ( typeof frequency === 'undefined' ) { frequency = 0; }
        if ( typeof damping === 'undefined' ) { damping = 0; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);        
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2DistanceJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        if (length === null || typeof length === 'undefined')
        {
            // Set length to current
            var worldAnchorA = new box2d.b2Vec2();
            var worldAnchorB = new box2d.b2Vec2();

            jd.bodyA.GetWorldPoint(jd.localAnchorA, worldAnchorA);
            jd.bodyB.GetWorldPoint(jd.localAnchorB, worldAnchorB);

            worldAnchorA.SelfSub(worldAnchorB);
            length = worldAnchorA.Length();
        }
        else
        {
            length = this.pxm(length);
        }
        
        jd.length = length;
        jd.frequencyHz = frequency;
        jd.dampingRatio = damping;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a rope joint.
    *
    * @method Phaser.Physics.Box2D#ropeJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} length - target length of joint. If not given, the current position of the anchor points will be used to calculate the joint length.
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @return {box2d.b2RopeJoint} The created joint.
    */
    ropeJoint: function (bodyA, bodyB, length, ax, ay, bx, by) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);        
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2RopeJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        if (length === null || typeof length === 'undefined')
        {
            // Set length to current
            var worldAnchorA = new box2d.b2Vec2();
            var worldAnchorB = new box2d.b2Vec2();

            jd.bodyA.GetWorldPoint(jd.localAnchorA, worldAnchorA);
            jd.bodyB.GetWorldPoint(jd.localAnchorB, worldAnchorB);

            worldAnchorA.SelfSub(worldAnchorB);
            length = worldAnchorA.Length();
        }
        else
        {
            length = this.pxm(length);
        }
        
        jd.maxLength = length;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a revolute joint.
    *
    * @method Phaser.Physics.Box2D#revoluteJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [motorSpeed=0] - target speed (degrees/second), measured as the angle of bodyB relative to bodyA, counter-clockwise being positive
    * @param {number} [motorTorque=0] - maximum torque the joint motor can exert to maintain the target speed
    * @param {boolean} [motorEnabled=false] - Is the motor enabled or not?
    * @param {number} [lowerLimit=0] - the lower limit angle (degrees), measured as the angle of bodyB relative to bodyA
    * @param {number} [upperLimit=0] - the upper limit angle (degrees), measured as the angle of bodyB relative to bodyA
    * @param {boolean} [limitEnabled=false] - Is the limit enabled?
    * @return {box2d.b2RevoluteJoint} The created joint.
    */
    revoluteJoint: function (bodyA, bodyB, ax, ay, bx, by, motorSpeed, motorTorque, motorEnabled, lowerLimit, upperLimit, limitEnabled) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }
        if ( typeof motorTorque === 'undefined' ) { motorTorque = 0; }
        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }
        if ( typeof lowerLimit === 'undefined' ) { lowerLimit = 0; }
        if ( typeof upperLimit === 'undefined' ) { upperLimit = 0; }
        if ( typeof limitEnabled === 'undefined' ) { limitEnabled = false; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);        
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2RevoluteJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        jd.motorSpeed = Phaser.Math.degToRad(-motorSpeed);
        jd.maxMotorTorque = motorTorque;
        jd.enableMotor = motorEnabled;
        jd.lowerAngle = Phaser.Math.degToRad(lowerLimit);
        jd.upperAngle = Phaser.Math.degToRad(upperLimit);
        jd.enableLimit = limitEnabled;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a prismatic joint.
    *
    * @method Phaser.Physics.Box2D#prismaticJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [axisX=1] - the x component of the joint axis
    * @param {number} [axisY=0] - the y component of the joint axis
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [motorSpeed=0] - target speed (pixels/second), measured along the joint axis
    * @param {number} [motorForce=0] - maximum torque the joint motor can exert to maintain the target speed
    * @param {boolean} [motorEnabled=false] -Is the motor enabled?
    * @param {number} [lowerLimit=0] - the lower limit angle (pixels), measured along the joint axis
    * @param {number} [upperLimit=0] - the upper limit angle (pixels), measured along the joint axis
    * @param {boolean} [limitEnabled=false] - Is the joint limit enabled?
    * @param {number} [offsetAngle=0] - angle (degrees) relative to bodyA, to which bodyB should be rotated, counter-clockwise being positive
    * @return {box2d.b2PrismaticJoint} The created joint.
    */
    prismaticJoint: function (bodyA, bodyB, axisX, axisY, ax, ay, bx, by, motorSpeed, motorForce, motorEnabled, lowerLimit, upperLimit, limitEnabled, offsetAngle) {
        
        if ( typeof axisX === 'undefined' ) { axisX = 1; }
        if ( typeof axisY === 'undefined' ) { axisY = 0; }
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }
        if ( typeof motorForce === 'undefined' ) { motorForce = 0; }
        if ( typeof lowerLimit === 'undefined' ) { lowerLimit = 0; }
        if ( typeof upperLimit === 'undefined' ) { upperLimit = 0; }
        if ( typeof limitEnabled === 'undefined' ) { limitEnabled = false; }
        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }
        if ( typeof offsetAngle === 'undefined' ) { offsetAngle = 0; }
        
        // Axis is only for direction, so don't need pxm conversion
        axisX *= -1;
        axisY *= -1;
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);
        
        // These are relative to axis, which has been converted already, so only do size change
        motorSpeed = this.pxm(motorSpeed);
        lowerLimit = this.pxm(lowerLimit);
        upperLimit = this.pxm(upperLimit);
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2PrismaticJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAxisA.SetXY( axisX, axisY );
        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        jd.motorSpeed = motorSpeed;
        jd.maxMotorForce = motorForce;
        jd.enableMotor = motorEnabled;
        jd.lowerTranslation = lowerLimit;
        jd.upperTranslation = upperLimit;
        jd.enableLimit = limitEnabled;
        jd.referenceAngle = Phaser.Math.degToRad(-offsetAngle);
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a friction joint.
    *
    * @method Phaser.Physics.Box2D#frictionJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [maxForce=0] - maximum force the joint can exert to maintain zero linear velocity between the two bodies
    * @param {number} [maxTorque=0] - maximum torque the joint can exert to maintain zero angular velocity between the two bodies
    * @return {box2d.b2FrictionJoint} The created joint.
    */
    frictionJoint: function (bodyA, bodyB, maxForce, maxTorque, ax, ay, bx, by) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof maxForce === 'undefined' ) { maxForce = 0; }
        if ( typeof maxTorque === 'undefined' ) { maxTorque = 0; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2FrictionJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        jd.maxForce = maxForce;
        jd.maxTorque = maxTorque;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a weld joint.
    *
    * @method Phaser.Physics.Box2D#weldJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [frequency=0] - frequency of joint
    * @param {number} [damping=0] - damping of joint
    * @return {box2d.b2WeldJoint} The created joint.
    */
    weldJoint: function (bodyA, bodyB, ax, ay, bx, by, frequency, damping) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof frequency === 'undefined' ) { frequency = 0; }
        if ( typeof damping === 'undefined' ) { damping = 0; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2WeldJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        jd.frequencyHz = frequency;
        jd.dampingRatio = damping;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a motor joint.
    *
    * @method Phaser.Physics.Box2D#motorJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [offsetX=0] - local x position in bodyA to which bodyB should be moved
    * @param {number} [offsetY=0] - local y position in bodyA to which bodyB should be moved
    * @param {number} [offsetAngle=0] - angle (degrees) relative to bodyA, to which bodyB should be rotated
    * @param {number} [maxForce=0] - maximum force the joint can exert to move bodyB to the offset position
    * @param {number} [maxTorque=0] - maximum torque the joint can exert to rotate bodyB to the offset angle
    * @param {number} [correctionFactor=1] - how quickly the joint should attempt to correct the position of bodyB
    * @return {box2d.b2MotorJoint} The created joint.
    */
    motorJoint: function (bodyA, bodyB, maxForce, maxTorque, correctionFactor, offsetX, offsetY, offsetAngle) {
        
        if ( typeof offsetX === 'undefined' ) { offsetX = 0; }
        if ( typeof offsetY === 'undefined' ) { offsetY = 0; }
        if ( typeof offsetAngle === 'undefined' ) { offsetAngle = 0; }
        if ( typeof maxForce === 'undefined' ) { maxForce = 0; }
        if ( typeof maxTorque === 'undefined' ) { maxTorque = 0; }
        if ( typeof correctionFactor === 'undefined' ) { correctionFactor = 1; }
        
        offsetX = this.pxm(-offsetX);
        offsetY = this.pxm(-offsetY);
        
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2MotorJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;
        jd.linearOffset.SetXY( offsetX, offsetY );
        
        jd.maxForce = maxForce;
        jd.maxTorque = maxTorque;
        jd.angularOffset = Phaser.Math.degToRad(-offsetAngle);
        jd.correctionFactor = correctionFactor;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a wheel joint.
    *
    * @method Phaser.Physics.Box2D#wheelJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [axisX=0] - the x component of the joint axis
    * @param {number} [axisY=1] - the y component of the joint axis
    * @param {number} [frequency=0] - frequency of joint
    * @param {number} [damping=0] - damping of joint
    * @param {number} [motorSpeed=0] - target speed (degrees/second), measured as the angle of bodyB relative to bodyA, counter-clockwise being positive.
    * @param {number} [motorTorque=0] - maximum torque the joint motor can exert to maintain the target speed
    * @param {boolean} [motorEnabled=false] - Is the motor enabled?
    * @return {box2d.b2WheelJoint} The created joint.
    */
    wheelJoint: function (bodyA, bodyB, ax, ay, bx, by, axisX, axisY, frequency, damping, motorSpeed, motorTorque, motorEnabled) {
        
        if ( typeof axisX === 'undefined' ) { axisX = 0; }
        if ( typeof axisY === 'undefined' ) { axisY = 1; }
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }
        if ( typeof motorTorque === 'undefined' ) { motorTorque = 0; }
        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }
        if ( typeof frequency === 'undefined' ) { frequency = 0; }
        if ( typeof damping === 'undefined' ) { damping = 0; }
                
        // Axis is only for direction, so don't need pxm conversion
        axisX *= -1;
        axisY *= -1;
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);

        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2WheelJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAxisA.SetXY( axisX, axisY );
        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        
        jd.motorSpeed = Phaser.Math.degToRad(-motorSpeed);
        jd.maxMotorTorque = motorTorque;
        jd.enableMotor = motorEnabled;
        jd.frequencyHz = frequency;
        jd.dampingRatio = damping;

        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a pulley joint.
    *
    * @method Phaser.Physics.Box2D#pulleyJoint
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined
    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined
    * @param {number} [ax=0] - local x position of the anchor in bodyA
    * @param {number} [ay=0] - local y position of the anchor in bodyA
    * @param {number} [bx=0] - local x position of the anchor in bodyB
    * @param {number} [by=0] - local y position of the anchor in bodyB
    * @param {number} [gax=0] - world x position of the ground anchor of bodyA
    * @param {number} [gay=0] - world y position of the ground anchor of bodyA
    * @param {number} [gbx=0] - world x position of the ground anchor of bodyB
    * @param {number} [gby=0] - world y position of the ground anchor of bodyB
    * @param {number} [ratio=1] - the ratio of movement between the two sides of the pulley
    * @param {number} [lengthA=100] - the length of pulley between bodyA and the ground anchor A
    * @param {number} [lengthB=100] - the length of pulley between bodyB and the ground anchor B
    * @return {box2d.b2PulleyJoint} The created joint.
    */
    pulleyJoint: function (bodyA, bodyB, ax, ay, bx, by, gax, gay, gbx, gby, ratio, lengthA, lengthB) {
        
        if ( typeof ax === 'undefined' ) { ax = 0; }
        if ( typeof ay === 'undefined' ) { ay = 0; }
        if ( typeof bx === 'undefined' ) { bx = 0; }
        if ( typeof by === 'undefined' ) { by = 0; }
        if ( typeof gax === 'undefined' ) { gax = 0; }
        if ( typeof gay === 'undefined' ) { gay = 0; }
        if ( typeof gbx === 'undefined' ) { gbx = 0; }
        if ( typeof gby === 'undefined' ) { gby = 0; }
        if ( typeof ratio === 'undefined' ) { ratio = 1; }
        if ( typeof lengthA === 'undefined' ) { lengthA = 100; }
        if ( typeof lengthB === 'undefined' ) { lengthB = 100; }
        
        ax = this.pxm(-ax);
        ay = this.pxm(-ay);
        bx = this.pxm(-bx);
        by = this.pxm(-by);
        gax = this.pxm(-gax);
        gay = this.pxm(-gay);
        gbx = this.pxm(-gbx);
        gby = this.pxm(-gby);
        lengthA = this.pxm(lengthA);
        lengthB = this.pxm(lengthB);
                
        // Could be a sprite
        if (bodyA['body'])
        {
            bodyA = bodyA['body'];
        }

        if (bodyB['body'])
        {
            bodyB = bodyB['body'];
        }
        
        var jd = new box2d.b2PulleyJointDef();

        jd.bodyA = bodyA.data;
        jd.bodyB = bodyB.data;

        jd.localAnchorA.SetXY( ax, ay );
        jd.localAnchorB.SetXY( bx, by );
        jd.groundAnchorA.SetXY( gax, gay );
        jd.groundAnchorB.SetXY( gbx, gby );
        
        jd.lengthA = lengthA;
        jd.lengthB = lengthB;
        jd.ratio = ratio;
        
        return this.world.CreateJoint(jd);

    },
    
    /**
    * Creates a gear joint.
    *
    * @method Phaser.Physics.Box2D#gearJoint
    * @param {box2d.b2Joint} joint1 - first joint to be gear-joined
    * @param {box2d.b2Joint} joint2 - second joint to be gear-joined
    * @param {number} [ratio=1] - ratio for gearing
    * @return {box2d.b2PulleyJoint} The created joint.
    */
    gearJoint: function (joint1, joint2, ratio) {
        
        if ( typeof ratio === 'undefined' ) { ratio = 1; }
        
        var jd = new box2d.b2GearJointDef();
        jd.joint1 = joint1;
        jd.joint2 = joint2;
        jd.ratio = -ratio;

        jd.bodyA = joint1.GetBodyA();
        jd.bodyB = joint2.GetBodyB();
        
        return this.world.CreateJoint(jd);

    },

    /**
    * Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.
    *
    * @method Phaser.Physics.Box2D#clearTilemapLayerBodies
    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.
    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.
    */
    clearTilemapLayerBodies: function (map, layer) {

        layer = map.getLayer(layer);

        var i = map.layers[layer].bodies.length;

        while (i--)
        {
            map.layers[layer].bodies[i].destroy();
        }

        map.layers[layer].bodies.length = 0;

    },

    /**
    * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.
    * Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.
    * Every time you call this method it will destroy any previously created bodies and remove them from the world.
    * Therefore understand it's a very expensive operation and not to be done in a core game update loop.
    *
    * @method Phaser.Physics.Box2D#convertTilemap
    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.
    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.
    * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world, otherwise it's up to you to do so.
    * @param {boolean} [optimize=true] - If true adjacent colliding tiles will be combined into a single body to save processing. However it means you cannot perform specific Tile to Body collision responses.
    * @return {array} An array of the Phaser.Physics.Box2D.Body objects that were created.
    */
    convertTilemap: function (map, layer, addToWorld, optimize) {

        layer = map.getLayer(layer);

        if (typeof addToWorld === 'undefined') { addToWorld = true; }
        if (typeof optimize === 'undefined') { optimize = true; }

        //  If the bodies array is already populated we need to nuke it
        this.clearTilemapLayerBodies(map, layer);

        var width = 0;
        var sx = 0;
        var sy = 0;

        for (var y = 0, h = map.layers[layer].height; y < h; y++)
        {
            width = 0;

            for (var x = 0, w = map.layers[layer].width; x < w; x++)
            {
                var tile = map.layers[layer].data[y][x];

                if (tile && tile.index > -1 && tile.collides)
                {
                    if (optimize)
                    {
                        var right = map.getTileRight(layer, x, y);

                        if (width === 0)
                        {
                            sx = tile.x * tile.width;
                            sy = tile.y * tile.height;
                            width = tile.width;
                        }

                        if (right && right.collides)
                        {
                            width += tile.width;
                        }
                        else
                        {
                            var body = new Phaser.Physics.Box2D.Body(this.game, null, sx, sy, 0);

                            body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);

                            if (addToWorld)
                            {
                                this.addBody(body);
                            }

                            map.layers[layer].bodies.push(body);

                            width = 0;
                        }
                    }
                    else
                    {
                        var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);

                        body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);

                        if (addToWorld)
                        {
                            this.addBody(body);
                        }

                        map.layers[layer].bodies.push(body);
                    }
                }
            }
        }

        return map.layers[layer].bodies;

    },
    
    /**
    * Casts a ray and finds intersecting fixtures in the world.
    *
    * @method Phaser.Physics.Box2D#raycast
    * @param {number} x1 - x location of start point (pixels)
    * @param {number} y1 - y location of start point (pixels)
    * @param {number} x2 - x location of end point (pixels)
    * @param {number} y2 - y location of end point (pixels)
    * @param {boolean} [closestHitOnly=true] - set to true if you want only the closest hit
    * @param {function} [filterFunction=null] - a function to be called for each hit, to decide which should be ignored
    * @return {Array} array of hits, as objects with body, fixture, point and normal properties. Eg. [ {body,fixture,point:{x,y},normal:{x,y}}, {body,fixture,point:{x,y},normal:{x,y}} ]
    */
    raycast: function (x1, y1, x2, y2, closestHitOnly, filterFunction) {
        
        if ( typeof closestHitOnly === 'undefined' ) { closestHitOnly = true; }
        if ( typeof filterFunction === 'undefined' ) { filterFunction = null; }
        
        x1 = this.pxm(-x1);
        y1 = this.pxm(-y1);
        x2 = this.pxm(-x2);
        y2 = this.pxm(-y2);

        var point1 = new box2d.b2Vec2(x1, y1);
        var point2 = new box2d.b2Vec2(x2, y2);
        
        var output = [];
                
        var callback = new Phaser.Physics.Box2D.RayCastCallback(this, closestHitOnly, filterFunction);
        this.world.RayCast(callback, point1, point2);
        
        // Need to convert coordinates of hit points to pixels before returning
        for (var i = 0; i < callback.hits.length; i++ )
        {
            var hit = callback.hits[i];
            hit.point = { x: this.mpx(-hit.point.x), y: this.mpx(-hit.point.y) };
            hit.normal = { x: -hit.normal.x, y: -hit.normal.y };
            output.push(hit);
        }
        
        return output;

    },
    
    /**
    * Finds all fixtures with AABBs overlapping the given area. This does NOT mean
    * that the fixtures themselves are actually overlapping the given area.
    *
    * @method Phaser.Physics.Box2D#queryAABB
    * @param {number} x - x location of AABB corner (pixels)
    * @param {number} y - y location of AABB corner (pixels)
    * @param {number} width - AABB width (pixels)
    * @param {number} height - AABB width (pixels)
    * @return {Array} array of hits, as objects with body and fixture properties. Eg. [ {body,fixture}, {body,fixture} ]
    */
    queryAABB: function (x, y, width, height) {
                
        x = this.pxm(-x);
        y = this.pxm(-y);
        width = this.pxm(width);
        height = this.pxm(height);
        
        var aabb = new box2d.b2AABB();
        aabb.lowerBound.SetXY( x - width, y - height );
        aabb.upperBound.SetXY( x, y );
        
        var callback = new Phaser.Physics.Box2D.QueryCallback(this);
        this.world.QueryAABB(callback, aabb);
        
        return callback.hits;

    },
    
    /**
    * Finds all fixtures that overlap the given fixture.
    *
    * @method Phaser.Physics.Box2D#queryFixture
    * @param {box2d.b2Fixture} fixture - the fixture to test overlapping for
    * @return {Array} array of hits, as objects with body and fixture properties. Eg. [ {body,fixture}, {body,fixture} ]
    */
    queryFixture: function (fixture) {
                
        var callback = new Phaser.Physics.Box2D.QueryCallback(this);
        this.world.QueryShape(callback, fixture.GetShape(), fixture.GetBody().GetTransform());
        
        return callback.hits;

    },

    /**
     * If the PTM ratio is changed after creating the world, the debug draw scale needs to be updated.
     *
     * @method Phaser.Physics.Box2D#setPTMRatio
     * @param {number} newRatio - The new ratio to be used for the DebugDraw.
     */
    setPTMRatio: function (newRatio) {
        
        this.ptmRatio = newRatio;
        game.physics.box2d.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.ptmRatio);
        game.physics.box2d.world.SetDebugDraw( game.physics.box2d.debugDraw );
        
    }

};

/**
 * Raycast callback, can return either all hits or just the closest, and use a function to filter hits.
 * Intended for internal use by the 'raycast' function
 * @constructor
 * @extends {box2d.b2RayCastCallback}
 * @param {Phaser.Physics.Box2D} world
 * @param {boolean} closestHitOnly
 * @param {function} filterFunction
 */
Phaser.Physics.Box2D.RayCastCallback = function(world, closestHitOnly, filterFunction)
{
    this.world = world;
    this.closestHitOnly = closestHitOnly;
    this.filterFunction = filterFunction;    
    this.hits = [];
};

goog.inherits(Phaser.Physics.Box2D.RayCastCallback, box2d.b2RayCastCallback);

/**
 * Internally used callback function for raycasting. Checks each reported fixture as it is discovered,
 * to see which should be ignored and which should be used.
 * 
 * @param {box2d.b2Fixture} fixture 
 * @param {box2d.b2Vec2} point 
 * @param {box2d.b2Vec2} normal 
 * @param {number} fraction 
 * @return {number} 
 */
Phaser.Physics.Box2D.RayCastCallback.prototype.ReportFixture = function (fixture, point, normal, fraction)
{
    // If a filter function was given, use that to decide if this hit should be ignored
    if (this.filterFunction !== null )
    {
        var pxPoint = { x: this.world.mpx(-point.x), y: this.world.mpx(-point.y) };
        var pxNormal = { x: -normal.x, y: -normal.y };
        var body = fixture.GetBody().parent;

        if (!this.filterFunction.call(this, body, fixture, pxPoint, pxNormal))
        {
            return -1;
        }
    }
    
    // If we are looking for the closest hit, we will have returned 'fraction' from any previously
    // reported hits to clip the ray length, so we know this hit is closer than what we already had.
    if (this.closestHitOnly)
    {
        this.hits = [];
    }
    
    var hit = {};
    hit.body = fixture.GetBody().parent;
    hit.fixture = fixture;
    hit.point = { x: point.x, y: point.y };
    hit.normal = { x: normal.x, y: normal.y };
    this.hits.push(hit);
    
    if (this.closestHitOnly)
    {
        return fraction;
    }
    else
    {
        return 1;
    }

};

/**
 * Query callback, can use a function to filter hits.
 * Intended for internal use by the 'queryAABB' function
 * @constructor
 * @param {Phaser.Physics.Box2D} world
 * @extends {box2d.b2QueryCallback}
 */
Phaser.Physics.Box2D.QueryCallback = function(world)
{
    this.world = world;  
    this.hits = [];
};

goog.inherits(Phaser.Physics.Box2D.QueryCallback, box2d.b2QueryCallback);

/**
 * Internally used callback function for raycasting. Checks each reported fixture as it is discovered,
 * to see which should be ignored and which should be used.
 * 
 * @param {box2d.b2Fixture} fixture
 * @return {number} 
 */
Phaser.Physics.Box2D.QueryCallback.prototype.ReportFixture = function (fixture)
{    
    var hit = {};
    hit.body = fixture.GetBody().parent;
    hit.fixture = fixture;
    this.hits.push(hit);
    
    return true;
};

/**
* Renders the fixtures of the given body.
*
* @method Phaser.Physics.Box2D#renderBody
* @param {object} context - The context to render to.
* @param {Phaser.Physics.Box2D.Body} body - The Body to render.
* @param {string} [color='rgb(255,255,255)'] - color of the debug shape to be rendered. (format is css color string).
* @param {boolean} [filled=true] - Render the shape as a filled (default, true) or a stroked (false)
*/
Phaser.Physics.Box2D.renderBody = function(context, body, color, filled) {

    color = color || 'rgb(255,255,255)';

    if (typeof filled === 'undefined')
    {
        filled = true;
    }
    
    var world = body.game.physics.box2d;
    var b = body.data;    
    var xf = b.GetTransform();
    
    xf.p.x += -game.camera.x / world.ptmRatio; // *** added this
    xf.p.y -= -game.camera.y / world.ptmRatio; // *** added this
    
    world.debugDraw.start(context);
    
    world.debugDraw.PushTransform(xf);
    
    var rgbcolor = Phaser.Color.webToColor(color);
        
    var b2color = world.debugDraw.color;
    b2color.r = rgbcolor.r / 255;
    b2color.g = rgbcolor.g / 255;
    b2color.b = rgbcolor.b / 255;

    for (var f = b.GetFixtureList(); f; f = f.GetNext())
    {
        world.world.DrawShape(f, b2color);
    }

    world.debugDraw.PopTransform();
    
    world.debugDraw.stop();

};

/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/**
* The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.
* These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.
* In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.
* By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearFixtures to add extra shapes around the Body.
* Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.
* Note: When a game object is given a Box2D body it has its anchor x/y set to 0.5, so it becomes centered.
*
* @class Phaser.Physics.Box2D.Body
* @classdesc Physics Body Constructor
* @constructor
* @param {Phaser.Game} game - Game reference to the currently running game.
* @param {Phaser.Sprite} [sprite] - The Sprite object this physics body belongs to.
* @param {number} [x=0] - The x coordinate of this Body.
* @param {number} [y=0] - The y coordinate of this Body.
* @param {number} [density=2] - The default density of this Body (0 = static, 1 = kinematic, 2 = dynamic, 3 = bullet).
* @param {Phaser.Physics.Box2D} [world] - Reference to the Box2D World.
*/
Phaser.Physics.Box2D.Body = function (game, sprite, x, y, density, world) {

    if (typeof sprite === 'undefined') { sprite = null; }
    if (typeof x === 'undefined') { x = 0; }
    if (typeof y === 'undefined') { y = 0; }
    if (typeof density === 'undefined') { density = 2; }
    if (typeof world === 'undefined') { world = game.physics.box2d; }

    /**
    * @property {Phaser.Game} game - Local reference to game.
    */
    this.game = game;

    /**
    * @property {Phaser.Physics.Box2D} world - Local reference to the Box2D World.
    */
    this.world = world;

    /**
    * @property {number} id - a unique id for this body in the world
    */
    this.id = this.world.getNextBodyId();

    /**
    * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.
    */
    this.sprite = sprite;

    /**
    * @property {number} type - The type of physics system this body belongs to.
    */
    this.type = Phaser.Physics.BOX2D;

    /**
    * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.
    */
    this.offset = new Phaser.Point();

    /**
    * @property {box2d.b2BodyDef} bodyDef - The Box2D body definition
    * @protected
    */
    this.bodyDef = new box2d.b2BodyDef();

    this.bodyDef.position.SetXY(-this.world.pxm(x), -this.world.pxm(y));

    if (density === 0)
    {
        this.bodyDef.type = box2d.b2BodyType.b2_staticBody;
    }
    else if (density === 1)
    {
        this.bodyDef.type = box2d.b2BodyType.b2_kinematicBody;
    }
    else if (density === 2)
    {
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody;
    }
    else if (density === 3)
    {
        this.bodyDef.type = box2d.b2BodyType.b2_bulletBody;
    }

    /**
    * @property {box2d.b2Body} data - The Box2D body data.
    * @protected
    */
    this.data = this.world.world.CreateBody(this.bodyDef);
    this.data.world = this.world.world;
    this.data.parent = this;

    /**
    * @property {Phaser.Physics.Box2D.PointProxy} velocity - The velocity of the body. Set velocity.x to a negative value to move to the left, position to the right. velocity.y negative values move up, positive move down.
    */
    this.velocity = new Phaser.Physics.Box2D.PointProxy(this.world, this.data, this.data.GetLinearVelocity, this.data.SetLinearVelocity);

    /**
    * @property {boolean} removeNextStep - To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.
    */
    this.removeNextStep = false;

    /**
    * @property {object} _fixtureContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with a specific fixture.
    * @private
    */
    this._fixtureContactCallbacks = {};

    /**
    * @property {object} _fixtureContactCallbackContext - Array of fixture contact callback contexts.
    * @private
    */
    this._fixtureContactCallbackContext = {};

    /**
    * @property {object} _bodyContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with a specific body.
    * @private
    */
    this._bodyContactCallbacks = {};

    /**
    * @property {object} _bodyContactCallbackContext - Array of body contact callback contexts.
    * @private
    */
    this._bodyContactCallbackContext = {};

    /**
    * @property {object} _categoryContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with fixtures matching a specific mask.
    * @private
    */
    this._categoryContactCallbacks = {};

    /**
    * @property {object} _categoryContactCallbackContext - Array of category contact callback contexts.
    * @private
    */
    this._categoryContactCallbackContext = {};

    /**
    * @property {object} _fixtureCallbacks - Array of presolve callbacks, triggered while this body continues contact with a specific fixture.
    * @private
    */
    this._fixturePresolveCallbacks = {};

    /**
    * @property {object} _fixtureCallbackContext - Array of fixture presolve callback contexts.
    * @private
    */
    this._fixturePresolveCallbackContext = {};

    /**
    * @property {object} _bodyCallbacks - Array of presolve callbacks, triggered while this body continues contact with a specific body.
    * @private
    */
    this._bodyPresolveCallbacks = {};

    /**
    * @property {object} _bodyCallbackContext - Array of body presolve callback contexts.
    * @private
    */
    this._bodyPresolveCallbackContext = {};

    /**
    * @property {object} _categoryCallbacks - Array of presolve callbacks, triggered while this body continues contact with fixtures matching a specific mask.
    * @private
    */
    this._categoryPresolveCallbacks = {};

    /**
    * @property {object} _categoryCallbackContext - Array of category presolve callback contexts.
    * @private
    */
    this._categoryPresolveCallbackContext = {};

    /**
    * @property {object} _fixturePostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific fixture.
    * @private
    */
    this._fixturePostsolveCallbacks = {};

    /**
    * @property {object} _fixturePostsolveCallbackContext - Array of fixture postsolve callback contexts.
    * @private
    */
    this._fixturePostsolveCallbackContext = {};

    /**
    * @property {object} _bodyPostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific body.
    * @private
    */
    this._bodyPostsolveCallbacks = {};

    /**
    * @property {object} _bodyPostsolveCallbackContext - Array of body postsolve callback contexts.
    * @private
    */
    this._bodyPostsolveCallbackContext = {};

    /**
    * @property {object} _categoryPostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific fixture.
    * @private
    */
    this._categoryPostsolveCallbacks = {};

    /**
    * @property {object} _categoryPostsolveCallbackContext - Array of category postsolve callback contexts.
    * @private
    */
    this._categoryPostsolveCallbackContext = {};
    
    //  Set-up the default shape
    if (sprite)
    {
        this.setRectangleFromSprite(sprite);
    }

};

Phaser.Physics.Box2D.Body.prototype = {

    /**
    * Sets a callback to be fired any time a fixture in this Body begins or ends contact with a fixture in the given Body. 
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setBodyContactCallback
    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setBodyContactCallback: function (object, callback, callbackContext) {

        var id = -1;

        if (object['id'])
        {
            id = object.id;
        }
        else if (object['body'])
        {
            id = object.body.id;
        }

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._bodyContactCallbacks[id]);
                delete (this._bodyContactCallbackContext[id]);
            }
            else
            {
                this._bodyContactCallbacks[id] = callback;
                this._bodyContactCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired any time the given fixture begins or ends contact something
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setFixtureContactCallback
    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setFixtureContactCallback: function (fixture, callback, callbackContext) {

        var id = fixture.id;

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._fixtureContactCallbacks[id]);
                delete (this._fixtureContactCallbackContext[id]);
            }
            else
            {
                this._fixtureContactCallbacks[id] = callback;
                this._fixtureContactCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired any time a fixture in this body begins contact with a fixture in another body that matches given category set.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setCategoryContactCallback
    * @param {number} category - A bitmask specifying the category(s) to trigger for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setCategoryContactCallback: function (category, callback, callbackContext) {

        if (callback === null)
        {
            delete (this._categoryContactCallbacks[category]);
            delete (this._categoryContactCallbacksContext[category]);
        }
        else
        {
            this._categoryContactCallbacks[category] = callback;
            this._categoryContactCallbackContext[category] = callbackContext;
        }

    },
    
    /**
    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body and a fixture in the given Body.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setBodyPresolveCallback
    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setBodyPresolveCallback: function (object, callback, callbackContext) {

        var id = -1;

        if (object['id'])
        {
            id = object.id;
        }
        else if (object['body'])
        {
            id = object.body.id;
        }

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._bodyPresolveCallbacks[id]);
                delete (this._bodyPresolveCallbackContext[id]);
            }
            else
            {
                this._bodyPresolveCallbacks[id] = callback;
                this._bodyPresolveCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body the given fixture.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setFixturePresolveCallback
    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setFixturePresolveCallback: function (fixture, callback, callbackContext) {

        var id = fixture.id;

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._fixturePresolveCallbacks[id]);
                delete (this._fixturePresolveCallbackContext[id]);
            }
            else
            {
                this._fixturePresolveCallbacks[id] = callback;
                this._fixturePresolveCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body and a fixture in another body that matches given category set.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setCategoryPresolveCallback
    * @param {number} category - A bitmask specifying the category(s) to trigger for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setCategoryPresolveCallback: function (category, callback, callbackContext) {

        if (callback === null)
        {
            delete (this._categoryPresolveCallbacks[category]);
            delete (this._categoryPresolveCallbacksContext[category]);
        }
        else
        {
            this._categoryPresolveCallbacks[category] = callback;
            this._categoryPresolveCallbackContext[category] = callbackContext;
        }

    },
    
    /**
    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body and a fixture in the given Body.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setBodyPostsolveCallback
    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setBodyPostsolveCallback: function (object, callback, callbackContext) {

        var id = -1;

        if (object['id'])
        {
            id = object.id;
        }
        else if (object['body'])
        {
            id = object.body.id;
        }

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._bodyPostsolveCallbacks[id]);
                delete (this._bodyPostsolveCallbackContext[id]);
            }
            else
            {
                this._bodyPostsolveCallbacks[id] = callback;
                this._bodyPostsolveCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body the given fixture.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setFixturePostsolveCallback
    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setFixturePostsolveCallback: function (fixture, callback, callbackContext) {

        var id = fixture.id;

        if (id > -1)
        {
            if (callback === null)
            {
                delete (this._fixturePostsolveCallbacks[id]);
                delete (this._fixturePostsolveCallbackContext[id]);
            }
            else
            {
                this._fixturePostsolveCallbacks[id] = callback;
                this._fixturePostsolveCallbackContext[id] = callbackContext;
            }
        }

    },

    /**
    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body and a fixture in another body that matches given category set.
    * The callback will be sent 6 parameters:
    *     this body
    *     the body that was contacted
    *     the fixture in this body (box2d.b2Fixture)
    *     the fixture in the other body that was contacted (box2d.b2Fixture)
    *     a boolean to say whether it was a begin or end event
    *     the contact object itself (box2d.b2Contact)
    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
    *
    * @method Phaser.Physics.Box2D.Body#setCategoryPostsolveCallback
    * @param {number} category - A bitmask specifying the category(s) to trigger for.
    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.
    * @param {object} callbackContext - The context under which the callback will fire.
    */
    setCategoryPostsolveCallback: function (category, callback, callbackContext) {

        if (callback === null)
        {
            delete (this._categoryPostsolveCallbacks[category]);
            delete (this._categoryPostsolveCallbacksContext[category]);
        }
        else
        {
            this._categoryPostsolveCallbacks[category] = callback;
            this._categoryPostsolveCallbackContext[category] = callbackContext;
        }

    },

    /**
    * Sets the given collision category for all fixtures in this Body, unless a specific fixture is given.
    *
    * @method Phaser.Physics.Box2D.Body#setCollisionCategory
    * @param {number} category - A bitmask representing the category(s) to include
    * @param {box2d.b2Fixture} [fixture] - An optional fixture. If not provided the collision category will be added to all fixtures in this body.
    */
    setCollisionCategory: function (category, fixture) {

        if (typeof shape === 'undefined')
        {
            for (var f = this.data.GetFixtureList(); f; f = f.GetNext())
            {
                var filter = f.GetFilterData();
                filter.categoryBits = category;
            }
        }
        else
        {
            var filter = fixture.GetFilterData();
            filter.categoryBits = category;
        }

    },

    /**
    * Sets the given collision mask for all fixtures in this Body, unless a specific fixture is given.
    *
    * @method Phaser.Physics.Box2D.Body#setCollisionMask
    * @param {number} mask - A bitmask representing the category(s) to include
    * @param {box2d.b2Fixture} [fixture] - An optional fixture. If not provided the collision mask will be added to all fixtures in this body.
    */
    setCollisionMask: function (mask, fixture) {

        if (typeof shape === 'undefined')
        {
            for (var f = this.data.GetFixtureList(); f; f = f.GetNext())
            {
                var filter = f.GetFilterData();
                filter.maskBits = mask;
            }
        }
        else
        {
            var filter = fixture.GetFilterData();
            filter.maskBits = mask;
        }

    },

    /**
    * Apply force at the center of mass. This will not cause any rotation.
    *
    * @method Phaser.Physics.Box2D.Body#applyForce
    * @param {number} x - 
    * @param {number} y - 
    */
    applyForce: function (x, y) {

        this.data.ApplyForce(new box2d.b2Vec2(-x,-y), this.data.GetWorldCenter(), true);

    },

    /**
    * If this Body is dynamic then this will zero its angular velocity.
    *
    * @method Phaser.Physics.Box2D.Body#setZeroRotation
    */
    setZeroRotation: function () {

        this.data.SetAngularVelocity(0);

    },

    /**
    * If this Body is dynamic then this will zero its velocity on both axis.
    *
    * @method Phaser.Physics.Box2D.Body#setZeroVelocity
    */
    setZeroVelocity: function () {

        this.data.SetLinearVelocity(box2d.b2Vec2.ZERO);

    },

    /**
    * Sets the linear damping and angular damping to zero.
    *
    * @method Phaser.Physics.Box2D.Body#setZeroDamping
    */
    setZeroDamping: function () {

        this.data.SetLinearDamping(0);
        this.data.SetAngularDamping(0);

    },

    /**
    * Transform a world point to local body frame.
    *
    * @method Phaser.Physics.Box2D.Body#toLocalPoint
    * @param {box2d.b2Vec2} out - The point to store the result in.
    * @param {box2d.b2Vec2} worldPoint - The input world point.
    */
    toLocalPoint: function (out, worldPoint) {
    
        out.x = this.world.pxm(-worldPoint.x);
        out.y = this.world.pxm(-worldPoint.y);
        this.data.GetLocalPoint(out, out);        
        out.x = this.world.mpx(-out.x);
        out.y = this.world.mpx(-out.y);
        
        return out;

    },

    /**
    * Transform a local point to world frame.
    *
    * @method Phaser.Physics.Box2D.Body#toWorldPoint
    * @param {box2d.b2Vec2} out - The point to store the result in.
    * @param {box2d.b2Vec2} localPoint - The input local point.
    */
    toWorldPoint: function (out, localPoint) {

        out.x = this.world.pxm(-localPoint.x);
        out.y = this.world.pxm(-localPoint.y);
        this.data.GetWorldPoint(out, out);        
        out.x = this.world.mpx(-out.x);
        out.y = this.world.mpx(-out.y);

        return out;
    },

    /**
    * Transform a world vector to local body frame.
    *
    * @method Phaser.Physics.Box2D.Body#toLocalVector
    * @param {box2d.b2Vec2} out - The vector to store the result in.
    * @param {box2d.b2Vec2} worldVector - The input world vector.
    */
    toLocalVector: function (out, worldVector) {

        out.x = this.world.pxm(-worldVector.x);
        out.y = this.world.pxm(-worldVector.y);
        this.data.GetLocalVector(out, out);        
        out.x = this.world.mpx(-out.x);
        out.y = this.world.mpx(-out.y);
        
        return out;

    },

    /**
    * Transform a local vector to world frame.
    *
    * @method Phaser.Physics.Box2D.Body#toWorldVector
    * @param {box2d.b2Vec2} out - The vector to store the result in.
    * @param {box2d.b2Vec2} localVector - The input local vector.
    */
    toWorldVector: function (out, localVector) {

        out.x = this.world.pxm(-localVector.x);
        out.y = this.world.pxm(-localVector.y);
        this.data.GetWorldVector(out, out);        
        out.x = this.world.mpx(-out.x);
        out.y = this.world.mpx(-out.y);

    },

    /**
    * This will rotate the Body by the given speed to the left (counter-clockwise).
    *
    * @method Phaser.Physics.Box2D.Body#rotateLeft
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateLeft: function (speed) {

        this.data.SetAngularVelocity(this.world.pxm(-speed));

    },

    /**
    * This will rotate the Body by the given speed to the left (clockwise).
    *
    * @method Phaser.Physics.Box2D.Body#rotateRight
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateRight: function (speed) {

        this.data.SetAngularVelocity(this.world.pxm(speed));

    },

    /**
    * Moves the Body forwards based on its current angle and the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveForward
    * @param {number} speed - The speed at which body should move forwards.
    */
    moveForward: function (speed) {

        var magnitude = this.world.pxm(speed);
        var direction = new box2d.b2Vec2();
        this.toWorldVector(direction, {x:0,y:magnitude});
        this.data.SetLinearVelocity(direction);
        
    },

    /**
    * Moves the Body backwards based on its current angle and the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveBackward
    * @param {number} speed - The speed at which body should move backwards.
    */
    moveBackward: function (speed) {

        var magnitude = this.world.pxm(-speed);
        var direction = new box2d.b2Vec2();
        this.toWorldVector(direction, {x:0,y:magnitude});
        this.data.SetLinearVelocity(direction);

    },

    /**
    * Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.
    *
    * @method Phaser.Physics.Box2D.Body#thrust
    * @param {number} power - The magnitude of the thrust force.
    */
    thrust: function (power) {
    
        // Magnitude should be multiplied by the mass of the body, so that user  
        // will see the same results regardless of the size of the sprite.
        var magnitude = this.world.pxm(power) * this.data.GetMass();
        
        var force = new box2d.b2Vec2();
        this.toWorldVector(force, {x:0,y:magnitude});
        
        this.data.ApplyForce( force, this.data.GetWorldCenter(), true );

    },

    /**
    * Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.
    *
    * @method Phaser.Physics.Box2D.Body#reverse
    * @param {number} power - The magnitude of the thrust force.
    */
    reverse: function (power) {
    
        // Magnitude should be multiplied by the mass of the body, so that user  
        // will see the same results regardless of the size of the sprite.
        var magnitude = -this.world.pxm(power) * this.data.GetMass();
        
        var force = new box2d.b2Vec2();
        this.toWorldVector(force, {x:0,y:magnitude});
        
        this.data.ApplyForce( force, this.data.GetWorldCenter(), true );

    },

    /**
    * If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveLeft
    * @param {number} speed - The speed at which it should move to the left, in pixels per second.
    */
    moveLeft: function (speed) {

        this.velocity.x = -speed;

    },

    /**
    * If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveRight
    * @param {number} speed - The speed at which it should move to the right, in pixels per second.
    */
    moveRight: function (speed) {

        this.velocity.x = speed;

    },

    /**
    * If this Body is dynamic then this will move it up by setting its y velocity to the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveUp
    * @param {number} speed - The speed at which it should move up, in pixels per second.
    */
    moveUp: function (speed) {

        this.velocity.y = -speed;

    },

    /**
    * If this Body is dynamic then this will move it down by setting its y velocity to the given speed.
    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.
    *
    * @method Phaser.Physics.Box2D.Body#moveDown
    * @param {number} speed - The speed at which it should move down, in pixels per second.
    */
    moveDown: function (speed) {

        this.velocity.y = speed;

    },

    /**
    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
    *
    * @method Phaser.Physics.Box2D.Body#preUpdate
    * @protected
    */
    preUpdate: function () {

        if (this.removeNextStep)
        {
            this.removeFromWorld();
            this.removeNextStep = false;
        }

    },

    /**
    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
    *
    * @method Phaser.Physics.Box2D.Body#postUpdate
    * @protected
    */
    postUpdate: function () {

        if (this.sprite)
        {
            this.sprite.x = this.world.mpx(-this.data.GetPosition().x);
            this.sprite.y = this.world.mpx(-this.data.GetPosition().y);
            this.sprite.rotation = this.data.GetAngle();
        }

    },

    /**
    * Sets this body as inactive. It will not participate in collisions or
    * any other aspect of the physics simulation. Intended for use by Phaser.Sprite.kill()
    *
    * @method Phaser.Physics.Box2D.Body#kill
    */
    kill: function () {

        this.data.SetActive(false);

    },

    /**
    * Restores the active status of this body.
    *
    * @method Phaser.Physics.Box2D.Body#reset
    * @param {number} x - The new x position of the Body.
    * @param {number} y - The new x position of the Body.
    */
    reset: function (x, y) {

        this.data.SetPositionXY( this.world.pxm(-x), this.world.pxm(-y) );
        this.data.SetActive(true);

    },

    /**
    * Removes this physics body from the world.
    *
    * @method Phaser.Physics.Box2D.Body#removeFromWorld
    */
    removeFromWorld: function () {

        if (this.data.world === this.game.physics.box2d.world)
        {
            this.game.physics.box2d.removeBodyNextStep(this);
        }

    },

    /**
    * Destroys this Body and all references it holds to other objects.
    *
    * @method Phaser.Physics.Box2D.Body#destroy
    */
    destroy: function () {

        this.removeFromWorld();

        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._categoryCallbacks = {};
        this._categoryCallbackContext = {};

        this.sprite = null;

    },

    /**
    * Removes all fixtures from this Body.
    *
    * @method Phaser.Physics.Box2D.Body#clearFixtures
    */
    clearFixtures: function () {

        var fixtures = [];
        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {
            fixtures.push(f);
        }

        var i = fixtures.length;

        while (i--)
        {
            this.data.DestroyFixture(fixtures[i]);
        }

    },

    /**
    * Adds a Circle fixture to this Body. You can control the offset from the center of the body and the rotation.
    * It will use the World friction, restitution and density by default.
    *
    * @method Phaser.Physics.Box2D.Body#addCircle
    * @param {number} radius - The radius of this circle (in pixels)
    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    addCircle: function (radius, offsetX, offsetY) {

        var circleShape = new box2d.b2CircleShape(this.world.pxm(radius));
        circleShape.m_p.SetXY(this.world.pxm(-offsetX), this.world.pxm(-offsetY));

        var fixtureDef = new box2d.b2FixtureDef();
        fixtureDef.shape = circleShape;
        fixtureDef.friction = this.world.friction;
        fixtureDef.restitution = this.world.restitution;
        fixtureDef.density = this.world.density;

        var f = this.data.CreateFixture(fixtureDef);
        f.id = this.world.getNextFixtureId();

        return f;

    },

    /**
    * Adds a Rectangle fixture to this Body. You can control the offset from the center of the body and the rotation.
    * It will use the World friction, restitution and density by default.
    *
    * @method Phaser.Physics.Box2D.Body#addRectangle
    * @param {number} [width=16] - The width of the rectangle in pixels.
    * @param {number} [height=16] - The height of the rectangle in pixels.
    * @param {number} [offsetX=0] - Local horizontal offset (pixels) of the shape relative to the body center.
    * @param {number} [offsetY=0] - Local vertical offset (pixels) of the shape relative to the body center.
    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    addRectangle: function (width, height, offsetX, offsetY, rotation) {

        if (typeof width === 'undefined') { width = 16; }
        if (typeof height === 'undefined') { height = 16; }
        if (typeof offsetX === 'undefined') { offsetX = 0; }
        if (typeof offsetY === 'undefined') { offsetY = 0; }
        if (typeof rotation === 'undefined') { rotation = 0; }   
    
        width = this.world.pxm(width);
        height = this.world.pxm(height);

        var polygonShape = new box2d.b2PolygonShape();
        polygonShape.SetAsOrientedBox(0.5 * width, 0.5 * height, new box2d.b2Vec2(this.world.pxm(-offsetX), this.world.pxm(-offsetY)), rotation);

        var fixtureDef = new box2d.b2FixtureDef();
        fixtureDef.shape = polygonShape;
        fixtureDef.friction = this.world.friction;
        fixtureDef.restitution = this.world.restitution;
        fixtureDef.density = this.world.density;

        var f = this.data.CreateFixture(fixtureDef);
        f.id = this.world.getNextFixtureId();

        return f;

    },

    /**
    * Creates a new Edge Shape and adds it to this Body.
    * It will use the World friction, restitution and density by default.
    *
    * @method Phaser.Physics.Box2D.Body#addEdge
    * @param {number} [x1=0] - Local horizontal offset of the first point relative to the body center.
    * @param {number} [y1=0] - Local vertical offset of the first point relative to the body center.
    * @param {number} [x2=0] - Local horizontal offset of the second point relative to the body center.
    * @param {number} [y2=0] - Local vertical offset of the second point relative to the body center.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    addEdge: function (x1, y1, x2, y2) {

        var edgeShape = new box2d.b2EdgeShape();
        edgeShape.Set( new box2d.b2Vec2(this.world.pxm(-x1), this.world.pxm(-y1)), new box2d.b2Vec2(this.world.pxm(-x2), this.world.pxm(-y2)) );

        var fixtureDef = new box2d.b2FixtureDef();
        fixtureDef.shape = edgeShape;
        fixtureDef.friction = this.world.friction;
        fixtureDef.restitution = this.world.restitution;
        fixtureDef.density = this.world.density;

        var f = this.data.CreateFixture(fixtureDef);
        f.id = this.world.getNextFixtureId();

        return f;

    },

    /**
    * Creates a new chain shape and adds it to this Body.
    * It will use the World friction, restitution and density by default.
    *
    * @method Phaser.Physics.Box2D.Body#addChain
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} [count] - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @param {boolean} [loop=false] - Whether the chain should form a closed loop.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    addChain: function (vertices, firstIndex, count, loop) {
    
        if (typeof vertices === 'undefined') { return null; }
        if (vertices.length < 4) { return null; }
    
        if (typeof firstIndex === 'undefined') { firstIndex = 0; }
        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }

        var b2Vertices = [];
        for (var i = firstIndex; i < (firstIndex+count); i++) {
            b2Vertices.push( new box2d.b2Vec2(this.world.pxm(-vertices[2*i]), this.world.pxm(-vertices[2*i+1])) );
        }

        var chainShape = new box2d.b2ChainShape();
        if (loop) {
            chainShape.CreateLoop( b2Vertices, b2Vertices.length );
        }
        else {
            chainShape.CreateChain( b2Vertices, b2Vertices.length );
        }

        var fixtureDef = new box2d.b2FixtureDef();
        fixtureDef.shape = chainShape;
        fixtureDef.friction = this.world.friction;
        fixtureDef.restitution = this.world.restitution;
        fixtureDef.density = this.world.density;

        var f = this.data.CreateFixture(fixtureDef);
        f.id = this.world.getNextFixtureId();
        return f;

    },

    /**
    * Creates a new loop shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#addLoop
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    addLoop: function (vertices, firstIndex, count) {
        
        return this.addChain(vertices, firstIndex, count, true);
        
    },

    /**
    * Creates a new polygon shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#addPolygon
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @return {box2d.b2Fixture} The last fixture that was added to the Body.
    */
    addPolygon: function (vertices, firstIndex, count) {
    
        if (typeof vertices === 'undefined') { return null; }
        if (vertices.length < 6) { return null; } // need at least three vertices
    
        if (typeof firstIndex === 'undefined') { firstIndex = 0; }
        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }

        var b2Vertices = [];
        for (var i = firstIndex; i < (firstIndex+count); i++) {
            b2Vertices.push( { x: this.world.pxm(-vertices[2*i]), y: this.world.pxm(-vertices[2*i+1]) } );
        }
        
        var poly = new Phaser.Physics.Box2D.Polygon();
        poly.setFromXYObjects(b2Vertices);
        var convexPolygons = poly.decompose(b2Vertices);
        
        var lastFixture = null;
        
        for (var i = 0; i < convexPolygons.length; i++)
        {
            var polygonShape = new box2d.b2PolygonShape();
            polygonShape.Set( convexPolygons[i], convexPolygons[i].length );
    
            var fixtureDef = new box2d.b2FixtureDef();
            fixtureDef.shape = polygonShape;
            fixtureDef.friction = this.world.friction;
            fixtureDef.restitution = this.world.restitution;
            fixtureDef.density = this.world.density;
    
            lastFixture = this.data.CreateFixture(fixtureDef);
            lastFixture.id = this.world.getNextFixtureId();
        }

        return lastFixture;
    },

    /**
    * Remove a shape from the body. Will automatically update the mass properties and bounding radius.
    *
    * @method Phaser.Physics.Box2D.Body#removeFixture
    * @param {box2d.b2Fixture} fixture - The fixture to remove from the body.
    * @return {boolean} True if the fixture was found and removed, else false.
    */
    removeFixture: function (fixture) {

        if ( fixture.GetBody() != this.data ) {
            return false;
        }
    
        this.data.DestroyFixture(fixture);

        return true;
    },

    /**
    * Clears any previously set fixtures. Then creates a new Circle shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#setCircle
    * @param {number} [radius=32] - The radius of this circle in pixels.
    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setCircle: function (radius, offsetX, offsetY) {
    
        if (typeof radius === 'undefined') { radius = 32; }
        if (typeof offsetX === 'undefined') { offsetX = 0; }
        if (typeof offsetY === 'undefined') { offsetY = 0; }
    
        this.clearFixtures();

        return this.addCircle(radius, offsetX, offsetY);

    },

    /**
    * Clears any previously set fixtures. The creates a new Rectangle fixture at the given size and offset, and adds it to this Body.
    * If you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.
    *
    * @method Phaser.Physics.Box2D.Body#setRectangle
    * @param {number} [width=16] - The width of the rectangle in pixels.
    * @param {number} [height=16] - The height of the rectangle in pixels.
    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setRectangle: function (width, height, offsetX, offsetY, rotation) {

        this.clearFixtures();

        return this.addRectangle(width, height, offsetX, offsetY, rotation);

    },

    /**
    * Clears any previously set fixtures.
    * Then creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.
    * If no Sprite is given it defaults to using the parent of this Body.
    *
    * @method Phaser.Physics.Box2D.Body#setRectangleFromSprite
    * @param {Phaser.Sprite|Phaser.Image} [sprite] - The Sprite on which the Rectangle will get its dimensions.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setRectangleFromSprite: function (sprite) {

        if (typeof sprite === 'undefined') { sprite = this.sprite; }

        this.clearFixtures();

        return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);

    },

    /**
    * Clears any previously set fixtures. Then creates a new edge shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#setEdge
    * @param {number} [x1=0] - Local horizontal offset of the first point relative to the body center.
    * @param {number} [y1=0] - Local vertical offset of the first point relative to the body center.
    * @param {number} [x2=0] - Local horizontal offset of the second point relative to the body center.
    * @param {number} [y2=0] - Local vertical offset of the second point relative to the body center.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setEdge: function (x1, y1, x2, y2) {
    
        if (typeof x1 === 'undefined') { x1 = 0; }
        if (typeof y1 === 'undefined') { y1 = 0; }
        if (typeof x2 === 'undefined') { x2 = 0; }
        if (typeof y2 === 'undefined') { y2 = 0; }
    
        this.clearFixtures();        

        return this.addEdge(x1, y1, x2, y2);

    },

    /**
    * Clears any previously set fixtures. Then creates a new chain shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#setChain
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @param {boolean} [loop=false] - Whether the chain should form a closed loop.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setChain: function (vertices, firstIndex, count, loop) {
    
        if (typeof vertices === 'undefined') { return null; }
        if (vertices.length < 4) { return null; }
    
        if (typeof firstIndex === 'undefined') { firstIndex = 0; }
        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }
    
        this.clearFixtures();

        return this.addChain(vertices, firstIndex, count, loop);

    },

    /**
    * An alias for setChain.
    *
    * @method Phaser.Physics.Box2D.Body#setLoop
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setLoop: function (vertices, firstIndex, count) {
        
        return this.setChain(vertices, firstIndex, count, true);
        
    },

    /**
    * Clears any previously set fixtures. Then creates a new polygon shape and adds it to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#setPolygon
    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]
    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.
    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.
    * @return {box2d.b2Fixture} The fixture that was added to the Body.
    */
    setPolygon: function (vertices, firstIndex, count) {
    
        if (typeof vertices === 'undefined') { return null; }
        if (vertices.length < 4) { return null; }
    
        if (typeof firstIndex === 'undefined') { firstIndex = 0; }
        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }
    
        this.clearFixtures();

        return this.addPolygon(vertices, firstIndex, count);

    },

    /**
    * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.
    *
    * @method Phaser.Physics.Box2D.Body#loadPolygon
    * @param {string} key - The key of the Physics Data file as stored in Game.Cache.
    * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.
    * @return {boolean} True on success, else false.
    */
    loadPolygon: function (key, object, sprite) {

        if (typeof sprite === 'undefined') { sprite = null; }
    
        var data = this.game.cache.getPhysicsData(key, object);

        for (var i = 0; i < data.length; i++)
        {
            var vertices = [];

            for (var s = 0; s < data[i].shape.length; s += 2)
            {
                vertices.push( new box2d.b2Vec2( this.world.pxm(-data[i].shape[s]), this.world.pxm(-data[i].shape[s + 1]) ) );
            }

            if (sprite) {
                var offsetx = this.world.pxm(-0.5 * sprite.width);
                var offsety = this.world.pxm(-0.5 * sprite.height);
                for (var k = 0; k < vertices.length; k++) {
                    vertices[k].x -= offsetx;
                    vertices[k].y -= offsety;
                }
            }

            var polygonShape = new box2d.b2PolygonShape();
            polygonShape.Set(vertices, vertices.length);
    
            var fixtureDef = new box2d.b2FixtureDef();
            fixtureDef.shape = polygonShape;
            fixtureDef.friction = data[i].friction;
            fixtureDef.restitution = data[i].bounce;
            fixtureDef.density = data[i].density;
            fixtureDef.filter.categoryBits = data[i].filter.categoryBits;
            fixtureDef.filter.maskBits = data[i].filter.maskBits;

            var f = this.data.CreateFixture(fixtureDef);
            f.id = this.world.getNextFixtureId();
        }

        return true;

    },

    /**
    * Checks if the given point (pixel coords) is contained by any of the fixtures on this body.
    * Not efficient for checking a large number of bodies to find which is under the mouse. (Use
    * Phaser.Physics.Box2D.getBodiesAtPoint for that.)
    *
    * @method Phaser.Physics.Box2D.Body#containsPoint
    * @param {Phaser.Pointer} point - The location to test for (pixel coordinates)
    * @return {boolean} True on success, else false.
    */
    containsPoint: function (point) {
        
        var worldx = this.world.pxm(-point.x);
        var worldy = this.world.pxm(-point.y);
        var worldPoint = new box2d.b2Vec2(worldx, worldy);
        
        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())
        {
            if (f.TestPoint(worldPoint))
            {
                return true;
            }
        }
        
        return false;

    }

};

Phaser.Physics.Box2D.Body.prototype.constructor = Phaser.Physics.Box2D.Body;

/**
* @name Phaser.Physics.Box2D.Body#static
* @property {boolean} static - Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "static", {

    get: function () {

        return (this.data.GetType() === box2d.b2BodyType.b2_staticBody);

    },

    set: function (value) {

        if (value && this.data.GetType() !== box2d.b2BodyType.b2_staticBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_staticBody);
        }
        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_staticBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_dynamicBody);
        }

    }

});

/**
* @name Phaser.Physics.Box2D.Body#dynamic
* @property {boolean} dynamic - Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "dynamic", {

    get: function () {

        return (this.data.GetType() === box2d.b2BodyType.b2_dynamicBody);

    },

    set: function (value) {

        if (value && this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_dynamicBody);
        }
        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_dynamicBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_staticBody);
        }

    }

});

/**
* @name Phaser.Physics.Box2D.Body#kinematic
* @property {boolean} kinematic - Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "kinematic", {

    get: function () {

        return (this.data.GetType() === box2d.b2BodyType.b2_kinematicBody);

    },

    set: function (value) {

        if (value && this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_kinematicBody);
        }
        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_kinematicBody)
        {
            this.data.SetType(box2d.b2BodyType.b2_staticBody);
        }

    }

});


/**
* The angle of the Body in degrees from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement Body.angle = 450 is the same as Body.angle = 90.
* If you wish to work in radians instead of degrees use the property Body.rotation instead. Working in radians is faster as it doesn't have to convert values.
*
* @name Phaser.Physics.Box2D.Body#angle
* @property {number} angle - The angle of this Body in degrees.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angle", {

    get: function() {

        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.GetAngle()));

    },

    set: function(value) {

        this.data.SetAngle( Phaser.Math.degToRad(Phaser.Math.wrapAngle(value)) );

    }

});

/**
* Linear damping acts like drag to cause a body to slow down.
* @name Phaser.Physics.Box2D.Body#linearDamping
* @property {number} linearDamping - The linear damping acting acting on the body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "linearDamping", {

    get: function () {

        return this.data.GetLinearDamping();

    },

    set: function (value) {

        this.data.SetLinearDamping(value);

    }

});

/**
* Linear damping acts like drag to cause rotation of a body to slow down.
* @name Phaser.Physics.Box2D.Body#angularDamping
* @property {number} angularDamping - The angular damping acting acting on the body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularDamping", {

    get: function () {

        return this.data.GetAngularDamping();

    },

    set: function (value) {

        this.data.SetAngularDamping(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#angularVelocity
* @property {number} angularVelocity - The angular velocity of the body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularVelocity", {

    get: function () {

        return this.data.GetAngularVelocity();

    },

    set: function (value) {

        this.data.SetAngularVelocity(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#fixedRotation
* @property {boolean} fixedRotation - If true, the body will not rotate.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "fixedRotation", {

    get: function () {

        return this.data.IsFixedRotation();

    },

    set: function (value) {

        this.data.SetFixedRotation(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#gravityScale
* @property {boolean} gravityScale - Set to zero to completely ignore gravity, or negative values to reverse gravity for this body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "gravityScale", {

    get: function () {

        return this.data.GetGravityScale();

    },

    set: function (value) {

        this.data.SetGravityScale(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#friction
* @property {number} friction - When setting, all fixtures on the body will be set to the given friction. When getting, the friction of the first fixture will be returned, or zero if no fixtures are present.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "friction", {

    get: function () {

        var fixture = this.data.GetFixtureList();
        
        if (fixture) {
            return fixture.GetFriction();
        }

        return 0;

    },

    set: function (value) {

        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {

            f.SetFriction(value);
            f.Refilter();

        }

    }

});

/**
* @name Phaser.Physics.Box2D.Body#restitution
* @property {number} restitution - When setting, all fixtures on the body will be set to the given restitution. When getting, the restitution of the first fixture will be returned, or zero if no fixtures are present.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "restitution", {

    get: function () {

        var fixture = this.data.GetFixtureList();
        
        if (fixture) {
            return fixture.GetRestitution();
        }

        return 0;

    },

    set: function (value) {

        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {

            f.SetRestitution(value);
            f.Refilter();

        }

    }

});

/**
* @name Phaser.Physics.Box2D.Body#sensor
* @property {boolean} sensor - When setting, all fixtures on the body will be set to the given sensor status. When getting, the sensor status of the first fixture will be returned, or false if no fixtures are present.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "sensor", {

    get: function () {

        var fixture = this.data.GetFixtureList();
        
        if (fixture) {
            return fixture.IsSensor();
        }

        return 0;

    },

    set: function (value) {

        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {

            f.SetSensor(value);
            f.Refilter();

        }

    }

});

/**
* @name Phaser.Physics.Box2D.Body#bullet
* @property {boolean} bullet - Set to true to give the body 'bullet' status, and use continous collision detection when moving it.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "bullet", {

    get: function () {

        return this.data.IsBullet();

    },

    set: function (value) {

        this.data.SetBullet(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#mass
* @property {number} mass - the new mass for the body. Setting this to zero will cause the body to become a static body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "mass", {

    get: function () {

        return this.data.GetMass();

    },

    set: function (value) {
        
        if (value === 0) {
            this.data.SetType(box2d.b2BodyType.b2_staticBody);
        }
        else {
            
            // Make sure the body is dynamic, before giving it a non-zero mass.
            if (this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody) {
                
                this.data.SetType(box2d.b2BodyType.b2_dynamicBody);
                
            }
        
            // Mass is determined by (area * density) of attached fixtures.
            // We need to find the current mass and scale the density of all
            // fixtures so that the overall mass matches the desired mass.
            
            var oldMass = this.data.GetMass();
            var scaleby = value / oldMass;
    
            for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {
                var oldDensity = f.GetDensity();
                f.SetDensity(oldDensity * scaleby);
            }
            
            // Make sure the new fixture densities take effect in the body
            this.data.ResetMassData();
        
        }

    }

});

/**
* The angle of the Body in radians.
* If you wish to work in degrees instead of radians use the Body.angle property instead. Working in radians is faster as it doesn't have to convert values.
*
* @name Phaser.Physics.Box2D.Body#rotation
* @property {number} rotation - The angle of this Body in radians.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "rotation", {

    get: function() {

        return this.data.GetAngle();

    },

    set: function(value) {

        this.data.SetAngle(value);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#x
* @property {number} x - The x coordinate of this Body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "x", {

    get: function () {

        return this.world.mpx(-this.data.GetPosition().x);

    },

    set: function (value) {

        this.data.SetPositionXY(this.world.pxm(-value), this.data.GetPosition().y);

    }

});

/**
* @name Phaser.Physics.Box2D.Body#y
* @property {number} y - The y coordinate of this Body.
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "y", {

    get: function () {

        return this.world.mpx(-this.data.GetPosition().y);

    },

    set: function (value) {

        this.data.SetPositionXY(this.data.GetPosition().x, this.world.pxm(-value));

    }

});

/**
* A Body can be set to collide against the World bounds automatically if this is set to true. Otherwise it will leave the World.
* Note that this only applies if your World has bounds! When getting this property, the returned value will be true if any of the
* fixtures of this body are set to collide with the world bounds.
*
* @name Phaser.Physics.Box2D.Body#collideWorldBounds
* @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?
*/
Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "collideWorldBounds", {

    get: function () {

        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())
        {
            var filter = f.GetFilterData();

            if (filter.maskBits & Phaser.Physics.Box2D.worldBoundsFilterCategory)
            {
                return true;
            }
        }
        
        return false;

    },

    set: function (value) {

        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())
        {
            var filter = f.GetFilterData();

            if (value)
            {
                filter.maskBits |=  Phaser.Physics.Box2D.worldBoundsFilterCategory;
            }
            else
            {
                filter.maskBits &= ~Phaser.Physics.Box2D.worldBoundsFilterCategory;
            }
        }
    }

});

/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/**
* A PointProxy is an internal class that allows for direct getter/setter style property access to box2d.b2Vec2 objects but inverses the values on set.
* The value of the vector is not stored in this class. Instead, it holds a reference to the object that actually stores the value, along with the functions used to get and set from that object.
*
* @xclass Phaser.Physics.Box2D.PointProxy
* @classdesc PointProxy
* @constructor
* @param {Phaser.Physics.Box2D} world - A reference to the Box2D world, used for pixel/meter conversions.
* @param {any} object - The object to bind to, which holds the actual value.
* @param {function} gettor - The function of the bound object which gets the value from it.
* @param {function} settor - The function of the bound object which sets the value in it.
*/
Phaser.Physics.Box2D.PointProxy = function (world, object, gettor, settor) {

    this.world = world;
    this.object = object;
    this.gettor = gettor;
    this.settor = settor;

};

Phaser.Physics.Box2D.PointProxy.prototype.constructor = Phaser.Physics.Box2D.PointProxy;

/**
* @name Phaser.Physics.Box2D.PointProxy#x
* @property {number} x - The x property of this PointProxy.
*/
Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "x", {

    get: function () {

        return this.world.mpx(-this.gettor.call(this.object).x);

    },

    set: function (value) {
        
        var v = this.gettor.call(this.object);
        v.x = this.world.pxm(-value);
        this.settor.call(this.object, v);

    }

});

/**
* @name Phaser.Physics.Box2D.PointProxy#y
* @property {number} y - The y property of this PointProxy.
*/
Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "y", {

    get: function () {

        return this.world.mpx(-this.gettor.call(this.object).y);

    },

    set: function (value) {

        var v = this.gettor.call(this.object);
        v.y = this.world.pxm(-value);
        this.settor.call(this.object, v);

    }

});

/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

/** 
 * This class implements debug drawing callbacks
 * @constructor
 * @param {number} pixelsPerMeter
 */
Phaser.Physics.Box2D.DefaultDebugDraw = function (pixelsPerMeter)
{
    this.context = null;
    this.pixelsPerMeter = pixelsPerMeter;
    this.flags = box2d.b2DrawFlags.e_shapeBit;
};

Phaser.Physics.Box2D.DefaultDebugDraw.prototype.color = new box2d.b2Color(1, 1, 1);

/**
 * Sets which aspects of the world to render
 *
 * @export 
 * @return {void}
 * @param {number} flags - a bitflag made from one or more of the following:
 *     box2d.b2DrawFlags = { e_none, e_shapeBit, e_jointBit, e_aabbBit, e_pairBit, e_centerOfMassBit, e_all }
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.SetFlags = function (flags)
{
    this.flags = flags;
};

/**
 * Gets which aspects of the world are currently set to be rendered
 *
 * @export 
 * @return {number} - the flags currently set
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.GetFlags = function ()
{
    return this.flags;
};

/**
 * Sets the canvas context to use in subsequent rendering and applies overall transform.
 *
 * @export 
 * @return {void} 
 * @param {CanvasRenderingContext2D} context
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.start = function (context)
{
    this.context = context;
    this.context.save();
    this.context.scale(-1, -1);
    this.context.scale(this.pixelsPerMeter, this.pixelsPerMeter);
};

/**
 * Resets transform state to original
 *
 * @export 
 * @return {void} 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.stop = function ()
{
    this.context.restore();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PushTransform = function (xf)
{
    var ctx = this.context;
    ctx.save();
    ctx.translate(xf.p.x, xf.p.y);
    ctx.rotate(xf.q.GetAngleRadians());
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PopTransform = function ()
{
    var ctx = this.context;
    ctx.restore();
};

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
{
    if (!vertexCount)
    {
        return;
    }

    var ctx = this.context;
    
    ctx.lineWidth = 1 / this.pixelsPerMeter;

    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);

    for (var i = 1; i < vertexCount; i++)
    {
        ctx.lineTo(vertices[i].x, vertices[i].y);
    }

    ctx.closePath();
    ctx.strokeStyle = color.MakeStyleString(1);
    ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
{
    if (!vertexCount)
    {
        return;
    }

    var ctx = this.context;
    
    ctx.lineWidth = 1 / this.pixelsPerMeter;

    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);

    for (var i = 1; i < vertexCount; i++)
    {
        ctx.lineTo(vertices[i].x, vertices[i].y);
    }

    ctx.closePath();
    ctx.fillStyle = color.MakeStyleString(0.5);
    ctx.fill();
    ctx.strokeStyle = color.MakeStyleString(1);
    ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawCircle = function (center, radius, color)
{
    if (!radius)
    {
        return;
    }

    var ctx = this.context;

    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2, true);
    ctx.strokeStyle = color.MakeStyleString(1);
    ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Vec2} axis 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
{
    if (!radius)
    {
        return;
    }

    var ctx = this.context;
    
    ctx.lineWidth = 1 / this.pixelsPerMeter;

    var cx = center.x;
    var cy = center.y;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);
    ctx.moveTo(cx, cy);
    ctx.lineTo((cx + axis.x * radius), (cy + axis.y * radius));
    ctx.fillStyle = color.MakeStyleString(0.5);
    ctx.fill();
    ctx.strokeStyle = color.MakeStyleString(1);
    ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p1 
 * @param {box2d.b2Vec2} p2 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSegment = function (p1, p2, color)
{
    var ctx = this.context;
    
    ctx.lineWidth = 1 / this.pixelsPerMeter;

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = color.MakeStyleString(1);
    ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawTransform = function (xf)
{
    var ctx = this.context;
    
    ctx.lineWidth = 1 / this.pixelsPerMeter;

    this.PushTransform(xf);

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(1, 0);
    ctx.strokeStyle = box2d.b2Color.RED.MakeStyleString(1);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, 1);
    ctx.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1);
    ctx.stroke();

    this.PopTransform(xf);
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p 
 * @param {number} size 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPoint = function (p, size, color)
{
    var ctx = this.context;

    ctx.fillStyle = color.MakeStyleString();
    //size /= this.m_settings.viewZoom;
    //size /= this.m_settings.canvasScale;
    var hsize = size / 2;
    ctx.fillRect(p.x - hsize, p.y - hsize, size, size);
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Color} color 
 */
Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawAABB = function (aabb, color)
{
    var ctx = this.context;

    ctx.strokeStyle = color.MakeStyleString();
    var x = aabb.lowerBound.x;
    var y = aabb.lowerBound.y;
    var w = aabb.upperBound.x - aabb.lowerBound.x;
    var h = aabb.upperBound.y - aabb.lowerBound.y;
    ctx.strokeRect(x, y, w, h);
};

/**
* @name Phaser.Physics.Box2D.DefaultDebugDraw#shapes
* @property {boolean} shapes - Specifies whether the debug draw should render shapes.
*/
Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "shapes", {

    get: function () {

        return this.flags & box2d.b2DrawFlags.e_shapeBit;

    },

    set: function (value) {

        if (value)
        {
            this.flags |= box2d.b2DrawFlags.e_shapeBit;
        }
        else
        {
            this.flags &= ~box2d.b2DrawFlags.e_shapeBit;
        }

    }

});

/**
* @name Phaser.Physics.Box2D.DefaultDebugDraw#joints
* @property {boolean} joints - Specifies whether the debug draw should render joints.
*/
Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "joints", {

    get: function () {

        return this.flags & box2d.b2DrawFlags.e_jointBit;

    },

    set: function (value) {

        if (value)
        {
            this.flags |= box2d.b2DrawFlags.e_jointBit;
        }
        else
        {
            this.flags &= ~box2d.b2DrawFlags.e_jointBit;
        }

    }

});

/**
* @name Phaser.Physics.Box2D.DefaultDebugDraw#aabbs
* @property {boolean} aabbs - Specifies whether the debug draw should render fixture AABBs.
*/
Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "aabbs", {

    get: function () {

        return this.flags & box2d.b2DrawFlags.e_aabbBit;

    },

    set: function (value) {

        if (value)
        {
            this.flags |= box2d.b2DrawFlags.e_aabbBit;
        }
        else
        {
            this.flags &= ~box2d.b2DrawFlags.e_aabbBit;
        }

    }

});

/**
* @name Phaser.Physics.Box2D.DefaultDebugDraw#pairs
* @property {boolean} pairs - Specifies whether the debug draw should render contact pairs.
*/
Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "pairs", {

    get: function () {

        return this.flags & box2d.b2DrawFlags.e_pairBit;

    },

    set: function (value) {

        if (value)
        {
            this.flags |= box2d.b2DrawFlags.e_pairBit;
        }
        else
        {
            this.flags &= ~box2d.b2DrawFlags.e_pairBit;
        }

    }

});

/**
* @name Phaser.Physics.Box2D.DefaultDebugDraw#centerOfMass
* @property {boolean} centerOfMass - Specifies whether the debug draw should render the center of mass of bodies.
*/
Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "centerOfMass", {

    get: function () {

        return this.flags & box2d.b2DrawFlags.e_centerOfMassBit;

    },

    set: function (value) {

        if (value)
        {
            this.flags |= box2d.b2DrawFlags.e_centerOfMassBit;
        }
        else
        {
            this.flags &= ~box2d.b2DrawFlags.e_centerOfMassBit;
        }

    }

});

/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/** 
 * This class implements a contact listener. The default behaviour is to check if the two bodies
 * that contacted had a callback set up by one of the following:
 *     Phaser.Physics.Box2D.Body.createBodyContactCallback
 *     Phaser.Physics.Box2D.Body.createCategoryContactCallback
 *     Phaser.Physics.Box2D.Body.createFixtureContactCallback
 * @constructor
 */
Phaser.Physics.Box2D.DefaultContactListener = function ()
{
};

/** 
 * Called when two fixtures begin to touch. 
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 */
Phaser.Physics.Box2D.DefaultContactListener.prototype.BeginContact = function (contact)
{
    this.handleContactBeginOrEnd(contact, true);
};

/** 
 * Called when two fixtures cease touching.
 * @export 
 * @return {void} 
 * @param {box2d.b2Contact} contact 
 */
Phaser.Physics.Box2D.DefaultContactListener.prototype.EndContact = function (contact)
{
    this.handleContactBeginOrEnd(contact, false);
};

/** 
 * Common code for begin and end contacts.
 * @export 
 * @param {box2d.b2Contact} contact 
 * @param {boolean} begin - true for a begin, false for an end 
 * @return {void} 
 */
Phaser.Physics.Box2D.DefaultContactListener.prototype.handleContactBeginOrEnd = function (contact, begin)
{
    var fA = contact.GetFixtureA();
    var fB = contact.GetFixtureB();
    var bA = fA.GetBody();
    var bB = fB.GetBody();
    var catA = fA.GetFilterData().categoryBits;
    var catB = fB.GetFilterData().categoryBits;
    var pA = bA.parent;
    var pB = bB.parent;
    
    if ( pA === void 0 || pB === void 0 ) {
        return;
    }
    
    var idA = pA.id;
    var idB = pB.id;
    
    // Check body callbacks
    if (pA._bodyContactCallbacks[idB])
    {
        pA._bodyContactCallbacks[idB].call(pA._bodyContactCallbackContext[idB], pA, pB, fA, fB, begin, contact);
    }

    if (pB._bodyContactCallbacks[idA])
    {
        pB._bodyContactCallbacks[idA].call(pB._bodyContactCallbackContext[idA], pB, pA, fB, fA, begin, contact);
    }   
        
    // Check fixture callbacks
    if (pA._fixtureContactCallbacks[fB.id])
    {
        pA._fixtureContactCallbacks[fB.id].call(pA._fixtureContactCallbackContext[fB.id], pA, pB, fA, fB, begin, contact);
    }

    if (pB._fixtureContactCallbacks[fA.id])
    {
        pB._fixtureContactCallbacks[fA.id].call(pB._fixtureContactCallbackContext[fA.id], pB, pA, fB, fA, begin, contact);
    }   
        
    if (pA._fixtureContactCallbacks[fA.id])
    {
        pA._fixtureContactCallbacks[fA.id].call(pA._fixtureContactCallbackContext[fA.id], pA, pB, fA, fB, begin, contact);
    }

    if (pB._fixtureContactCallbacks[fB.id])
    {
        pB._fixtureContactCallbacks[fB.id].call(pB._fixtureContactCallbackContext[fB.id], pB, pA, fB, fA, begin, contact);
    }
    
    // Check group callbacks
    if (pA._categoryContactCallbacks[catB])
    {
        pA._categoryContactCallbacks[catB].call(pA._categoryContactCallbackContext[catB], pA, pB, fA, fB, begin, contact);
    }

    if (pB._categoryContactCallbacks[catA])
    {
        pB._categoryContactCallbacks[catA].call(pB._categoryContactCallbackContext[catA], pB, pA, fB, fA, begin, contact);
    }
    
    if (pA._categoryContactCallbacks[catA])
    {
        pA._categoryContactCallbacks[catA].call(pA._categoryContactCallbackContext[catA], pA, pB, fA, fB, begin, contact);
    }

    if (pB._categoryContactCallbacks[catB])
    {
        pB._categoryContactCallbacks[catB].call(pB._categoryContactCallbackContext[catB], pB, pA, fB, fA, begin, contact);
    }

};

/** 
 * This is called after a contact is updated. This allows you to 
 * inspect a contact before it goes to the solver. If you are 
 * careful, you can modify the contact manifold (e.g. disable 
 * contact). 
 * @export 
 * @param {box2d.b2Contact} contact 
 * @param {box2d.b2Manifold} oldManifold 
 * @return {void} 
 */
Phaser.Physics.Box2D.DefaultContactListener.prototype.PreSolve = function (contact, oldManifold)
{
    var fA = contact.GetFixtureA();
    var fB = contact.GetFixtureB();
    var bA = fA.GetBody();
    var bB = fB.GetBody();
    var catA = fA.GetFilterData().categoryBits;
    var catB = fB.GetFilterData().categoryBits;
    var pA = bA.parent;
    var pB = bB.parent;
    
    if ( pA === void 0 || pB === void 0 ) {
        return;
    }
    
    var idA = pA.id;
    var idB = pB.id;

    // Check body callbacks
    if (pA._bodyPresolveCallbacks[idB])
    {
        pA._bodyPresolveCallbacks[idB].call(pA._bodyPresolveCallbackContext[idB], pA, pB, fA, fB, contact, oldManifold);
    }

    if (pB._bodyPresolveCallbacks[idA])
    {
        pB._bodyPresolveCallbacks[idA].call(pB._bodyPresolveCallbackContext[idA], pB, pA, fB, fA, contact, oldManifold);
    }   
        
    // Check fixture callbacks
    if (pA._fixturePresolveCallbacks[fB.id])
    {
        pA._fixturePresolveCallbacks[fB.id].call(pA._fixturePresolveCallbackContext[fB.id], pA, pB, fA, fB, contact, oldManifold);
    }

    if (pB._fixturePresolveCallbacks[fA.id])
    {
        pB._fixturePresolveCallbacks[fA.id].call(pB._fixturePresolveCallbackContext[fA.id], pB, pA, fB, fA, contact, oldManifold);
    }
    
    // Check group callbacks
    if (pA._categoryPresolveCallbacks[catB])
    {
        pA._categoryPresolveCallbacks[catB].call(pA._categoryPresolveCallbackContext[catB], pA, pB, fA, fB, contact, oldManifold);
    }

    if (pB._categoryPresolveCallbacks[catA])
    {
        pB._categoryPresolveCallbacks[catA].call(pB._categoryPresolveCallbackContext[catA], pB, pA, fB, fA, contact, oldManifold);
    }

};

/** 
 * This lets you inspect a contact after the solver is finished. 
 * @export 
 * @param {box2d.b2Contact} contact
 * @param {box2d.b2ContactImpulse} impulse
 * @return {void} 
 */
Phaser.Physics.Box2D.DefaultContactListener.prototype.PostSolve = function (contact, impulse)
{
    var fA = contact.GetFixtureA();
    var fB = contact.GetFixtureB();
    var bA = fA.GetBody();
    var bB = fB.GetBody();
    var catA = fA.GetFilterData().categoryBits;
    var catB = fB.GetFilterData().categoryBits;
    var pA = bA.parent;
    var pB = bB.parent;
    
    if ( pA === void 0 || pB === void 0 ) {
        return;
    }
    
    var idA = pA.id;
    var idB = pB.id;

    // Check body callbacks
    if (pA._bodyPostsolveCallbacks[idB])
    {
        pA._bodyPostsolveCallbacks[idB].call(pA._bodyPostsolveCallbackContext[idB], pA, pB, fA, fB, contact, impulse);
    }

    if (pB._bodyPostsolveCallbacks[idA])
    {
        pB._bodyPostsolveCallbacks[idA].call(pB._bodyPostsolveCallbackContext[idA], pB, pA, fB, fA, contact, impulse);
    }   
        
    // Check fixture callbacks
    if (pA._fixturePostsolveCallbacks[fB.id])
    {
        pA._fixturePostsolveCallbacks[fB.id].call(pA._fixturePostsolveCallbackContext[fB.id], pA, pB, fA, fB, contact, impulse);
    }

    if (pB._fixturePostsolveCallbacks[fA.id])
    {
        pB._fixturePostsolveCallbacks[fA.id].call(pB._fixturePostsolveCallbackContext[fA.id], pB, pA, fB, fA, contact, impulse);
    }
    
    // Check group callbacks
    if (pA._categoryPostsolveCallbacks[catB])
    {
        pA._categoryPostsolveCallbacks[catB].call(pA._categoryPostsolveCallbackContext[catB], pA, pB, fA, fB, contact, impulse);
    }

    if (pB._categoryPostsolveCallbacks[catA])
    {
        pB._categoryPostsolveCallbacks[catA].call(pB._categoryPostsolveCallbackContext[catA], pB, pA, fB, fA, contact, impulse);
    }

};

/**
* @author       Chris Campbell <iforce2d@gmail.com>
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2015 Photon Storm Ltd.
* @license      {@link http://choosealicense.com/licenses/no-license/|No License}
*/

/**
* A generic polygon class. Includes functions for decomposing into convex polygons.
* Use one of the 'set' functions to define the vertices.
*
* @class Phaser.Physics.Box2D.Polygon
*/
Phaser.Physics.Box2D.Polygon = function () {
    this.vertices = [];
};

/**
 * Sets the vertices of this polygon from a flat array of xy coords, eg [x, y, x, y, x, y, ...]
 * @param {Array} flatXYCoords - a flat array of xy coordinates
 */
Phaser.Physics.Box2D.Polygon.prototype.setFromFlatXYCoords = function(flatXYCoords) {

    this.vertices = [];

    for (var i = 0; i < flatXYCoords.length / 2; i++) {
        this.vertices.push( { x: flatXYCoords[2*i], y: flatXYCoords[2*i+1] } );
    }

};

/**
 * Sets the vertices of this polygon from an array of xy objects, eg [ {x, y}, {x, y}, {x, y}, ...]
 * @param {Array} xyObjects - 
 */
Phaser.Physics.Box2D.Polygon.prototype.setFromXYObjects = function(xyObjects) {
    this.vertices = xyObjects.concat();
};

/**
 * Appends a vertex to this polygon
 * @param {object} vertex - an object containing x and y number properties
 */
Phaser.Physics.Box2D.Polygon.prototype.addVertex = function(vertex) {
    this.vertices.push(vertex);
};

/**
 * Returns the vertex at the given position
 */
Phaser.Physics.Box2D.Polygon.prototype.at = function(i) {

    var s = this.vertices.length;
    return this.vertices[i < 0 ? i % s + s : i % s];

};

/**
 * Checks if two indices are adjacent or the same on this polygon
 * For example, on a polygon with 5 vertices, indices 4 and 0 are adjacent.
 * @param {number} a - first index
 * @param {number} b - second index
 * @return {boolean} true if the two indices are adjacent or equal
 */
Phaser.Physics.Box2D.Polygon.prototype.indicesAreAdjacent = function (a, b) {

    a = a % this.vertices.length;
    b = b % this.vertices.length;
    
    if ( a == b ) { return true; }
    var diff = Math.abs(a-b);
    if ( diff < 2 ) { return true; }
    if ( diff == this.vertices.length-1 ) { return true; }
    
    return false;
};

/**
 * Returns the area of the triangle formed by three vertices of this polygon.
 * Result will be negative for clockwise windings.
 * @param {number} a - index of first vertex
 * @param {number} b - index of second vertex
 * @param {number} c - index of third vertex
 * @return {number} The area of the triangle formed by the three vertices
 */
Phaser.Physics.Box2D.Polygon.prototype.areaInTriangle = function (a, b, c) {

    a = this.at(a);
    b = this.at(b);
    c = this.at(c);

    return (((b.x - a.x)*(c.y - a.y))-((c.x - a.x)*(b.y - a.y))) * 0.5;

};

/**
 * Checks if the polygon outline turns left at the given vertex, when moving around
 * the outline in counter-clockwise order. Polygon must be made CCW first!
 * @return {boolean} True if outline turns left at the given vertex
 */
Phaser.Physics.Box2D.Polygon.prototype.left = function(a, b, c) {    

    return this.areaInTriangle(a, b, c) > 0;

};

/**
 * Checks if the polygon outline turns left or stays straight at the given vertex, when moving around
 * the outline in counter-clockwise order. Polygon must be made CCW first!
 * @return {boolean} True if outline turns left at the given vertex or stays straight
 */
Phaser.Physics.Box2D.Polygon.prototype.leftOn = function(a, b, c) {

    return this.areaInTriangle(a, b, c) >= 0;

};

/**
 * Checks if the polygon outline turns right at the given vertex, when moving around
 * the outline in counter-clockwise order. Polygon must be made CCW first!
 * @return {boolean} True if outline turns right at the given vertex
 */
Phaser.Physics.Box2D.Polygon.prototype.right = function(a, b, c) {

    return this.areaInTriangle(a, b, c) < 0;

};

/**
 * Checks if the polygon outline turns right or stays straight at the given vertex, when moving around
 * the outline in counter-clockwise order. Polygon must be made CCW first!
 * @return {boolean} True if outline turns right at the given vertex or stays straight
 */
Phaser.Physics.Box2D.Polygon.prototype.rightOn = function(a, b, c) {

    return this.areaInTriangle(a, b, c) <= 0;

};

/**
 * Finds the squared distance between two points
 * @param {object} a - an object with x and y number properties
 * @param {object} b - an object with x and y number properties
 * @return {number} The square of the distance between the two points
 */
Phaser.Physics.Box2D.Polygon.sqdist = function(a, b) {

    var dx = b.x - a.x;
    var dy = b.y - a.y;

    return dx * dx + dy * dy;

};

/**
 * Ensures this polygon is wound counter-clockwise.
 * @return {boolean} true if the polygon winding was reversed
 */
Phaser.Physics.Box2D.Polygon.prototype.makeCCW = function() {
    
    // Find bottom right point
    var br = 0;

    for (var i = 1, len = this.vertices.length; i < len; i++)
    {
        if (this.at(i).y < this.at(br).y || (this.at(i).y === this.at(br).y && this.at(i).x > this.at(br).x))
        {
            br = i;
        }
    }

    // Reverse poly if clockwise
    if (!this.left(br - 1, br, br + 1))
    {
        this.vertices.reverse();
        return true;
    }
    
    return false;

};

/**
 * Checks if this polygon is convex.
 * @return {boolean} True if the polygon is convex.
 */
Phaser.Physics.Box2D.Polygon.prototype.isConvex = function () {
    
    var havePositive = false;
    var haveNegative = false;
    
    for (var i = 0, len = this.vertices.length; i < len; i++)
    {
        var i0 = i;
        var i1 = (i + 1) % len;
        var i2 = (i + 2) % len;

        if (this.areaInTriangle(this.vertices[i0], this.vertices[i1], this.vertices[i2]) > 0)
        {
            havePositive = true;
        }
        else
        {
            haveNegative = true;
        }
    }

    return haveNegative ^ havePositive;

};

/**
 * Checks if the given vertex is reflex (concave causing). Polygon must be made CCW first!
 * @param {object} i - the index of the vertex to check
 * @return {number} true if the given vertex is a reflex vertex
 */
Phaser.Physics.Box2D.Polygon.prototype.isReflex = function (i) {

    return this.right(i - 1, i, i + 1);

};

/**
 * Check if two vectors are equal.
 * @param {object} v0 - an object with x and y properties
 * @param {object} v1 - an object with x and y properties
 * @return {boolean} true if the two vector are the same
 */
Phaser.Physics.Box2D.Polygon.areVecsEqual = function(v0, v1) {

    return v0.x == v1.x && v0.y == v1.y;

};

/**
 * Check if two lines intersect each other.
 * @param {object} v0 - an object with x and y properties (first point of first line)
 * @param {object} v1 - an object with x and y properties (second point of first line)
 * @param {object} t0 - an object with x and y properties (first point of second line)
 * @param {object} t1 - an object with x and y properties (second point of second line)
 * @return {number} The intersection point, or null if the lines do not cross
 */
Phaser.Physics.Box2D.Polygon.linesCross = function(v0, v1, t0, t1) {

    if (Phaser.Physics.Box2D.Polygon.areVecsEqual(v1,t0) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v0,t0) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v1,t1) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v0,t1))
    {
        return null;
    }

    var vnormal = {};

    box2d.b2SubVV(v1, v0, vnormal);
    box2d.b2CrossVS(vnormal, 1, vnormal);

    var v0d = box2d.b2DotVV(vnormal, v0);
    var t0d = box2d.b2DotVV(vnormal, t0);
    var t1d = box2d.b2DotVV(vnormal, t1);

    if ( t0d > v0d && t1d > v0d )
    {
        return null;
    }

    if ( t0d < v0d && t1d < v0d )
    {
        return null;
    }

    var tnormal = {};
    box2d.b2SubVV(t1, t0, tnormal);
    box2d.b2CrossVS(tnormal, 1, tnormal);

    var t0d = box2d.b2DotVV(tnormal, t0);
    var v0d = box2d.b2DotVV(tnormal, v0);
    var v1d = box2d.b2DotVV(tnormal, v1);

    if ( v0d > t0d && v1d > t0d )
    {
        return null;
    }

    if ( v0d < t0d && v1d < t0d )
    {
        return null;
    }

    var f = (t0d - v0d) / (v1d - v0d);

    var intersectionPoint = { x: v0.x + f * (v1.x-v0.x), y: v0.y + f * (v1.y-v0.y) };

    return intersectionPoint;

};

/**
 * Check if two vertices of a polygon have a clear line of sight to each other. "Line of sight" means
 * that the line between them is not intersected by any other edges of the polygon.
 * @param {Array} vertices - array of vertices representing the polygon
 * @param {number} a - index of first vertex
 * @param {number} b - index of second vertex
 * @return {boolean} true if the two vertices are not adjacent and can 'see' each other.
 */
Phaser.Physics.Box2D.Polygon.prototype.canSee = function (a, b) {

    if (this.indicesAreAdjacent(a, b) )
    {
        return false;
    }
        
    if (this.leftOn(a + 1, a, b) && this.rightOn(a - 1, a, b))
    {
        return false;
    }
    
    for (var i = 0; i < this.vertices.length; ++i)
    {
        // for each edge
        if ((i + 1) % this.vertices.length == a || i == a)
        {
            // ignore incident edges
            continue;
        } 

        if (this.leftOn(a, b, i + 1) && this.rightOn(a, b, i))
        { 
            // if diag intersects an edge
            if (Phaser.Physics.Box2D.Polygon.linesCross(this.at(a), this.at(b), this.at(i), this.at(i + 1)))
            {
                return false;
            }
        }
    }

    return true;
    
};

/** Copies a subset of the vertices of this polygon to make a new one. Start and end points will be included.
 * @param {number} i - index of the first vertex
 * @param {number} j - index of the second vertex
 * @return {Array} array representing a sub-polygon
 */
Phaser.Physics.Box2D.Polygon.prototype.subPolygon = function (i, j) {

    var p = new Phaser.Physics.Box2D.Polygon();

    if (i < j)
    {
        //p.v.insert(p.v.begin(), v.begin() + i, v.begin() + j + 1);
        for (var n = i; n < j + 1; n++)
        {
            p.addVertex( this.at(n) );
        }
    }
    else
    {
        //p.v.insert(p.v.begin(), v.begin() + i, v.end());
        //p.v.insert(p.v.end(), v.begin(), v.begin() + j + 1);
        for (var n = i; n < this.vertices.length; n++)
        {
            p.addVertex( this.at(n) );
        }

        for (var n = 0; n < j + 1; n++)
        {
            p.addVertex( this.at(n) );
        }
    }
    
    return p;

};

/**
 * Returns an array of the individual convex polygons which make up the given concave polygon.
 * This will return a near-optimal (lowest number of sub-polygons) decomposition and is
 * astoundingly slow for polygons with more than about 8 vertices. You most likely will
 * not want to use this at runtime, but it could be useful as a pre-process for something.
 * Please try the normal 'decompose' function instead.
 * @return {Array} Array of objects containing pairs of indices which should be joined
 */
Phaser.Physics.Box2D.Polygon.prototype.decomposeOptimal = function (level) {

    if (typeof level === 'undefined') { level = 0; }
    
    if (level > 1)
    {
        return this.vertices;
    }
        
    this.makeCCW();
      
    var min = [];
    var tmp1 = [];
    var tmp2 = [];    
    
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; i++)
    {
        if (this.isReflex(i))
        {
            for (var j = 0; j < this.vertices.length; j++)
            {
                if (this.canSee(i, j))
                {
                    tmp1 = this.subPolygon(i, j).decompose(level+1);
                    tmp2 = this.subPolygon(j, i).decompose(level+1);                    

                    if (tmp1.length + tmp2.length < nDiags)
                    {
                        min = tmp1.concat(tmp2);
                        nDiags = min.length;
                    }
                }
            }
        }
    }
    
    if (min.length === 0)
    {
        min.push(this.vertices);
    }
    
    return min;

};

/**
 * Returns an array of the individual convex polygons which make up the given concave polygon.
 * @return {Array} Array of arrays containing the vertex positions of sub-polygons. Vertex positions are an object like {x,y}
 */
Phaser.Physics.Box2D.Polygon.prototype.decompose = function (level) {

    if (typeof level === 'undefined') { level = 0; }
    
    this.makeCCW();
      
    var min = [];
    
    var bestDivision = Number.MAX_VALUE;
    var bestI;
    var bestJ;
    var foundReflex = false;
    
    for (var i = 0; i < this.vertices.length; i++)
    {
        if (this.isReflex(i))
        {
            foundReflex = true;
            var v0 = this.at(i);

            for (var j = 0; j < this.vertices.length; j++)
            {
                if (this.canSee(i, j))
                {
                    var v1 = this.at(j);
                    var dx = v1.x - v0.x;
                    var dy = v1.y - v0.y;
                    var distanceSquared = (dx * dx) * (dy * dy);

                    if (distanceSquared < bestDivision)
                    {
                        bestI = i;
                        bestJ = j;
                        bestDivision = distanceSquared;
                    }
                }
            }
        }
    }
    
    // Specific to Box2D, force to 8 vertices or less
    if (!foundReflex && this.vertices.length > 8 )
    {
        bestI = 0;
        bestJ = Math.floor(this.vertices.length / 2);
        foundReflex = true;
    }
    
    if (foundReflex)
    {
        var tmp1 = this.subPolygon(bestI, bestJ).decompose(level+1);
        var tmp2 = this.subPolygon(bestJ, bestI).decompose(level+1);        
        min = tmp1.concat(tmp2);
    }
    
    if (min.length === 0)
    {
        min.push(this.vertices);
    }
    
    return min;

};
